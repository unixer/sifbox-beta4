diff -urN linux-3.4.3/drivers/media/common/Makefile linux-3.4.3.dd/drivers/media/common/Makefile
--- linux-3.4.3/drivers/media/common/Makefile	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/common/Makefile	2012-06-18 22:34:38.484032284 +0200
@@ -4,3 +4,4 @@
 obj-y += tuners/
 obj-$(CONFIG_VIDEO_SAA7146) += saa7146.o
 obj-$(CONFIG_VIDEO_SAA7146_VV) += saa7146_vv.o
+obj-$(CONFIG_SAA716X_CORE) += saa716x/
diff -urN linux-3.4.3/drivers/media/common/saa716x/Kconfig linux-3.4.3.dd/drivers/media/common/saa716x/Kconfig
--- linux-3.4.3/drivers/media/common/saa716x/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/Kconfig	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,63 @@
+menuconfig SAA716X_SUPPORT
+	bool "Support for SAA716x family from NXP/Philips"
+	depends on PCI && I2C
+	help
+	  support for saa716x
+
+if SAA716X_SUPPORT
+config SAA716X_CORE
+	tristate "SAA7160/1/2 PCI Express bridge based devices"
+	depends on PCI && I2C
+
+	help
+	  Support for PCI cards based on the SAA7160/1/2 PCI Express bridge.
+
+	  Say Y if you own such a device and want to use it.
+
+config DVB_SAA716X_BUDGET
+	tristate "SAA7160/1/2 based Budget PCIe cards (DVB only)"
+	depends on SAA716X_CORE && DVB_CORE
+
+	help
+	  Support for the SAA7160/1/2 based Budget PCIe DVB cards
+	  Currently supported devices are:
+
+	  * KNC1 Dual S2 (DVB-S, DVB-S/S2)
+	  * Twinhan/Azurewave VP-1028 (DVB-S)
+	  * Twinhan/Azurewave VP-3071 (DVB-T x2)
+	  * Twinhan/Azurewave VP-6002 (DVB-S)
+
+	  Say Y if you own such a device and want to use it.
+
+config DVB_SAA716X_HYBRID
+	tristate "SAA7160/1/2 based Hybrid PCIe cards (DVB + Analog)"
+	depends on SAA716X_CORE && DVB_CORE
+
+	help
+	  Support for the SAA7160/1/2 based Hybrid PCIe DVB cards
+	  Currently supported devices are:
+
+	  * Avermedia H-788 (DVB-T)
+	  * Avermedia HC-82 (DVB-T)
+	  * NXP Reference (Atlantis) (DVB-T x2)
+	  * NXP Reference (Nemo) (DVB-T)
+	  * Twinhan/Azurewave VP-6090 (DVB-S x2, DVB-T x2)
+
+	  Say Y if you own such a device and want to use it.
+
+config DVB_SAA716X_FF
+	tristate "SAA7160/1/2 based Full Fledged PCIe cards"
+	depends on SAA716X_CORE && DVB_CORE
+	depends on INPUT # IR
+
+	help
+	  Support for the SAA7160/1/2 based  Full fledged PCIe DVB cards
+	  These cards do feature a hardware MPEG decoder and other
+	  peripherals. Also known as Premium cards.
+	  Currently supported devices are:
+
+	  * Technotrend S2 6400 Dual S2 HD (DVB-S/S2 x2)
+
+	  Say Y if you own such a device and want to use it.
+
+endif # SAA716X_SUPPORT
diff -urN linux-3.4.3/drivers/media/common/saa716x/Makefile linux-3.4.3.dd/drivers/media/common/saa716x/Makefile
--- linux-3.4.3/drivers/media/common/saa716x/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/Makefile	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,26 @@
+saa716x_core-objs	:= saa716x_pci.o	\
+			   saa716x_i2c.o	\
+			   saa716x_cgu.o	\
+			   saa716x_msi.o	\
+			   saa716x_dma.o	\
+			   saa716x_vip.o	\
+			   saa716x_aip.o	\
+			   saa716x_phi.o	\
+			   saa716x_boot.o	\
+			   saa716x_fgpi.o	\
+			   saa716x_adap.o	\
+			   saa716x_gpio.o	\
+			   saa716x_greg.o	\
+			   saa716x_rom.o	\
+			   saa716x_spi.o
+
+saa716x_ff-objs		:= saa716x_ff_main.o	\
+                           saa716x_ff_cmd.o	\
+			   saa716x_ff_ir.o
+
+obj-$(CONFIG_SAA716X_CORE)	  += saa716x_core.o
+obj-$(CONFIG_DVB_SAA716X_BUDGET)  += saa716x_budget.o
+obj-$(CONFIG_DVB_SAA716X_HYBRID)  += saa716x_hybrid.o
+obj-$(CONFIG_DVB_SAA716X_FF)	  += saa716x_ff.o
+
+EXTRA_CFLAGS = -Idrivers/media/dvb/dvb-core/
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_adap.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_adap.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_adap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_adap.c	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,248 @@
+#include <linux/bitops.h>
+
+#include "dmxdev.h"
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dvb_frontend.h"
+
+#include "saa716x_mod.h"
+#include "saa716x_spi.h"
+#include "saa716x_adap.h"
+#include "saa716x_i2c.h"
+#include "saa716x_gpio.h"
+#include "saa716x_priv.h"
+
+
+DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
+
+
+void saa716x_dma_start(struct saa716x_dev *saa716x, u8 adapter)
+{
+	struct fgpi_stream_params params;
+
+	dprintk(SAA716x_DEBUG, 1, "SAA716x Start DMA engine for Adapter:%d", adapter);
+
+	params.bits		= 8;
+	params.samples		= 188;
+	params.lines		= 348;
+	params.pitch		= 188;
+	params.offset		= 0;
+	params.page_tables	= 0;
+	params.stream_type	= FGPI_TRANSPORT_STREAM;
+	params.stream_flags	= 0;
+
+	saa716x_fgpi_start(saa716x, saa716x->config->adap_config[adapter].ts_port, &params);
+}
+
+void saa716x_dma_stop(struct saa716x_dev *saa716x, u8 adapter)
+{
+	dprintk(SAA716x_DEBUG, 1, "SAA716x Stop DMA engine for Adapter:%d", adapter);
+
+	saa716x_fgpi_stop(saa716x, saa716x->config->adap_config[adapter].ts_port);
+}
+
+static int saa716x_dvb_start_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct dvb_demux *dvbdmx		= dvbdmxfeed->demux;
+	struct saa716x_adapter *saa716x_adap	= dvbdmx->priv;
+	struct saa716x_dev *saa716x		= saa716x_adap->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "SAA716x DVB Start feed");
+	if (!dvbdmx->dmx.frontend) {
+		dprintk(SAA716x_DEBUG, 1, "no frontend ?");
+		return -EINVAL;
+	}
+	saa716x_adap->feeds++;
+	dprintk(SAA716x_DEBUG, 1, "SAA716x start feed, feeds=%d",
+		saa716x_adap->feeds);
+
+	if (saa716x_adap->feeds == 1) {
+		dprintk(SAA716x_DEBUG, 1, "SAA716x start feed & dma");
+		saa716x_dma_start(saa716x, saa716x_adap->count);
+	}
+
+	return saa716x_adap->feeds;
+}
+
+static int saa716x_dvb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)
+{
+	struct dvb_demux *dvbdmx		= dvbdmxfeed->demux;
+	struct saa716x_adapter *saa716x_adap	= dvbdmx->priv;
+	struct saa716x_dev *saa716x		= saa716x_adap->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "SAA716x DVB Stop feed");
+	if (!dvbdmx->dmx.frontend) {
+		dprintk(SAA716x_DEBUG, 1, "no frontend ?");
+		return -EINVAL;
+	}
+	saa716x_adap->feeds--;
+	if (saa716x_adap->feeds == 0) {
+		dprintk(SAA716x_DEBUG, 1, "saa716x stop feed and dma");
+		saa716x_dma_stop(saa716x, saa716x_adap->count);
+	}
+
+	return 0;
+}
+
+int __devinit saa716x_dvb_init(struct saa716x_dev *saa716x)
+{
+	struct saa716x_adapter *saa716x_adap = saa716x->saa716x_adap;
+	struct saa716x_config *config = saa716x->config;
+	int result, i;
+
+	mutex_init(&saa716x->adap_lock);
+
+	for (i = 0; i < config->adapters; i++) {
+
+		dprintk(SAA716x_DEBUG, 1, "dvb_register_adapter");
+		if (dvb_register_adapter(&saa716x_adap->dvb_adapter,
+					 "SAA716x dvb adapter",
+					 THIS_MODULE,
+					 &saa716x->pdev->dev,
+					 adapter_nr) < 0) {
+
+			dprintk(SAA716x_ERROR, 1, "Error registering adapter");
+			return -ENODEV;
+		}
+
+		saa716x_adap->count			= i;
+
+		saa716x_adap->dvb_adapter.priv		= saa716x_adap;
+		saa716x_adap->demux.dmx.capabilities	= DMX_TS_FILTERING	|
+							  DMX_SECTION_FILTERING	|
+							  DMX_MEMORY_BASED_FILTERING;
+
+		saa716x_adap->demux.priv		= saa716x_adap;
+		saa716x_adap->demux.filternum		= 256;
+		saa716x_adap->demux.feednum		= 256;
+		saa716x_adap->demux.start_feed		= saa716x_dvb_start_feed;
+		saa716x_adap->demux.stop_feed		= saa716x_dvb_stop_feed;
+		saa716x_adap->demux.write_to_decoder	= NULL;
+
+		dprintk(SAA716x_DEBUG, 1, "dvb_dmx_init");
+		if ((result = dvb_dmx_init(&saa716x_adap->demux)) < 0) {
+			dprintk(SAA716x_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
+			goto err0;
+		}
+
+		saa716x_adap->dmxdev.filternum		= 256;
+		saa716x_adap->dmxdev.demux		= &saa716x_adap->demux.dmx;
+		saa716x_adap->dmxdev.capabilities	= 0;
+
+		dprintk(SAA716x_DEBUG, 1, "dvb_dmxdev_init");
+		if ((result = dvb_dmxdev_init(&saa716x_adap->dmxdev,
+					      &saa716x_adap->dvb_adapter)) < 0) {
+
+			dprintk(SAA716x_ERROR, 1, "dvb_dmxdev_init failed, ERROR=%d", result);
+			goto err1;
+		}
+
+		saa716x_adap->fe_hw.source = DMX_FRONTEND_0;
+
+		if ((result = saa716x_adap->demux.dmx.add_frontend(&saa716x_adap->demux.dmx,
+								   &saa716x_adap->fe_hw)) < 0) {
+
+			dprintk(SAA716x_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
+			goto err2;
+		}
+
+		saa716x_adap->fe_mem.source = DMX_MEMORY_FE;
+
+		if ((result = saa716x_adap->demux.dmx.add_frontend(&saa716x_adap->demux.dmx,
+								   &saa716x_adap->fe_mem)) < 0) {
+			dprintk(SAA716x_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
+			goto err3;
+		}
+
+		if ((result = saa716x_adap->demux.dmx.connect_frontend(&saa716x_adap->demux.dmx,
+								       &saa716x_adap->fe_hw)) < 0) {
+
+			dprintk(SAA716x_ERROR, 1, "dvb_dmx_init failed, ERROR=%d", result);
+			goto err4;
+		}
+
+		dvb_net_init(&saa716x_adap->dvb_adapter, &saa716x_adap->dvb_net, &saa716x_adap->demux.dmx);
+//		tasklet_init(&saa716x_adap->tasklet, saa716x_dma_xfer, (unsigned long) saa716x);
+		dprintk(SAA716x_DEBUG, 1, "Frontend Init");
+		saa716x_adap->saa716x = saa716x;
+
+		if (config->frontend_attach) {
+			result = config->frontend_attach(saa716x_adap, i);
+			if (result < 0)
+				dprintk(SAA716x_ERROR, 1, "SAA716x frontend attach failed");
+
+			if (saa716x_adap->fe == NULL) {
+				dprintk(SAA716x_ERROR, 1, "A frontend driver was not found for [%04x:%04x] subsystem [%04x:%04x]\n",
+					saa716x->pdev->vendor,
+					saa716x->pdev->device,
+					saa716x->pdev->subsystem_vendor,
+					saa716x->pdev->subsystem_device);
+			} else {
+				result = dvb_register_frontend(&saa716x_adap->dvb_adapter, saa716x_adap->fe);
+				if (result < 0) {
+					dprintk(SAA716x_ERROR, 1, "SAA716x register frontend failed");
+					goto err6;
+				}
+			}
+
+		} else {
+			dprintk(SAA716x_ERROR, 1, "Frontend attach = NULL");
+		}
+
+		saa716x_fgpi_init(saa716x, config->adap_config[i].ts_port,
+				  config->adap_config[i].worker);
+
+		saa716x_adap++;
+	}
+
+
+	return 0;
+
+	/* Error conditions */
+err6:
+	dvb_frontend_detach(saa716x_adap->fe);
+err4:
+	saa716x_adap->demux.dmx.remove_frontend(&saa716x_adap->demux.dmx, &saa716x_adap->fe_mem);
+err3:
+	saa716x_adap->demux.dmx.remove_frontend(&saa716x_adap->demux.dmx, &saa716x_adap->fe_hw);
+err2:
+	dvb_dmxdev_release(&saa716x_adap->dmxdev);
+err1:
+	dvb_dmx_release(&saa716x_adap->demux);
+err0:
+	dvb_unregister_adapter(&saa716x_adap->dvb_adapter);
+
+	return result;
+}
+EXPORT_SYMBOL(saa716x_dvb_init);
+
+void __devexit saa716x_dvb_exit(struct saa716x_dev *saa716x)
+{
+	struct saa716x_adapter *saa716x_adap = saa716x->saa716x_adap;
+	int i;
+
+	for (i = 0; i < saa716x->config->adapters; i++) {
+
+		saa716x_fgpi_exit(saa716x, saa716x->config->adap_config[i].ts_port);
+
+		if (saa716x_adap->fe) {
+			dvb_unregister_frontend(saa716x_adap->fe);
+			dvb_frontend_detach(saa716x_adap->fe);
+		}
+
+//		tasklet_kill(&saa716x->tasklet);
+		dvb_net_release(&saa716x_adap->dvb_net);
+		saa716x_adap->demux.dmx.remove_frontend(&saa716x_adap->demux.dmx, &saa716x_adap->fe_mem);
+		saa716x_adap->demux.dmx.remove_frontend(&saa716x_adap->demux.dmx, &saa716x_adap->fe_hw);
+		dvb_dmxdev_release(&saa716x_adap->dmxdev);
+		dvb_dmx_release(&saa716x_adap->demux);
+
+		dprintk(SAA716x_DEBUG, 1, "dvb_unregister_adapter");
+		dvb_unregister_adapter(&saa716x_adap->dvb_adapter);
+
+		saa716x_adap++;
+	}
+
+	return;
+}
+EXPORT_SYMBOL(saa716x_dvb_exit);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_adap.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_adap.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_adap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_adap.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,9 @@
+#ifndef __SAA716x_ADAP_H
+#define __SAA716x_ADAP_H
+
+struct saa716x_dev;
+
+extern int saa716x_dvb_init(struct saa716x_dev *saa716x);
+extern void saa716x_dvb_exit(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_ADAP_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_aip.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_aip.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,20 @@
+#include <linux/kernel.h>
+
+#include "saa716x_mod.h"
+#include "saa716x_aip_reg.h"
+#include "saa716x_spi.h"
+#include "saa716x_aip.h"
+#include "saa716x_priv.h"
+
+int saa716x_aip_status(struct saa716x_dev *saa716x, u32 dev)
+{
+	return SAA716x_EPRD(dev, AI_CTL) == 0 ? 0 : -1;
+}
+EXPORT_SYMBOL_GPL(saa716x_aip_status);
+
+void saa716x_aip_disable(struct saa716x_dev *saa716x)
+{
+	SAA716x_EPWR(AI0, AI_CTL, 0x00);
+	SAA716x_EPWR(AI1, AI_CTL, 0x00);
+}
+EXPORT_SYMBOL_GPL(saa716x_aip_disable);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_aip.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_aip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,9 @@
+#ifndef __SAA716x_AIP_H
+#define __SAA716x_AIP_H
+
+struct saa716x_dev;
+
+extern int saa716x_aip_status(struct saa716x_dev *saa716x, u32 dev);
+extern void saa716x_aip_disable(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_AIP_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_aip_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_aip_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_aip_reg.h	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,62 @@
+#ifndef __SAA716x_AIP_REG_H
+#define __SAA716x_AIP_REG_H
+
+/* -------------- AI Registers ---------------- */
+
+#define AI_STATUS			0x000
+#define AI_BUF1_ACTIVE			(0x00000001 <<  4)
+#define AI_OVERRUN			(0x00000001 <<  3)
+#define AI_HBE				(0x00000001 <<  2)
+#define AI_BUF2_FULL			(0x00000001 <<  1)
+#define AI_BUF1_FULL			(0x00000001 <<  0)
+
+#define AI_CTL				0x004
+#define AI_RESET			(0x00000001 <<  31)
+#define AI_CAP_ENABLE			(0x00000001 <<  30)
+#define AI_CAP_MODE			(0x00000003 <<  28)
+#define AI_SIGN_CONVERT			(0x00000001 <<  27)
+#define AI_EARLYMODE			(0x00000001 <<  26)
+#define AI_DIAGMODE			(0x00000001 <<  25)
+#define AI_RAWMODE			(0x00000001 <<  24)
+#define AI_OVR_INTEN			(0x00000001 <<   7)
+#define AI_HBE_INTEN			(0x00000001 <<   6)
+#define AI_BUF2_INTEN			(0x00000001 <<   5)
+#define AI_BUF1_INTEN			(0x00000001 <<   4)
+#define AI_ACK_OVR			(0x00000001 <<   3)
+#define AI_ACK_HBE			(0x00000001 <<   2)
+#define AI_ACK2				(0x00000001 <<   1)
+#define AI_ACK1				(0x00000001 <<   0)
+
+#define AI_SERIAL			0x008
+#define AI_SER_MASTER			(0x00000001 <<  31)
+#define AI_DATAMODE			(0x00000001 <<  30)
+#define AI_FRAMEMODE			(0x00000003 <<  28)
+#define AI_CLOCK_EDGE			(0x00000001 <<  27)
+#define AI_SSPOS4			(0x00000001 <<  19)
+#define AI_NR_CHAN			(0x00000003 <<  17)
+#define AI_WSDIV			(0x000001ff <<   8)
+#define AI_SCKDIV			(0x000000ff <<   0)
+
+#define AI_FRAMING			0x00c
+#define AI_VALIDPOS			(0x000001ff << 22)
+#define AI_LEFTPOS			(0x000001ff << 13)
+#define AI_RIGHTPOS			(0x000001ff <<  4)
+#define AI_SSPOS_3_0			(0x0000000f <<  0)
+
+#define AI_BASE1			0x014
+#define AI_BASE2			0x018
+#define AI_BASE				(0x03ffffff <<  6)
+
+#define AI_SIZE				0x01c
+#define AI_SAMPLE_SIZE			(0x03ffffff <<  6)
+
+#define AI_INT_ACK			0x020
+#define AI_ACK_OVR			(0x00000001 <<  3)
+#define AI_ACK_HBE			(0x00000001 <<  2)
+#define AI_ACK2				(0x00000001 <<  1)
+#define AI_ACK1				(0x00000001 <<  0)
+
+#define AI_PWR_DOWN			0xff4
+#define AI_PWR_DWN			(0x00000001 <<  0)
+
+#endif /* __SAA716x_AIP_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_boot.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_boot.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_boot.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_boot.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,319 @@
+#include <linux/delay.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_greg_reg.h"
+#include "saa716x_cgu_reg.h"
+#include "saa716x_vip_reg.h"
+#include "saa716x_aip_reg.h"
+#include "saa716x_msi_reg.h"
+#include "saa716x_dma_reg.h"
+#include "saa716x_gpio_reg.h"
+#include "saa716x_fgpi_reg.h"
+#include "saa716x_dcs_reg.h"
+
+#include "saa716x_boot.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+static int saa716x_ext_boot(struct saa716x_dev *saa716x)
+{
+	/* Write GREG boot_ready to 0
+	 * DW_0 = 0x0001_2018
+	 * DW_1 = 0x0000_0000
+	 */
+	SAA716x_EPWR(GREG, GREG_RSTU_CTRL, 0x00000000);
+
+	/* Clear VI0 interrupt
+	 * DW_2 = 0x0000_0fe8
+	 * DW_3 = 0x0000_03ff
+	 */
+	SAA716x_EPWR(VI0, INT_CLR_STATUS, 0x000003ff);
+
+	/* Clear VI1 interrupt
+	 * DW_4 = 0x0000_1fe8
+	 * DW_5 = 0x0000_03ff
+	 */
+	SAA716x_EPWR(VI1, INT_CLR_STATUS, 0x000003ff);
+
+	/* CLear FGPI0 interrupt
+	 * DW_6 = 0x0000_2fe8
+	 * DW_7 = 0x0000_007f
+	 */
+	SAA716x_EPWR(FGPI0, INT_CLR_STATUS, 0x0000007f);
+
+	/* Clear FGPI1 interrupt
+	 * DW_8 = 0x0000_3fe8
+	 * DW_9 = 0x0000_007f
+	 */
+	SAA716x_EPWR(FGPI1, INT_CLR_STATUS, 0x0000007f);
+
+	/* Clear FGPI2 interrupt
+	 * DW_10 = 0x0000_4fe8
+	 * DW_11 = 0x0000_007f
+	 */
+	SAA716x_EPWR(FGPI2, INT_CLR_STATUS, 0x0000007f);
+
+	/* Clear FGPI3 interrupt
+	 * DW_12 = 0x0000_5fe8
+	 * DW_13 = 0x0000_007f
+	 */
+	SAA716x_EPWR(FGPI3, INT_CLR_STATUS, 0x0000007f);
+
+	/* Clear AI0 interrupt
+	 * DW_14 = 0x0000_6020
+	 * DW_15 = 0x0000_000f
+	 */
+	SAA716x_EPWR(AI0, AI_INT_ACK, 0x0000000f);
+
+	/* Clear AI1 interrupt
+	 * DW_16 = 0x0000_7020
+	 * DW_17 = 0x0000_200f
+	 */
+	SAA716x_EPWR(AI1, AI_INT_ACK, 0x0000000f);
+
+	/* Set GREG boot_ready bit to 1
+	 * DW_18 = 0x0001_2018
+	 * DW_19 = 0x0000_2000
+	 */
+	SAA716x_EPWR(GREG, GREG_RSTU_CTRL, 0x00002000);
+#if 0
+	/* End of Boot script command
+	 * DW_20 = 0x0000_0006
+	 * Where to write this value ??
+	 * This seems very odd an address to trigger the
+	 * Boot Control State Machine !
+	 */
+	SAA716x_EPWR(VI0, 0x00000006, 0xffffffff);
+#endif
+	return 0;
+}
+
+/* Internal Bootscript configuration */
+static void saa716x_int_boot(struct saa716x_dev *saa716x)
+{
+	/* #1 Configure PCI COnfig space
+	 * GREG_JETSTR_CONFIG_0
+	 */
+	SAA716x_EPWR(GREG, GREG_SUBSYS_CONFIG, saa716x->pdev->subsystem_vendor);
+
+	/* GREG_JETSTR_CONFIG_1
+	 * pmcsr_scale:7 = 0x00
+	 * pmcsr_scale:6 = 0x00
+	 * pmcsr_scale:5 = 0x00
+	 * pmcsr_scale:4 = 0x00
+	 * pmcsr_scale:3 = 0x00
+	 * pmcsr_scale:2 = 0x00
+	 * pmcsr_scale:1 = 0x00
+	 * pmcsr_scale:0 = 0x00
+	 * BAR mask = 20 bit
+	 * BAR prefetch = no
+	 * MSI capable = 32 messages
+	 */
+	SAA716x_EPWR(GREG, GREG_MSI_BAR_PMCSR, 0x00001005);
+
+	/* GREG_JETSTR_CONFIG_2
+	 * pmcsr_data:3 = 0x0
+	 * pmcsr_data:2 = 0x0
+	 * pmcsr_data:1 = 0x0
+	 * pmcsr_data:0 = 0x0
+	 */
+	SAA716x_EPWR(GREG, GREG_PMCSR_DATA_1, 0x00000000);
+
+	/* GREG_JETSTR_CONFIG_3
+	 * pmcsr_data:7 = 0x0
+	 * pmcsr_data:6 = 0x0
+	 * pmcsr_data:5 = 0x0
+	 * pmcsr_data:4 = 0x0
+	 */
+	SAA716x_EPWR(GREG, GREG_PMCSR_DATA_2, 0x00000000);
+
+	/* #2 Release GREG resets
+	 * ip_rst_an
+	 * dpa1_rst_an
+	 * jetsream_reset_an
+	 */
+	SAA716x_EPWR(GREG, GREG_RSTU_CTRL, 0x00000e00);
+
+	/* #3 GPIO Setup
+	 * GPIO 25:24 = Output
+	 * GPIO Output "0" after Reset
+	 */
+	SAA716x_EPWR(GPIO, GPIO_OEN, 0xfcffffff);
+
+	/* #4 Custom stuff goes in here */
+
+	/* #5 Disable CGU Clocks
+	 * except for PHY, Jetstream, DPA1, DCS, Boot, GREG
+	 * CGU_PCR_0_3: pss_mmu_clk:0 = 0x0
+	 */
+	SAA716x_EPWR(CGU, CGU_PCR_0_3, 0x00000006);
+
+	/* CGU_PCR_0_4: pss_dtl2mtl_mmu_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_0_4, 0x00000006);
+
+	/* CGU_PCR_0_5: pss_msi_ck:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_0_5, 0x00000006);
+
+	/* CGU_PCR_0_7: pss_gpio_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_0_7, 0x00000006);
+
+	/* CGU_PCR_2_1: spi_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_2_1, 0x00000006);
+
+	/* CGU_PCR_3_2: i2c_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_3_2, 0x00000006);
+
+	/* CGU_PCR_4_1: phi_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_4_1, 0x00000006);
+
+	/* CGU_PCR_5: vip0_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_5, 0x00000006);
+
+	/* CGU_PCR_6: vip1_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_6, 0x00000006);
+
+	/* CGU_PCR_7: fgpi0_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_7, 0x00000006);
+
+	/* CGU_PCR_8: fgpi1_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_8, 0x00000006);
+
+	/* CGU_PCR_9: fgpi2_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_9, 0x00000006);
+
+	/* CGU_PCR_10: fgpi3_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_10, 0x00000006);
+
+	/* CGU_PCR_11: ai0_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_11, 0x00000006);
+
+	/* CGU_PCR_12: ai1_clk:0 = 0x0 */
+	SAA716x_EPWR(CGU, CGU_PCR_12, 0x00000006);
+
+	/* #6 Set GREG boot_ready = 0x1 */
+	SAA716x_EPWR(GREG, GREG_RSTU_CTRL, 0x00002000);
+
+	/* #7 Disable GREG CGU Clock */
+	SAA716x_EPWR(CGU, CGU_PCR_0_6, 0x00000006);
+
+	/* End of Bootscript command ?? */
+}
+
+int saa716x_core_boot(struct saa716x_dev *saa716x)
+{
+	struct saa716x_config *config = saa716x->config;
+
+	switch (config->boot_mode) {
+	case SAA716x_EXT_BOOT:
+		dprintk(SAA716x_DEBUG, 1, "Using External Boot from config");
+		saa716x_ext_boot(saa716x);
+		break;
+	case SAA716x_INT_BOOT:
+		dprintk(SAA716x_DEBUG, 1, "Using Internal Boot from config");
+		saa716x_int_boot(saa716x);
+		break;
+	default:
+		dprintk(SAA716x_ERROR, 1, "Unknown configuration %d", config->boot_mode);
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_core_boot);
+
+static void saa716x_bus_report(struct pci_dev *pdev, int enable)
+{
+	u32 reg;
+
+	pci_read_config_dword(pdev, 0x04, &reg);
+	if (enable)
+		reg |= 0x00000100; /* enable SERR */
+	else
+		reg &= 0xfffffeff; /* disable SERR */
+	pci_write_config_dword(pdev, 0x04, reg);
+
+	pci_read_config_dword(pdev, 0x58, &reg);
+	reg &= 0xfffffffd;
+	pci_write_config_dword(pdev, 0x58, reg);
+}
+
+int saa716x_jetpack_init(struct saa716x_dev *saa716x)
+{
+	/*
+	 * configure PHY through config space not to report
+	 * non-fatal error messages to avoid problems with
+	 * quirky BIOS'es
+	 */
+	saa716x_bus_report(saa716x->pdev, 0);
+
+	/*
+	 * create time out for blocks that have no clock
+	 * helps with lower bitrates on FGPI
+	 */
+	SAA716x_EPWR(DCS, DCSC_CTRL, ENABLE_TIMEOUT);
+
+	/* Reset all blocks */
+	SAA716x_EPWR(MSI, MSI_SW_RST, MSI_SW_RESET);
+	SAA716x_EPWR(MMU, MMU_SW_RST, MMU_SW_RESET);
+	SAA716x_EPWR(BAM, BAM_SW_RST, BAM_SW_RESET);
+
+	switch (saa716x->pdev->device) {
+	case SAA7162:
+		dprintk(SAA716x_DEBUG, 1, "SAA%02x Decoder disable", saa716x->pdev->device);
+		SAA716x_EPWR(GPIO, GPIO_OEN, 0xfcffffff);
+		SAA716x_EPWR(GPIO, GPIO_WR,  0x00000000); /* Disable decoders */
+		msleep(10);
+		SAA716x_EPWR(GPIO, GPIO_WR,  0x03000000); /* Enable decoders */
+		break;
+	case SAA7161:
+		dprintk(SAA716x_DEBUG, 1, "SAA%02x Decoder disable", saa716x->pdev->device);
+		SAA716x_EPWR(GPIO, GPIO_OEN, 0xfeffffff);
+		SAA716x_EPWR(GPIO, GPIO_WR,  0x00000000); /* Disable decoders */
+		msleep(10);
+		SAA716x_EPWR(GPIO, GPIO_WR,  0x01000000); /* Enable decoder */
+		break;
+	case SAA7160:
+		saa716x->i2c_rate = SAA716x_I2C_RATE_100;
+		break;
+	default:
+		dprintk(SAA716x_ERROR, 1, "Unknown device (0x%02x)", saa716x->pdev->device);
+		return -ENODEV;
+	}
+
+	/* General setup for MMU */
+	SAA716x_EPWR(MMU, MMU_MODE, 0x14);
+	dprintk(SAA716x_DEBUG, 1, "SAA%02x Jetpack Successfully initialized", saa716x->pdev->device);
+
+	return 0;
+}
+EXPORT_SYMBOL(saa716x_jetpack_init);
+
+void saa716x_core_reset(struct saa716x_dev *saa716x)
+{
+	dprintk(SAA716x_DEBUG, 1, "RESET Modules");
+
+	/* VIP */
+	SAA716x_EPWR(VI0, VI_MODE, SOFT_RESET);
+	SAA716x_EPWR(VI1, VI_MODE, SOFT_RESET);
+
+	/* FGPI */
+	SAA716x_EPWR(FGPI0, FGPI_SOFT_RESET, FGPI_SOFTWARE_RESET);
+	SAA716x_EPWR(FGPI1, FGPI_SOFT_RESET, FGPI_SOFTWARE_RESET);
+	SAA716x_EPWR(FGPI2, FGPI_SOFT_RESET, FGPI_SOFTWARE_RESET);
+	SAA716x_EPWR(FGPI3, FGPI_SOFT_RESET, FGPI_SOFTWARE_RESET);
+
+	/* AIP */
+	SAA716x_EPWR(AI0, AI_CTL, AI_RESET);
+	SAA716x_EPWR(AI1, AI_CTL, AI_RESET);
+
+	/* BAM */
+	SAA716x_EPWR(BAM, BAM_SW_RST, BAM_SW_RESET);
+
+	/* MMU */
+	SAA716x_EPWR(MMU, MMU_SW_RST, MMU_SW_RESET);
+
+	/* MSI */
+	SAA716x_EPWR(MSI, MSI_SW_RST, MSI_SW_RESET);
+}
+EXPORT_SYMBOL_GPL(saa716x_core_reset);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_boot.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_boot.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_boot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_boot.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,18 @@
+#ifndef __SAA716x_BOOT_H
+#define __SAA716x_BOOT_H
+
+#define DISABLE_TIMEOUT		0x17
+#define ENABLE_TIMEOUT		0x16
+
+enum saa716x_boot_mode {
+	SAA716x_EXT_BOOT = 1,
+	SAA716x_INT_BOOT, /* GPIO[31:30] = 0x01 */
+};
+
+struct saa716x_dev;
+
+extern int saa716x_core_boot(struct saa716x_dev *saa716x);
+extern int saa716x_jetpack_init(struct saa716x_dev *saa716x);
+extern void saa716x_core_reset(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_BOOT_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_budget.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_budget.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_budget.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_budget.c	2012-06-18 23:11:33.824033419 +0200
@@ -0,0 +1,664 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <linux/i2c.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_gpio_reg.h"
+#include "saa716x_greg_reg.h"
+#include "saa716x_msi_reg.h"
+
+#include "saa716x_adap.h"
+#include "saa716x_i2c.h"
+#include "saa716x_msi.h"
+#include "saa716x_budget.h"
+#include "saa716x_gpio.h"
+#include "saa716x_rom.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+#include "../frontends/mb86a16.h"
+#include "../frontends/stv6110x.h"
+#include "../frontends/stv090x.h"
+
+unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
+
+unsigned int int_type;
+module_param(int_type, int, 0644);
+MODULE_PARM_DESC(int_type, "force Interrupt Handler type: 0=INT-A, 1=MSI, 2=MSI-X. default INT-A mode");
+
+#define DRIVER_NAME	"SAA716x Budget"
+
+static int __devinit saa716x_budget_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct saa716x_dev *saa716x;
+	int err = 0;
+
+	saa716x = kzalloc(sizeof (struct saa716x_dev), GFP_KERNEL);
+	if (saa716x == NULL) {
+		printk(KERN_ERR "saa716x_budget_pci_probe ERROR: out of memory\n");
+		err = -ENOMEM;
+		goto fail0;
+	}
+
+	saa716x->verbose	= verbose;
+	saa716x->int_type	= int_type;
+	saa716x->pdev		= pdev;
+	saa716x->config		= (struct saa716x_config *) pci_id->driver_data;
+
+	err = saa716x_pci_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x PCI Initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_cgu_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x CGU Init failed");
+		goto fail1;
+	}
+
+	err = saa716x_core_boot(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Core Boot failed");
+		goto fail2;
+	}
+	dprintk(SAA716x_DEBUG, 1, "SAA716x Core Boot Success");
+
+	err = saa716x_msi_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x MSI Init failed");
+		goto fail2;
+	}
+
+	err = saa716x_jetpack_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Jetpack core initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_i2c_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x I2C Initialization failed");
+		goto fail3;
+	}
+
+	saa716x_gpio_init(saa716x);
+
+	err = saa716x_dump_eeprom(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM dump failed");
+	}
+
+	err = saa716x_eeprom_data(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM read failed");
+	}
+
+	/* set default port mapping */
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x04080FA9);
+	/* enable FGPI3 and FGPI1 for TS input from Port 2 and 6 */
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x321);
+
+	err = saa716x_dvb_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x DVB initialization failed");
+		goto fail4;
+	}
+
+	return 0;
+
+fail4:
+	saa716x_dvb_exit(saa716x);
+fail3:
+	saa716x_i2c_exit(saa716x);
+fail2:
+	saa716x_pci_exit(saa716x);
+fail1:
+	kfree(saa716x);
+fail0:
+	return err;
+}
+
+static void __devexit saa716x_budget_pci_remove(struct pci_dev *pdev)
+{
+	struct saa716x_dev *saa716x = pci_get_drvdata(pdev);
+
+	saa716x_dvb_exit(saa716x);
+	saa716x_i2c_exit(saa716x);
+	saa716x_pci_exit(saa716x);
+	kfree(saa716x);
+}
+
+static irqreturn_t saa716x_budget_pci_irq(int irq, void *dev_id)
+{
+	struct saa716x_dev *saa716x	= (struct saa716x_dev *) dev_id;
+
+	u32 stat_h, stat_l, mask_h, mask_l;
+
+	if (unlikely(saa716x == NULL)) {
+		printk("%s: saa716x=NULL", __func__);
+		return IRQ_NONE;
+	}
+
+	stat_l = SAA716x_EPRD(MSI, MSI_INT_STATUS_L);
+	stat_h = SAA716x_EPRD(MSI, MSI_INT_STATUS_H);
+	mask_l = SAA716x_EPRD(MSI, MSI_INT_ENA_L);
+	mask_h = SAA716x_EPRD(MSI, MSI_INT_ENA_H);
+
+	dprintk(SAA716x_DEBUG, 1, "MSI STAT L=<%02x> H=<%02x>, CTL L=<%02x> H=<%02x>",
+		stat_l, stat_h, mask_l, mask_h);
+
+	if (!((stat_l & mask_l) || (stat_h & mask_h)))
+		return IRQ_NONE;
+
+	if (stat_l)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, stat_l);
+
+	if (stat_h)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_H, stat_h);
+
+	saa716x_msi_event(saa716x, stat_l, stat_h);
+#if 0
+	dprintk(SAA716x_DEBUG, 1, "VI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(VI0, INT_STATUS),
+		SAA716x_EPRD(VI1, INT_STATUS),
+		SAA716x_EPRD(VI0, INT_ENABLE),
+		SAA716x_EPRD(VI1, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(FGPI0, INT_STATUS),
+		SAA716x_EPRD(FGPI1, INT_STATUS),
+		SAA716x_EPRD(FGPI0, INT_ENABLE),
+		SAA716x_EPRD(FGPI0, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 2=<%02x> 3=<%02x>, CTL 2=<%02x> 3=<%02x>",
+		SAA716x_EPRD(FGPI2, INT_STATUS),
+		SAA716x_EPRD(FGPI3, INT_STATUS),
+		SAA716x_EPRD(FGPI2, INT_ENABLE),
+		SAA716x_EPRD(FGPI3, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "AI STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(AI0, AI_STATUS),
+		SAA716x_EPRD(AI1, AI_STATUS),
+		SAA716x_EPRD(AI0, AI_CTL),
+		SAA716x_EPRD(AI1, AI_CTL));
+
+	dprintk(SAA716x_DEBUG, 1, "I2C STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(I2C_A, INT_STATUS),
+		SAA716x_EPRD(I2C_B, INT_STATUS),
+		SAA716x_EPRD(I2C_A, INT_ENABLE),
+		SAA716x_EPRD(I2C_B, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "DCS STAT=<%02x>, CTL=<%02x>",
+		SAA716x_EPRD(DCS, DCSC_INT_STATUS),
+		SAA716x_EPRD(DCS, DCSC_INT_ENABLE));
+#endif
+
+	if (stat_l) {
+		if (stat_l & MSI_INT_TAGACK_FGPI_0) {
+			tasklet_schedule(&saa716x->fgpi[0].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_1) {
+			tasklet_schedule(&saa716x->fgpi[1].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_2) {
+			tasklet_schedule(&saa716x->fgpi[2].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_3) {
+			tasklet_schedule(&saa716x->fgpi[3].tasklet);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void demux_worker(unsigned long data)
+{
+	struct saa716x_fgpi_stream_port *fgpi_entry = (struct saa716x_fgpi_stream_port *)data;
+	struct saa716x_dev *saa716x = fgpi_entry->saa716x;
+	struct dvb_demux *demux;
+	u32 fgpi_index;
+	u32 i;
+	u32 write_index;
+
+	fgpi_index = fgpi_entry->dma_channel - 6;
+	demux = NULL;
+	for (i = 0; i < saa716x->config->adapters; i++) {
+		if (saa716x->config->adap_config[i].ts_port == fgpi_index) {
+			demux = &saa716x->saa716x_adap[i].demux;
+			break;
+		}
+	}
+	if (demux == NULL) {
+		printk(KERN_ERR "%s: unexpected channel %u\n",
+		       __func__, fgpi_entry->dma_channel);
+		return;
+	}
+
+	write_index = saa716x_fgpi_get_write_index(saa716x, fgpi_index);
+	if (write_index < 0)
+		return;
+
+	dprintk(SAA716x_DEBUG, 1, "dma buffer = %d", write_index);
+
+	if (write_index == fgpi_entry->read_index) {
+		printk(KERN_DEBUG "%s: called but nothing to do\n", __func__);
+		return;
+	}
+
+	do {
+		u8 *data = (u8 *)fgpi_entry->dma_buf[fgpi_entry->read_index].mem_virt;
+
+		pci_dma_sync_sg_for_cpu(saa716x->pdev,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].sg_list,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].list_len,
+			PCI_DMA_FROMDEVICE);
+
+		dvb_dmx_swfilter(demux, data, 348 * 188);
+
+		fgpi_entry->read_index = (fgpi_entry->read_index + 1) & 7;
+	} while (write_index != fgpi_entry->read_index);
+}
+
+
+#define SAA716x_MODEL_TWINHAN_VP3071	"Twinhan/Azurewave VP-3071"
+#define SAA716x_DEV_TWINHAN_VP3071	"2x DVB-T"
+
+static int saa716x_vp3071_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_vp3071_config = {
+	.model_name		= SAA716x_MODEL_TWINHAN_VP3071,
+	.dev_type		= SAA716x_DEV_TWINHAN_VP3071,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 2,
+	.frontend_attach	= saa716x_vp3071_frontend_attach,
+	.irq_handler		= saa716x_budget_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+
+#define SAA716x_MODEL_TWINHAN_VP1028	"Twinhan/Azurewave VP-1028"
+#define SAA716x_DEV_TWINHAN_VP1028	"DVB-S"
+
+static int vp1028_dvbs_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct saa716x_dev *saa716x = fe->dvb->priv;
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		dprintk(SAA716x_ERROR, 1, "Polarization=[13V]");
+		break;
+	case SEC_VOLTAGE_18:
+		dprintk(SAA716x_ERROR, 1, "Polarization=[18V]");
+		break;
+	case SEC_VOLTAGE_OFF:
+		dprintk(SAA716x_ERROR, 1, "Frontend (dummy) POWERDOWN");
+		break;
+	default:
+		dprintk(SAA716x_ERROR, 1, "Invalid = (%d)", (u32 ) voltage);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct mb86a16_config vp1028_mb86a16_config = {
+	.demod_address	= 0x08,
+	.set_voltage	= vp1028_dvbs_set_voltage,
+};
+
+static int saa716x_vp1028_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	struct saa716x_i2c *i2c = &saa716x->i2c[1];
+
+	if (count == 0) {
+
+		mutex_lock(&saa716x->adap_lock);
+
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Power ON", count);
+		saa716x_gpio_set_output(saa716x, 10);
+		msleep(1);
+
+		/* VP-1028 has inverted power supply control */
+		saa716x_gpio_write(saa716x, 10, 1); /* set to standby */
+		saa716x_gpio_write(saa716x, 10, 0); /* switch it on */
+		msleep(100);
+
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Reset", count);
+		saa716x_gpio_set_output(saa716x, 12);
+		msleep(1);
+
+		/* reset demodulator (Active LOW) */
+		saa716x_gpio_write(saa716x, 12, 1);
+		msleep(100);
+		saa716x_gpio_write(saa716x, 12, 0);
+		msleep(100);
+		saa716x_gpio_write(saa716x, 12, 1);
+		msleep(100);
+
+		mutex_unlock(&saa716x->adap_lock);
+
+		dprintk(SAA716x_ERROR, 1, "Probing for MB86A16 (DVB-S/DSS)");
+		adapter->fe = mb86a16_attach(&vp1028_mb86a16_config, &i2c->i2c_adapter);
+		if (adapter->fe) {
+			dprintk(SAA716x_ERROR, 1, "found MB86A16 DVB-S/DSS frontend @0x%02x",
+				vp1028_mb86a16_config.demod_address);
+
+		} else {
+			goto exit;
+		}
+		dprintk(SAA716x_ERROR, 1, "Done!");
+	}
+
+	return 0;
+exit:
+	dprintk(SAA716x_ERROR, 1, "Frontend attach failed");
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_vp1028_config = {
+	.model_name		= SAA716x_MODEL_TWINHAN_VP1028,
+	.dev_type		= SAA716x_DEV_TWINHAN_VP1028,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_vp1028_frontend_attach,
+	.irq_handler		= saa716x_budget_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+
+#define SAA716x_MODEL_TWINHAN_VP6002	"Twinhan/Azurewave VP-6002"
+#define SAA716x_DEV_TWINHAN_VP6002	"DVB-S"
+
+static int saa716x_vp6002_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_vp6002_config = {
+	.model_name		= SAA716x_MODEL_TWINHAN_VP6002,
+	.dev_type		= SAA716x_DEV_TWINHAN_VP6002,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_vp6002_frontend_attach,
+	.irq_handler		= saa716x_budget_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+
+#define SAA716x_MODEL_KNC1_DUALS2	"KNC One Dual S2"
+#define SAA716x_DEV_KNC1_DUALS2		"1xDVB-S + 1xDVB-S/S2"
+
+static int saa716x_knc1_duals2_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_knc1_duals2_config = {
+	.model_name		= SAA716x_MODEL_KNC1_DUALS2,
+	.dev_type		= SAA716x_DEV_KNC1_DUALS2,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 2,
+	.frontend_attach	= saa716x_knc1_duals2_frontend_attach,
+	.irq_handler		= saa716x_budget_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+
+#define SAA716x_MODEL_SKYSTAR2_EXPRESS_HD	"SkyStar 2 eXpress HD"
+#define SAA716x_DEV_SKYSTAR2_EXPRESS_HD		"DVB-S/S2"
+
+static struct stv090x_config skystar2_stv090x_config = {
+	.device			= STV0903,
+	.demod_mode		= STV090x_SINGLE,
+	.clk_mode		= STV090x_CLK_EXT,
+
+	.xtal			= 8000000,
+	.address		= 0x68,
+
+	.ts1_mode		= STV090x_TSMODE_DVBCI,
+	.ts2_mode		= STV090x_TSMODE_SERIAL_CONTINUOUS,
+
+	.repeater_level		= STV090x_RPTLEVEL_16,
+
+	.tuner_init		= NULL,
+	.tuner_sleep		= NULL,
+	.tuner_set_mode		= NULL,
+	.tuner_set_frequency	= NULL,
+	.tuner_get_frequency	= NULL,
+	.tuner_set_bandwidth	= NULL,
+	.tuner_get_bandwidth	= NULL,
+	.tuner_set_bbgain	= NULL,
+	.tuner_get_bbgain	= NULL,
+	.tuner_set_refclk	= NULL,
+	.tuner_get_status	= NULL,
+};
+
+static int skystar2_set_voltage(struct dvb_frontend *fe,
+				enum fe_sec_voltage voltage)
+{
+	int err;
+	u8 en = 0;
+	u8 sel = 0;
+
+	switch (voltage) {
+	case SEC_VOLTAGE_OFF:
+		en = 0;
+		break;
+
+	case SEC_VOLTAGE_13:
+		en = 1;
+		sel = 0;
+		break;
+
+	case SEC_VOLTAGE_18:
+		en = 1;
+		sel = 1;
+		break;
+
+	default:
+		break;
+	}
+
+	err = stv090x_set_gpio(fe, 2, 0, en, 0);
+	if (err < 0)
+		goto exit;
+	err = stv090x_set_gpio(fe, 3, 0, sel, 0);
+	if (err < 0)
+		goto exit;
+
+	return 0;
+exit:
+	return err;
+}
+
+static int skystar2_voltage_boost(struct dvb_frontend *fe, long arg)
+{
+	int err;
+	u8 value;
+
+	if (arg)
+		value = 1;
+	else
+		value = 0;
+
+	err = stv090x_set_gpio(fe, 4, 0, value, 0);
+	if (err < 0)
+		goto exit;
+
+	return 0;
+exit:
+	return err;
+}
+
+static struct stv6110x_config skystar2_stv6110x_config = {
+	.addr			= 0x60,
+	.refclk			= 16000000,
+	.clk_div		= 2,
+};
+
+static int skystar2_express_hd_frontend_attach(struct saa716x_adapter *adapter,
+					       int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	struct saa716x_i2c *i2c = &saa716x->i2c[SAA716x_I2C_BUS_B];
+	struct stv6110x_devctl *ctl;
+
+	if (count < saa716x->config->adapters) {
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init",
+			count);
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count,
+			saa716x->pdev->subsystem_device);
+
+		saa716x_gpio_set_output(saa716x, 26);
+
+		/* Reset the demodulator */
+		saa716x_gpio_write(saa716x, 26, 1);
+		msleep(10);
+		saa716x_gpio_write(saa716x, 26, 0);
+		msleep(10);
+		saa716x_gpio_write(saa716x, 26, 1);
+		msleep(10);
+
+		adapter->fe = dvb_attach(stv090x_attach,
+					 &skystar2_stv090x_config,
+					 &i2c->i2c_adapter,
+					 STV090x_DEMODULATOR_0);
+
+		if (adapter->fe) {
+			dprintk(SAA716x_NOTICE, 1, "found STV0903 @0x%02x",
+				skystar2_stv090x_config.address);
+		} else {
+			goto exit;
+		}
+
+		adapter->fe->ops.set_voltage = skystar2_set_voltage;
+		adapter->fe->ops.enable_high_lnb_voltage = skystar2_voltage_boost;
+
+		ctl = dvb_attach(stv6110x_attach,
+				 adapter->fe,
+				 &skystar2_stv6110x_config,
+				 &i2c->i2c_adapter);
+
+		if (ctl) {
+			dprintk(SAA716x_NOTICE, 1, "found STV6110(A) @0x%02x",
+				skystar2_stv6110x_config.addr);
+
+			skystar2_stv090x_config.tuner_init	    = ctl->tuner_init;
+			skystar2_stv090x_config.tuner_sleep	    = ctl->tuner_sleep;
+			skystar2_stv090x_config.tuner_set_mode	    = ctl->tuner_set_mode;
+			skystar2_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;
+			skystar2_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;
+			skystar2_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;
+			skystar2_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;
+			skystar2_stv090x_config.tuner_set_bbgain    = ctl->tuner_set_bbgain;
+			skystar2_stv090x_config.tuner_get_bbgain    = ctl->tuner_get_bbgain;
+			skystar2_stv090x_config.tuner_set_refclk    = ctl->tuner_set_refclk;
+			skystar2_stv090x_config.tuner_get_status    = ctl->tuner_get_status;
+
+			/* call the init function once to initialize
+			   tuner's clock output divider and demod's
+			   master clock */
+			if (adapter->fe->ops.init)
+				adapter->fe->ops.init(adapter->fe);
+		} else {
+			goto exit;
+		}
+
+		dprintk(SAA716x_ERROR, 1, "Done!");
+		return 0;
+	}
+exit:
+	dprintk(SAA716x_ERROR, 1, "Frontend attach failed");
+	return -ENODEV;
+}
+
+static struct saa716x_config skystar2_express_hd_config = {
+	.model_name		= SAA716x_MODEL_SKYSTAR2_EXPRESS_HD,
+	.dev_type		= SAA716x_DEV_SKYSTAR2_EXPRESS_HD,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= skystar2_express_hd_frontend_attach,
+	.irq_handler		= saa716x_budget_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+	.adap_config		= {
+		{
+			/* Adapter 0 */
+			.ts_port = 1, /* using FGPI 1 */
+			.worker = demux_worker
+		}
+	}
+};
+
+
+static struct pci_device_id saa716x_budget_pci_table[] = {
+
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, TWINHAN_VP_1028, SAA7160, &saa716x_vp1028_config), /* VP-1028 */
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, TWINHAN_VP_3071, SAA7160, &saa716x_vp3071_config), /* VP-3071 */
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, TWINHAN_VP_6002, SAA7160, &saa716x_vp6002_config), /* VP-6002 */
+	MAKE_ENTRY(KNC_One, KNC_Dual_S2, SAA7160, &saa716x_knc1_duals2_config),
+	MAKE_ENTRY(TECHNISAT, SKYSTAR2_EXPRESS_HD, SAA7160, &skystar2_express_hd_config),
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, saa716x_budget_pci_table);
+
+static struct pci_driver saa716x_budget_pci_driver = {
+	.name			= DRIVER_NAME,
+	.id_table		= saa716x_budget_pci_table,
+	.probe			= saa716x_budget_pci_probe,
+	.remove			= saa716x_budget_pci_remove,
+};
+
+static int __devinit saa716x_budget_init(void)
+{
+	return pci_register_driver(&saa716x_budget_pci_driver);
+}
+
+static void __devexit saa716x_budget_exit(void)
+{
+	return pci_unregister_driver(&saa716x_budget_pci_driver);
+}
+
+module_init(saa716x_budget_init);
+module_exit(saa716x_budget_exit);
+
+MODULE_DESCRIPTION("SAA716x Budget driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_budget.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_budget.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_budget.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_budget.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,15 @@
+#ifndef __SAA716x_BUDGET_H
+#define __SAA716x_BUDGET_H
+
+#define TWINHAN_TECHNOLOGIES	0x1822
+#define TWINHAN_VP_3071		0x0039
+#define TWINHAN_VP_1028		0x0044
+#define TWINHAN_VP_6002		0x0047
+
+#define KNC_One			0x1894
+#define KNC_Dual_S2		0x0110
+
+#define TECHNISAT		0x1AE4
+#define SKYSTAR2_EXPRESS_HD	0x0700
+
+#endif /* __SAA716x_BUDGET_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,539 @@
+#include <linux/delay.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_cgu_reg.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+u32 cgu_clk[14] = {
+	CGU_FDC_0,
+	CGU_FDC_1,
+	CGU_FDC_2,
+	CGU_FDC_3,
+	CGU_FDC_4,
+	CGU_FDC_5,
+	CGU_FDC_6,
+	CGU_FDC_7,
+	CGU_FDC_8,
+	CGU_FDC_9,
+	CGU_FDC_10,
+	CGU_FDC_11,
+	CGU_FDC_12,
+	CGU_FDC_13
+};
+
+char *clk_desc[14] = {
+	"Clk PSS",
+	"Clk DCS",
+	"Clk SPI",
+	"Clk I2C/Boot",
+	"Clk PHI",
+	"Clk VI0",
+	"Clk VI1",
+	"Clk FGPI0",
+	"Clk FGPI1",
+	"Clk FGPI2",
+	"Clk FGPI3",
+	"Clk AI0",
+	"Clk AI1",
+	"Clk Phy"
+};
+
+int saa716x_getbootscript_setup(struct saa716x_dev *saa716x)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	u8 i;
+	s8 N = 0;
+	s16 M = 0;
+
+	SAA716x_EPWR(CGU, CGU_PCR_0_6, CGU_PCR_RUN); /* GREG */
+	SAA716x_EPWR(CGU, CGU_PCR_0_3, CGU_PCR_RUN); /* PSS_MMU */
+	SAA716x_EPWR(CGU, CGU_PCR_0_4, CGU_PCR_RUN); /* PSS_DTL2MTL */
+	SAA716x_EPWR(CGU, CGU_PCR_0_5, CGU_PCR_RUN); /* MSI */
+	SAA716x_EPWR(CGU, CGU_PCR_3_2, CGU_PCR_RUN); /* I2C */
+	SAA716x_EPWR(CGU, CGU_PCR_4_1, CGU_PCR_RUN); /* PHI */
+	SAA716x_EPWR(CGU, CGU_PCR_0_7, CGU_PCR_RUN); /* GPIO */
+	SAA716x_EPWR(CGU, CGU_PCR_2_1, CGU_PCR_RUN); /* SPI */
+	SAA716x_EPWR(CGU, CGU_PCR_1_1, CGU_PCR_RUN); /* DCS */
+	SAA716x_EPWR(CGU, CGU_PCR_3_1, CGU_PCR_RUN); /* BOOT */
+
+	/* get all dividers */
+	for (i = 0; i < CGU_CLKS; i++) {
+		cgu->clk_boot_div[i] = SAA716x_EPRD(CGU, cgu_clk[i]);
+		cgu->clk_curr_div[i] = cgu->clk_boot_div[i];
+
+		N = (cgu->clk_boot_div[i] >> 11) & 0xff;
+		N *= -1;
+		M = ((cgu->clk_boot_div[i] >>  3) & 0xff) + N;
+
+		if (M)
+			cgu->clk_freq[i] = (u32 ) N * PLL_FREQ / (u32 ) M;
+		else
+			cgu->clk_freq[i] = 0;
+
+		dprintk(SAA716x_DEBUG, 1, "Domain %d: %s <0x%02x> Divider: 0x%x --> N=%d, M=%d, freq=%d",
+			i, clk_desc[i], cgu_clk[i], cgu->clk_boot_div[i], N, M, cgu->clk_freq[i]);
+	}
+	/* store clock settings */
+	cgu->clk_vi_0[0] = cgu->clk_freq[CLK_DOMAIN_VI0];
+	cgu->clk_vi_0[1] = cgu->clk_freq[CLK_DOMAIN_VI0];
+	cgu->clk_vi_0[2] = cgu->clk_freq[CLK_DOMAIN_VI0];
+	cgu->clk_vi_1[0] = cgu->clk_freq[CLK_DOMAIN_VI1];
+	cgu->clk_vi_1[1] = cgu->clk_freq[CLK_DOMAIN_VI1];
+	cgu->clk_vi_1[2] = cgu->clk_freq[CLK_DOMAIN_VI1];
+
+	return 0;
+}
+
+int saa716x_set_clk_internal(struct saa716x_dev *saa716x, u32 port)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	u8 delay = 1;
+
+	switch (port) {
+	case PORT_VI0_VIDEO:
+		cgu->clk_int_port[PORT_VI0_VIDEO] = 1;
+
+		if (!cgu->clk_int_port[PORT_VI0_VBI]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_CGU_CLKRUN(5);
+		break;
+
+	case PORT_VI0_VBI:
+		cgu->clk_int_port[PORT_VI0_VBI] = 1;
+
+		if (!cgu->clk_int_port[PORT_VI0_VIDEO]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_CGU_CLKRUN(5);
+		break;
+
+	case PORT_VI1_VIDEO:
+		cgu->clk_int_port[PORT_VI1_VIDEO] = 1;
+
+		if (!cgu->clk_int_port[PORT_VI1_VBI]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_CGU_CLKRUN(6);
+		break;
+
+	case PORT_VI1_VBI:
+		cgu->clk_int_port[PORT_VI1_VBI] = 1;
+
+		if (!cgu->clk_int_port[PORT_VI1_VIDEO]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_CGU_CLKRUN(6);
+		break;
+
+	case PORT_FGPI0:
+		cgu->clk_int_port[PORT_FGPI0] = 1;
+		SAA716x_CGU_CLKRUN(7);
+		break;
+
+	case PORT_FGPI1:
+		cgu->clk_int_port[PORT_FGPI1] = 1;
+		SAA716x_CGU_CLKRUN(8);
+		break;
+
+	case PORT_FGPI2:
+		cgu->clk_int_port[PORT_FGPI2] = 1;
+		SAA716x_CGU_CLKRUN(9);
+		break;
+
+	case PORT_FGPI3:
+		cgu->clk_int_port[PORT_FGPI3] = 1;
+		SAA716x_CGU_CLKRUN(10);
+		break;
+
+	case PORT_AI0:
+		cgu->clk_int_port[PORT_AI0] = 1;
+		SAA716x_CGU_CLKRUN(11);
+		break;
+
+	case PORT_AI1:
+		cgu->clk_int_port[PORT_AI1] = 1;
+		SAA716x_CGU_CLKRUN(12);
+		break;
+
+	case PORT_ALL:
+		SAA716x_CGU_CLKRUN(5);
+		SAA716x_CGU_CLKRUN(6);
+		SAA716x_CGU_CLKRUN(7);
+		SAA716x_CGU_CLKRUN(8);
+		SAA716x_CGU_CLKRUN(9);
+		SAA716x_CGU_CLKRUN(10);
+		SAA716x_CGU_CLKRUN(11);
+		SAA716x_CGU_CLKRUN(12);
+
+		cgu->clk_int_port[PORT_VI0_VIDEO] = 1;
+		cgu->clk_int_port[PORT_VI0_VBI] = 1;
+		cgu->clk_int_port[PORT_VI1_VIDEO] = 1;
+		cgu->clk_int_port[PORT_VI1_VBI] = 1;
+		cgu->clk_int_port[PORT_FGPI0] = 1;
+		cgu->clk_int_port[PORT_FGPI1] = 1;
+		cgu->clk_int_port[PORT_FGPI2] = 1;
+		cgu->clk_int_port[PORT_FGPI3] = 1;
+		cgu->clk_int_port[PORT_AI0] = 1;
+		cgu->clk_int_port[PORT_AI1] = 1;
+		break;
+
+	default:
+		dprintk(SAA716x_ERROR, 1, "Unknown port <%02x>", port);
+		delay = 0;
+		break;
+	}
+
+	/* wait for PLL */
+	if (delay)
+		msleep(1);
+
+	return 0;
+}
+
+int saa716x_set_clk_external(struct saa716x_dev *saa716x, u32 port)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	u8 delay = 1;
+
+	switch (port) {
+	case PORT_VI0_VIDEO:
+		cgu->clk_int_port[PORT_VI0_VIDEO] = 0;
+
+		if (!cgu->clk_int_port[PORT_VI0_VBI]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_EPWR(CGU, CGU_FS1_5, 0x2); /* VI 0 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_5, 0x0); /* disable divider */
+		break;
+
+	case PORT_VI0_VBI:
+		cgu->clk_int_port[PORT_VI0_VBI] = 0;
+
+		if (!cgu->clk_int_port[PORT_VI0_VIDEO]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_EPWR(CGU, CGU_FS1_5, 0x2); /* VI 0 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_5, 0x0); /* disable divider */
+		break;
+
+	case PORT_VI1_VIDEO:
+		cgu->clk_int_port[PORT_VI1_VIDEO] = 0;
+
+		if (!cgu->clk_int_port[PORT_VI1_VBI]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_EPWR(CGU, CGU_FS1_6, 0x3); /* VI 1 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_6, 0x0); /* disable divider */
+		break;
+
+	case PORT_VI1_VBI:
+		cgu->clk_int_port[PORT_VI1_VBI] = 0;
+
+		if (!cgu->clk_int_port[PORT_VI1_VIDEO]) {
+			delay = 0;
+			break;
+		}
+
+		SAA716x_EPWR(CGU, CGU_FS1_6, 0x3); /* VI 1 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_6, 0x0); /* disable divider */
+		break;
+
+	case PORT_FGPI0:
+		cgu->clk_int_port[PORT_FGPI0] = 0;
+
+		SAA716x_EPWR(CGU, CGU_FS1_7, 0x4); /* FGPI 0 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_7, 0x0); /* disable divider */
+		break;
+
+	case PORT_FGPI1:
+		cgu->clk_int_port[PORT_FGPI1] = 0;
+
+		SAA716x_EPWR(CGU, CGU_FS1_8, 0x5); /* FGPI 1 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_8, 0x0); /* disable divider */
+		break;
+
+	case PORT_FGPI2:
+		cgu->clk_int_port[PORT_FGPI2] = 0;
+
+		SAA716x_EPWR(CGU, CGU_FS1_9, 0x6); /* FGPI 2 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_9, 0x0); /* disable divider */
+		break;
+
+	case PORT_FGPI3:
+		cgu->clk_int_port[PORT_FGPI3] = 0;
+
+		SAA716x_EPWR(CGU, CGU_FS1_10, 0x7); /* FGPI 3 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_10, 0x0); /* disable divider */
+		break;
+
+	case PORT_AI0:
+		cgu->clk_int_port[PORT_AI0] = 1;
+
+		SAA716x_EPWR(CGU, CGU_FS1_11, 0x8); /* AI 0 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_11, 0x0); /* disable divider */
+		break;
+
+	case PORT_AI1:
+		cgu->clk_int_port[PORT_AI1] = 1;
+
+		SAA716x_EPWR(CGU, CGU_FS1_12, 0x9); /* AI 1 clk */
+		SAA716x_EPWR(CGU, CGU_ESR_12, 0x0); /* disable divider */
+		break;
+
+	default:
+		dprintk(SAA716x_ERROR, 1, "Unknown port <%02x>", port);
+		delay = 0;
+		break;
+
+	}
+
+	if (delay)
+		msleep(1);
+
+	return 0;
+}
+
+int saa716x_get_clk(struct saa716x_dev *saa716x,
+		    enum saa716x_clk_domain domain,
+		    u32 *frequency)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	switch (domain) {
+	case CLK_DOMAIN_PSS:
+	case CLK_DOMAIN_DCS:
+	case CLK_DOMAIN_SPI:
+	case CLK_DOMAIN_I2C:
+	case CLK_DOMAIN_PHI:
+	case CLK_DOMAIN_VI0:
+	case CLK_DOMAIN_VI1:
+	case CLK_DOMAIN_FGPI0:
+	case CLK_DOMAIN_FGPI1:
+	case CLK_DOMAIN_FGPI2:
+	case CLK_DOMAIN_FGPI3:
+	case CLK_DOMAIN_AI0:
+	case CLK_DOMAIN_AI1:
+	case CLK_DOMAIN_PHY:
+		*frequency = cgu->clk_freq[domain];
+		break;
+
+	case CLK_DOMAIN_VI0VBI:
+		*frequency = cgu->clk_freq[CLK_DOMAIN_VI0];
+		break;
+
+	case CLK_DOMAIN_VI1VBI:
+		*frequency =cgu->clk_freq[CLK_DOMAIN_VI1];
+		break;
+	default:
+		dprintk(SAA716x_ERROR, 1, "Error Clock domain <%02x>", domain);
+		break;
+	}
+
+	return 0;
+}
+
+int saa716x_set_clk(struct saa716x_dev *saa716x,
+		    enum saa716x_clk_domain domain,
+		    u32 frequency)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	u32 M = 1, N = 1, reset, i;
+	s8 N_tmp, M_tmp, sub, add, lsb;
+
+
+	if (cgu->clk_freq_min > frequency)
+		frequency = cgu->clk_freq_min;
+
+	if (cgu->clk_freq_max < frequency)
+		frequency = cgu->clk_freq_max;
+
+	switch (domain) {
+	case CLK_DOMAIN_PSS:
+	case CLK_DOMAIN_DCS:
+	case CLK_DOMAIN_SPI:
+	case CLK_DOMAIN_I2C:
+	case CLK_DOMAIN_PHI:
+	case CLK_DOMAIN_FGPI0:
+	case CLK_DOMAIN_FGPI1:
+	case CLK_DOMAIN_FGPI2:
+	case CLK_DOMAIN_FGPI3:
+	case CLK_DOMAIN_AI0:
+	case CLK_DOMAIN_AI1:
+	case CLK_DOMAIN_PHY:
+
+		if (frequency == cgu->clk_freq[domain])
+			return 0; /* same frequency */
+		break;
+
+	case CLK_DOMAIN_VI0:
+
+		if (frequency == cgu->clk_vi_0[1]) {
+			return 0;
+
+		} else if (frequency == cgu->clk_vi_0[0]) {
+			cgu->clk_vi_0[1] = frequency; /* store */
+
+			if (frequency == cgu->clk_vi_0[2])
+				return 0;
+
+		} else {
+			cgu->clk_vi_0[1] = frequency;
+
+			if (frequency != cgu->clk_vi_0[2])
+				return 0;
+
+		}
+		break;
+
+	case CLK_DOMAIN_VI1:
+		if (frequency == cgu->clk_vi_1[1]) {
+			return 0;
+
+		} else if (frequency == cgu->clk_vi_1[0]) {
+			cgu->clk_vi_1[1] = frequency; /* store */
+
+			if (frequency == cgu->clk_vi_1[2])
+				return 0;
+
+		} else {
+			cgu->clk_vi_1[1] = frequency;
+
+			if (frequency != cgu->clk_vi_1[2])
+				return 0;
+
+		}
+		break;
+
+	case CLK_DOMAIN_VI0VBI:
+		if (frequency == cgu->clk_vi_0[2]) {
+			return 0;
+
+		} else if (frequency == cgu->clk_vi_0[0]) {
+			cgu->clk_vi_0[2] = frequency; /* store */
+
+			if (frequency == cgu->clk_vi_0[1])
+				return 0;
+
+		} else {
+			cgu->clk_vi_0[2] = frequency; /* store */
+
+			if (frequency != cgu->clk_vi_0[1])
+				return 0;
+
+		}
+		domain = CLK_DOMAIN_VI0; /* change domain */
+		break;
+
+	case CLK_DOMAIN_VI1VBI:
+		if (frequency == cgu->clk_vi_1[2]) {
+			return 0;
+
+		} else if (frequency == cgu->clk_vi_1[0]) {
+			cgu->clk_vi_1[2] = frequency; /* store */
+
+			if (frequency == cgu->clk_vi_1[1])
+				return 0;
+
+		} else {
+			cgu->clk_vi_1[2] = frequency; /* store */
+
+			if (frequency != cgu->clk_vi_1[1])
+				return 0;
+
+		}
+		domain = CLK_DOMAIN_VI1; /* change domain */
+		break;
+	}
+
+	/* calculate divider */
+	do {
+		M = (N * PLL_FREQ) / frequency;
+		if (M == 0)
+			N++;
+
+	} while (M == 0);
+
+	/* calculate frequency */
+	cgu->clk_freq[domain] = (N * PLL_FREQ) / M;
+
+	N_tmp = N & 0xff;
+	M_tmp = M & 0xff;
+	sub = -N_tmp;
+	add = M_tmp - N_tmp;
+	lsb = 4; /* run */
+
+	if (((10 * N) / M) < 5)
+		lsb |= 1; /* stretch */
+
+	/* store new divider */
+	cgu->clk_curr_div[domain] = sub & 0xff;
+	cgu->clk_curr_div[domain] <<= 8;
+	cgu->clk_curr_div[domain] = add & 0xff;
+	cgu->clk_curr_div[domain] <<= 3;
+	cgu->clk_curr_div[domain]  |= lsb;
+
+	dprintk(SAA716x_DEBUG, 1, "Domain <0x%02x> Frequency <%d> Set Freq <%d> N=%d M=%d Divider <0x%02x>",
+		domain,
+		frequency,
+		cgu->clk_freq[domain],
+		N,
+		M,
+		cgu->clk_curr_div[domain]);
+
+	reset = 0;
+
+	/* Reset */
+	SAA716x_EPWR(CGU, cgu_clk[domain], cgu->clk_curr_div[domain] | 0x2);
+
+	/* Reset disable */
+	for (i = 0; i < 1000; i++) {
+		msleep(10);
+		reset = SAA716x_EPRD(CGU, cgu_clk[domain]);
+
+		if (cgu->clk_curr_div[domain == reset])
+			break;
+	}
+
+	if (cgu->clk_curr_div[domain] != reset)
+		SAA716x_EPWR(CGU, cgu_clk[domain], cgu->clk_curr_div[domain]);
+
+	return 0;
+}
+
+int saa716x_cgu_init(struct saa716x_dev *saa716x)
+{
+	struct saa716x_cgu *cgu = &saa716x->cgu;
+
+	cgu->clk_freq_min = PLL_FREQ / 255;
+	if (PLL_FREQ > (cgu->clk_freq_min * 255))
+		cgu->clk_freq_min++;
+
+	cgu->clk_freq_max = PLL_FREQ;
+
+	saa716x_getbootscript_setup(saa716x);
+	saa716x_set_clk_internal(saa716x, PORT_ALL);
+
+	return 0;
+}
+EXPORT_SYMBOL(saa716x_cgu_init);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,61 @@
+#ifndef __SAA716x_CGU_H
+#define __SAA716x_CGU_H
+
+#define PLL_FREQ	2500
+
+#define SAA716x_CGU_CLKRUN(__reg)  do {						\
+	SAA716x_EPWR(CGU, CGU_PCR_##__reg, CGU_PCR_RUN); /* Run */		\
+	SAA716x_EPWR(CGU, CGU_SCR_##__reg, CGU_SCR_ENF1); /* Switch */		\
+	SAA716x_EPWR(CGU, CGU_FS1_##__reg, 0x00000000); /* PLL Clk */		\
+	SAA716x_EPWR(CGU, CGU_ESR_##__reg, CGU_ESR_FD_EN); /* Frac div */	\
+} while (0)
+
+enum saa716x_clk_domain {
+	CLK_DOMAIN_PSS		= 0,
+	CLK_DOMAIN_DCS		= 1,
+	CLK_DOMAIN_SPI		= 2,
+	CLK_DOMAIN_I2C		= 3,
+	CLK_DOMAIN_PHI		= 4,
+	CLK_DOMAIN_VI0		= 5,
+	CLK_DOMAIN_VI1		= 6,
+	CLK_DOMAIN_FGPI0	= 7,
+	CLK_DOMAIN_FGPI1	= 8,
+	CLK_DOMAIN_FGPI2	= 9,
+	CLK_DOMAIN_FGPI3	= 10,
+	CLK_DOMAIN_AI0		= 11,
+	CLK_DOMAIN_AI1		= 12,
+	CLK_DOMAIN_PHY		= 13,
+	CLK_DOMAIN_VI0VBI	= 14,
+	CLK_DOMAIN_VI1VBI	= 15
+};
+
+#define PORT_VI0_VIDEO		0
+#define PORT_VI0_VBI		2
+#define	PORT_VI1_VIDEO		3
+#define PORT_VI1_VBI		5
+#define PORT_FGPI0		6
+#define	PORT_FGPI1		7
+#define PORT_FGPI2		8
+#define PORT_FGPI3		9
+#define PORT_AI0		10
+#define PORT_AI1		11
+#define PORT_ALL		12
+
+#define CGU_CLKS	14
+
+struct saa716x_cgu {
+	u8	clk_int_port[12];
+	u32	clk_vi_0[3];
+	u32	clk_vi_1[3];
+	u32	clk_boot_div[CGU_CLKS];
+	u32	clk_curr_div[CGU_CLKS];
+	u32	clk_freq[CGU_CLKS];
+	u32	clk_freq_min;
+	u32	clk_freq_max;
+};
+
+extern int saa716x_cgu_init(struct saa716x_dev *saa716x);
+extern int saa716x_set_clk_internal(struct saa716x_dev *saa716x, u32 port);
+extern int saa716x_set_clk_external(struct saa716x_dev *saa716x, u32 port);
+
+#endif /* __SAA716x_CGU_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_cgu_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_cgu_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,178 @@
+#ifndef __SAA716x_CGU_REG_H
+#define __SAA716x_CGU_REG_H
+
+/* -------------- CGU Registers -------------- */
+
+#define CGU_SCR_0			0x000
+#define CGU_SCR_1			0x004
+#define CGU_SCR_2			0x008
+#define CGU_SCR_3			0x00c
+#define CGU_SCR_4			0x010
+#define CGU_SCR_5			0x014
+#define CGU_SCR_6			0x018
+#define CGU_SCR_7			0x01c
+#define CGU_SCR_8			0x020
+#define CGU_SCR_9			0x024
+#define CGU_SCR_10			0x028
+#define CGU_SCR_11			0x02c
+#define CGU_SCR_12			0x030
+#define CGU_SCR_13			0x034
+#define CGU_SCR_STOP			(0x00000001 <<  3)
+#define CGU_SCR_RESET			(0x00000001 <<  2)
+#define CGU_SCR_ENF2			(0x00000001 <<  1)
+#define CGU_SCR_ENF1			(0x00000001 <<  0)
+
+#define CGU_FS1_0			0x038
+#define CGU_FS1_1			0x03c
+#define CGU_FS1_2			0x040
+#define CGU_FS1_3			0x044
+#define CGU_FS1_4			0x048
+#define CGU_FS1_5			0x04c
+#define CGU_FS1_6			0x050
+#define CGU_FS1_7			0x054
+#define CGU_FS1_8			0x058
+#define CGU_FS1_9			0x05c
+#define CGU_FS1_10			0x060
+#define CGU_FS1_11			0x064
+#define CGU_FS1_12			0x068
+#define CGU_FS1_13			0x06c
+#define CGU_FS1_PLL			(0x00000000 <<  0)
+
+
+#define CGU_FS2_0			0x070
+#define CGU_FS2_1			0x074
+#define CGU_FS2_2			0x078
+#define CGU_FS2_3			0x07c
+#define CGU_FS2_4			0x080
+#define CGU_FS2_5			0x084
+#define CGU_FS2_6			0x088
+#define CGU_FS2_7			0x08c
+#define CGU_FS2_8			0x090
+#define CGU_FS2_9			0x094
+#define CGU_FS2_10			0x098
+#define CGU_FS2_11			0x09c
+#define CGU_FS2_12			0x0a0
+#define CGU_FS2_13			0x0a4
+
+#define CGU_SSR_0			0x0a8
+#define CGU_SSR_1			0x0ac
+#define CGU_SSR_2			0x0b0
+#define CGU_SSR_3			0x0b4
+#define CGU_SSR_4			0x0b8
+#define CGU_SSR_5			0x0bc
+#define CGU_SSR_6			0x0c0
+#define CGU_SSR_7			0x0c4
+#define CGU_SSR_8			0x0c8
+#define CGU_SSR_9			0x0cc
+#define CGU_SSR_10			0x0d0
+#define CGU_SSR_11			0x0d4
+#define CGU_SSR_12			0x0d8
+#define CGU_SSR_13			0x0dc
+
+#define CGU_PCR_0_0			0x0e0
+#define CGU_PCR_0_1			0x0e4
+#define CGU_PCR_0_2			0x0e8
+#define CGU_PCR_0_3			0x0ec
+#define CGU_PCR_0_4			0x0f0
+#define CGU_PCR_0_5			0x0f4
+#define CGU_PCR_0_6			0x0f8
+#define CGU_PCR_0_7			0x0fc
+#define CGU_PCR_1_0			0x100
+#define CGU_PCR_1_1			0x104
+#define CGU_PCR_2_0			0x108
+#define CGU_PCR_2_1			0x10c
+#define CGU_PCR_3_0			0x110
+#define CGU_PCR_3_1			0x114
+#define CGU_PCR_3_2			0x118
+#define CGU_PCR_4_0			0x11c
+#define CGU_PCR_4_1			0x120
+#define CGU_PCR_5			0x124
+#define CGU_PCR_6			0x128
+#define CGU_PCR_7			0x12c
+#define CGU_PCR_8			0x130
+#define CGU_PCR_9			0x134
+#define CGU_PCR_10			0x138
+#define CGU_PCR_11			0x13c
+#define CGU_PCR_12			0x140
+#define CGU_PCR_13			0x144
+#define CGU_PCR_WAKE_EN			(0x00000001 <<  2)
+#define CGU_PCR_AUTO			(0x00000001 <<  1)
+#define CGU_PCR_RUN			(0x00000001 <<  0)
+
+
+#define CGU_PSR_0_0			0x148
+#define CGU_PSR_0_1			0x14c
+#define CGU_PSR_0_2			0x150
+#define CGU_PSR_0_3			0x154
+#define CGU_PSR_0_4			0x158
+#define CGU_PSR_0_5			0x15c
+#define CGU_PSR_0_6			0x160
+#define CGU_PSR_0_7			0x164
+#define CGU_PSR_1_0			0x168
+#define CGU_PSR_1_1			0x16c
+#define CGU_PSR_2_0			0x170
+#define CGU_PSR_2_1			0x174
+#define CGU_PSR_3_0			0x178
+#define CGU_PSR_3_1			0x17c
+#define CGU_PSR_3_2			0x180
+#define CGU_PSR_4_0			0x184
+#define CGU_PSR_4_1			0x188
+#define CGU_PSR_5			0x18c
+#define CGU_PSR_6			0x190
+#define CGU_PSR_7			0x194
+#define CGU_PSR_8			0x198
+#define CGU_PSR_9			0x19c
+#define CGU_PSR_10			0x1a0
+#define CGU_PSR_11			0x1a4
+#define CGU_PSR_12			0x1a8
+#define CGU_PSR_13			0x1ac
+
+#define CGU_ESR_0_0			0x1b0
+#define CGU_ESR_0_1			0x1b4
+#define CGU_ESR_0_2			0x1b8
+#define CGU_ESR_0_3			0x1bc
+#define CGU_ESR_0_4			0x1c0
+#define CGU_ESR_0_5			0x1c4
+#define CGU_ESR_0_6			0x1c8
+#define CGU_ESR_0_7			0x1cc
+#define CGU_ESR_1_0			0x1d0
+#define CGU_ESR_1_1			0x1d4
+#define CGU_ESR_2_0			0x1d8
+#define CGU_ESR_2_1			0x1dc
+#define CGU_ESR_3_0			0x1e0
+#define CGU_ESR_3_1			0x1e4
+#define CGU_ESR_3_2			0x1e8
+#define CGU_ESR_4_0			0x1ec
+#define CGU_ESR_4_1			0x1f0
+#define CGU_ESR_5			0x1f4
+#define CGU_ESR_6			0x1f8
+#define CGU_ESR_7			0x1fc
+#define CGU_ESR_8			0x200
+#define CGU_ESR_9			0x204
+#define CGU_ESR_10			0x208
+#define CGU_ESR_11			0x20c
+#define CGU_ESR_12			0x210
+#define CGU_ESR_13			0x214
+#define CGU_ESR_FD_EN			(0x00000001 <<  0)
+
+#define CGU_FDC_0			0x218
+#define CGU_FDC_1			0x21c
+#define CGU_FDC_2			0x220
+#define CGU_FDC_3			0x224
+#define CGU_FDC_4			0x228
+#define CGU_FDC_5			0x22c
+#define CGU_FDC_6			0x230
+#define CGU_FDC_7			0x234
+#define CGU_FDC_8			0x238
+#define CGU_FDC_9			0x23c
+#define CGU_FDC_10			0x240
+#define CGU_FDC_11			0x244
+#define CGU_FDC_12			0x248
+#define CGU_FDC_13			0x24c
+#define CGU_FDC_STRETCH			(0x00000001 <<  0)
+#define CGU_FDC_RESET			(0x00000001 <<  1)
+#define CGU_FDC_RUN1			(0x00000001 <<  2)
+#define CGU_FDC_MADD			(0x000000ff <<  3)
+#define CGU_FDC_MSUB			(0x000000ff << 11)
+
+#endif /* __SAA716x_CGU_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_dcs_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dcs_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_dcs_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dcs_reg.h	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,56 @@
+#ifndef __SAA716x_DCS_REG_H
+#define __SAA716x_DCS_REG_H
+
+/* -------------- DCS Registers -------------- */
+
+#define DCSC_CTRL			0x000
+#define DCSC_SEL_PLLDI			(0x03ffffff <<  5)
+#define DCSC_TOUT_SEL			(0x0000000f <<  1)
+#define DCSC_TOUT_OFF			(0x00000001 <<  0)
+
+#define DCSC_ADDR			0x00c
+#define DCSC_ERR_TOUT_ADDR		(0x3fffffff <<  2)
+
+#define DCSC_STAT			0x010
+#define DCSC_ERR_TOUT_GNT		(0x0000001f << 24)
+#define DCSC_ERR_TOUT_SEL		(0x0000007f << 10)
+#define DCSC_ERR_TOUT_READ		(0x00000001 <<  8)
+#define DCSC_ERR_TOUT_MASK		(0x0000000f <<  4)
+#define DCSC_ERR_ACK			(0x00000001 <<  1)
+
+#define DCSC_FEATURES			0x040
+#define DCSC_UNIQUE_ID			(0x00000007 << 16)
+#define DCSC_SECURITY			(0x00000001 << 14)
+#define DCSC_NUM_BASE_REGS		(0x00000003 << 11)
+#define DCSC_NUM_TARGETS		(0x0000001f <<  5)
+#define DCSC_NUM_INITIATORS		(0x0000001f <<  0)
+
+#define DCSC_BASE_REG0			0x100
+#define DCSC_BASE_N_REG			(0x00000fff << 20)
+
+#define DCSC_INT_CLR_ENABLE		0xfd8
+#define DCSC_INT_CLR_ENABLE_TOUT	(0x00000001 <<  1)
+#define DCSC_INT_CLR_ENABLE_ERROR	(0x00000001 <<  0)
+
+#define DCSC_INT_SET_ENABLE		0xfdc
+#define DCSC_INT_SET_ENABLE_TOUT	(0x00000001 <<  1)
+#define DCSC_INT_SET_ENABLE_ERROR	(0x00000001 <<  0)
+
+#define DCSC_INT_STATUS			0xfe0
+#define DCSC_INT_STATUS_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_STATUS_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_ENABLE			0xfe4
+#define DCSC_INT_ENABLE_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_ENABLE_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_CLR_STATUS		0xfe8
+#define DCSC_INT_CLEAR_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_CLEAR_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_SET_STATUS		0xfec
+#define DCSC_INT_SET_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_SET_ERROR		(0x00000001 <<  0)
+
+
+#endif /* __SAA716x_DCS_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_dma.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,306 @@
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/scatterlist.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include "saa716x_dma.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+/*  Allocates one page of memory, which is stores the data of one
+ *  716x page table. The result gets stored in the passed DMA buffer
+ *  structure.
+ */
+static int saa716x_allocate_ptable(struct saa716x_dmabuf *dmabuf)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	dprintk(SAA716x_DEBUG, 1, "SG Page table allocate");
+	dmabuf->mem_ptab_virt = (void *) __get_free_page(GFP_KERNEL);
+
+	if (dmabuf->mem_ptab_virt == NULL) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Out of pages !");
+		return -ENOMEM;
+	}
+
+	dmabuf->mem_ptab_phys = dma_map_single(&pdev->dev,
+						dmabuf->mem_ptab_virt,
+						SAA716x_PAGE_SIZE,
+						DMA_TO_DEVICE);
+
+	if (dmabuf->mem_ptab_phys == 0) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: map memory failed !");
+		return -ENOMEM;
+	}
+
+	BUG_ON(!(((unsigned long) dmabuf->mem_ptab_phys % SAA716x_PAGE_SIZE) == 0));
+
+	return 0;
+}
+
+static void saa716x_free_ptable(struct saa716x_dmabuf *dmabuf)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	BUG_ON(dmabuf == NULL);
+	dprintk(SAA716x_DEBUG, 1, "SG Page table free");
+
+	/* free physical PCI memory */
+	if (dmabuf->mem_ptab_phys != 0) {
+		dma_unmap_single(&pdev->dev,
+				 dmabuf->mem_ptab_phys,
+				 SAA716x_PAGE_SIZE,
+				 DMA_TO_DEVICE);
+
+		dmabuf->mem_ptab_phys = 0;
+	}
+
+	/* free kernel memory */
+	if (dmabuf->mem_ptab_virt != NULL) {
+		free_page((unsigned long) dmabuf->mem_ptab_virt);
+		dmabuf->mem_ptab_virt = NULL;
+	}
+}
+
+static void saa716x_dmabuf_sgfree(struct saa716x_dmabuf *dmabuf)
+{
+	struct saa716x_dev *saa716x = dmabuf->saa716x;
+
+	BUG_ON(dmabuf == NULL);
+	dprintk(SAA716x_DEBUG, 1, "SG free");
+
+	dmabuf->mem_virt = NULL;
+	if (dmabuf->mem_virt_noalign != NULL) {
+		if (dmabuf->dma_type == SAA716x_DMABUF_INT)
+			vfree(dmabuf->mem_virt_noalign);
+
+		dmabuf->mem_virt_noalign = NULL;
+	}
+
+	if (dmabuf->sg_list != NULL) {
+		kfree(dmabuf->sg_list);
+		dmabuf->sg_list = NULL;
+	}
+}
+
+/*
+ * Create a SG, when an allocated buffer is passed to it,
+ * otherwise the needed memory gets allocated by itself
+ */
+static int saa716x_dmabuf_sgalloc(struct saa716x_dmabuf *dmabuf, void *buf, int size)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct scatterlist *list;
+	struct page *pg;
+
+	int i, pages;
+
+	BUG_ON(!(size > 0));
+	BUG_ON(dmabuf == NULL);
+	dprintk(SAA716x_DEBUG, 1, "SG allocate");
+
+	if ((size % SAA716x_PAGE_SIZE) != 0) /* calculate required pages */
+		pages = size / SAA716x_PAGE_SIZE + 1;
+	else
+		pages = size / SAA716x_PAGE_SIZE;
+
+	/* Allocate memory for SG list */
+	dmabuf->sg_list = kzalloc(sizeof (struct scatterlist) * pages, GFP_KERNEL);
+	if (dmabuf->sg_list == NULL) {
+		dprintk(SAA716x_ERROR, 1, "Failed to allocate memory for scatterlist.");
+		return -ENOMEM;
+	}
+
+	dprintk(SAA716x_DEBUG, 1, "Initializing SG table");
+	sg_init_table(dmabuf->sg_list, pages);
+
+	if (buf == NULL) {
+
+		/* allocate memory, unaligned */
+		dmabuf->mem_virt_noalign = vmalloc((pages + 1) * SAA716x_PAGE_SIZE);
+		if (dmabuf->mem_virt_noalign == NULL) {
+			dprintk(SAA716x_ERROR, 1, "Failed to allocate memory for buffer");
+			return -ENOMEM;
+		}
+
+		/* align memory to page */
+		dmabuf->mem_virt = (void *) PAGE_ALIGN (((unsigned long) dmabuf->mem_virt_noalign));
+
+		BUG_ON(!((((unsigned long) dmabuf->mem_virt) % SAA716x_PAGE_SIZE) == 0));
+	} else {
+		dmabuf->mem_virt = buf;
+	}
+
+	dmabuf->list_len = pages; /* scatterlist length */
+	list = dmabuf->sg_list;
+
+	dprintk(SAA716x_DEBUG, 1, "Allocating SG pages");
+	for (i = 0; i < pages; i++) {
+		if (buf == NULL)
+			pg = vmalloc_to_page(dmabuf->mem_virt + i * SAA716x_PAGE_SIZE);
+		else
+			pg = virt_to_page(dmabuf->mem_virt + i * SAA716x_PAGE_SIZE);
+
+		BUG_ON(pg == NULL);
+		sg_set_page(&list[i], pg, SAA716x_PAGE_SIZE, 0);
+	}
+
+	dprintk(SAA716x_DEBUG, 1, "Done!");
+	return 0;
+}
+
+/*  Fill the "page table" page with the pointers to the specified SG buffer */
+static void saa716x_dmabuf_sgpagefill(struct saa716x_dmabuf *dmabuf, struct scatterlist *sg_list, int pages, int offset)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct pci_dev *pdev		= saa716x->pdev;
+	struct scatterlist *sg_cur;
+
+	u32 *page;
+	int i, j, k = 0;
+	dma_addr_t addr = 0;
+
+	BUG_ON(dmabuf == NULL);
+	BUG_ON(sg_list == NULL);
+	BUG_ON(pages == 0);
+	dprintk(SAA716x_DEBUG, 1, "SG page fill");
+
+	/* make page writable for the PC */
+	dma_sync_single_for_cpu(&pdev->dev, dmabuf->mem_ptab_phys, SAA716x_PAGE_SIZE, DMA_TO_DEVICE);
+	page = dmabuf->mem_ptab_virt;
+
+	/* create page table */
+	for (i = 0; i < pages; i++) {
+		sg_cur = &sg_list[i];
+		BUG_ON(!(((sg_cur->length + sg_cur->offset) % SAA716x_PAGE_SIZE) == 0));
+
+		if (i == 0)
+			dmabuf->offset = (sg_cur->length + sg_cur->offset) % SAA716x_PAGE_SIZE;
+		else
+			BUG_ON(sg_cur->offset != 0);
+
+		for (j = 0; (j * SAA716x_PAGE_SIZE) < sg_dma_len(sg_cur); j++) {
+
+			if ((offset + sg_cur->offset) >= SAA716x_PAGE_SIZE) {
+				offset -= SAA716x_PAGE_SIZE;
+				continue;
+			}
+
+			addr = ((u64)sg_dma_address(sg_cur)) + (j * SAA716x_PAGE_SIZE) - sg_cur->offset;
+
+			BUG_ON(addr == 0);
+			page[k * 2] = (u32 )addr; /* Low */
+			page[k * 2 + 1] = (u32 )(((u64) addr) >> 32); /* High */
+			BUG_ON(page[k * 2] % SAA716x_PAGE_SIZE);
+			k++;
+		}
+	}
+
+	for (; k < (SAA716x_PAGE_SIZE / 8); k++) {
+		page[k * 2] = (u32 ) addr;
+		page[k * 2 + 1] = (u32 ) (((u64 ) addr) >> 32);
+	}
+
+	/* make "page table" page writable for the PC */
+	dma_sync_single_for_device(&pdev->dev,
+				   dmabuf->mem_ptab_phys,
+				   SAA716x_PAGE_SIZE,
+				   DMA_TO_DEVICE);
+
+}
+
+void saa716x_dmabufsync_dev(struct saa716x_dmabuf *dmabuf)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	dprintk(SAA716x_DEBUG, 1, "DMABUF sync DEVICE");
+	BUG_ON(dmabuf->sg_list == NULL);
+
+	dma_sync_sg_for_device(&pdev->dev,
+			       dmabuf->sg_list,
+			       dmabuf->list_len,
+			       DMA_FROM_DEVICE);
+
+}
+
+void saa716x_dmabufsync_cpu(struct saa716x_dmabuf *dmabuf)
+{
+	struct saa716x_dev *saa716x	= dmabuf->saa716x;
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	dprintk(SAA716x_DEBUG, 1, "DMABUF sync CPU");
+	BUG_ON(dmabuf->sg_list == NULL);
+
+	dma_sync_sg_for_cpu(&pdev->dev,
+			    dmabuf->sg_list,
+			    dmabuf->list_len,
+			    DMA_FROM_DEVICE);
+}
+
+/* Allocates a DMA buffer for the specified external linear buffer. */
+int saa716x_dmabuf_alloc(struct saa716x_dev *saa716x, struct saa716x_dmabuf *dmabuf, int size)
+{
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	int ret;
+
+	BUG_ON(saa716x == NULL);
+	BUG_ON(dmabuf == NULL);
+	BUG_ON(! (size > 0));
+
+	dmabuf->dma_type		= SAA716x_DMABUF_INT;
+
+	dmabuf->mem_virt_noalign	= NULL;
+	dmabuf->mem_virt		= NULL;
+	dmabuf->mem_ptab_phys		= 0;
+	dmabuf->mem_ptab_virt		= NULL;
+
+	dmabuf->list_len		= 0;
+	dmabuf->saa716x			= saa716x;
+
+	/* Allocate page table */
+	ret = saa716x_allocate_ptable(dmabuf);
+	if (ret < 0) {
+		dprintk(SAA716x_ERROR, 1, "PT alloc failed, Out of memory");
+		goto err1;
+	}
+
+	/* Allocate buffer as SG */
+	ret = saa716x_dmabuf_sgalloc(dmabuf, NULL, size);
+	if (ret < 0) {
+		dprintk(SAA716x_ERROR, 1, "SG alloc failed");
+		goto err2;
+	}
+
+	ret = dma_map_sg(&pdev->dev, dmabuf->sg_list, dmabuf->list_len, DMA_FROM_DEVICE);
+	if (ret < 0) {
+		dprintk(SAA716x_ERROR, 1, "SG map failed");
+		goto err3;
+	}
+
+	saa716x_dmabuf_sgpagefill(dmabuf, dmabuf->sg_list, ret, 0);
+
+	return 0;
+err3:
+	saa716x_dmabuf_sgfree(dmabuf);
+err2:
+	saa716x_free_ptable(dmabuf);
+err1:
+	return ret;
+}
+
+void saa716x_dmabuf_free(struct saa716x_dev *saa716x, struct saa716x_dmabuf *dmabuf)
+{
+	struct pci_dev *pdev		= saa716x->pdev;
+
+	BUG_ON(saa716x == NULL);
+	BUG_ON(dmabuf == NULL);
+
+	dma_unmap_sg(&pdev->dev, dmabuf->sg_list, dmabuf->list_len, DMA_FROM_DEVICE);
+	saa716x_dmabuf_sgfree(dmabuf);
+	saa716x_free_ptable(dmabuf);
+}
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_dma.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,38 @@
+#ifndef __SAA716x_DMA_H
+#define __SAA716x_DMA_H
+
+#define SAA716x_PAGE_SIZE	4096
+
+enum saa716x_dma_type {
+	SAA716x_DMABUF_EXT_LIN, /* Linear external */
+	SAA716x_DMABUF_EXT_SG, /* SG external */
+	SAA716x_DMABUF_INT /* Linear internal */
+};
+
+struct saa716x_dev;
+
+struct saa716x_dmabuf {
+	enum saa716x_dma_type	dma_type;
+
+	void			*mem_virt_noalign;
+	void			*mem_virt; /* page aligned */
+	dma_addr_t		mem_ptab_phys;
+	void			*mem_ptab_virt;
+	void			*sg_list; /* SG list */
+
+	struct saa716x_dev	*saa716x;
+
+	int			list_len; /* buffer len */
+	int			offset; /* page offset */
+};
+
+extern int saa716x_dmabuf_alloc(struct saa716x_dev *saa716x,
+				struct saa716x_dmabuf *dmabuf,
+				int size);
+extern void saa716x_dmabuf_free(struct saa716x_dev *saa716x,
+				struct saa716x_dmabuf *dmabuf);
+
+extern void saa716x_dmabufsync_dev(struct saa716x_dmabuf *dmabuf);
+extern void saa716x_dmabufsync_cpu(struct saa716x_dmabuf *dmabuf);
+
+#endif /* __SAA716x_DMA_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_dma_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_dma_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_dma_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,200 @@
+#ifndef __SAA716x_DMA_REG_H
+#define __SAA716x_DMA_REG_H
+
+/* -------------- BAM Registers -------------- */
+
+#define BAM_VI0_0_DMA_BUF_MODE		0x000
+
+#define BAM_VI0_0_ADDR_OFFST_0		0x004
+#define BAM_VI0_0_ADDR_OFFST_1		0x008
+#define BAM_VI0_0_ADDR_OFFST_2		0x00c
+#define BAM_VI0_0_ADDR_OFFST_3		0x010
+#define BAM_VI0_0_ADDR_OFFST_4		0x014
+#define BAM_VI0_0_ADDR_OFFST_5		0x018
+#define BAM_VI0_0_ADDR_OFFST_6		0x01c
+#define BAM_VI0_0_ADDR_OFFST_7		0x020
+
+#define BAM_VI0_1_DMA_BUF_MODE		0x024
+#define BAM_VI0_1_ADDR_OFFST_0		0x028
+#define BAM_VI0_1_ADDR_OFFST_1		0x02c
+#define BAM_VI0_1_ADDR_OFFST_2		0x030
+#define BAM_VI0_1_ADDR_OFFST_3		0x034
+#define BAM_VI0_1_ADDR_OFFST_4		0x038
+#define BAM_VI0_1_ADDR_OFFST_5		0x03c
+#define BAM_VI0_1_ADDR_OFFST_6		0x040
+#define BAM_VI0_1_ADDR_OFFST_7		0x044
+
+#define BAM_VI0_2_DMA_BUF_MODE		0x048
+#define BAM_VI0_2_ADDR_OFFST_0		0x04c
+#define BAM_VI0_2_ADDR_OFFST_1		0x050
+#define BAM_VI0_2_ADDR_OFFST_2		0x054
+#define BAM_VI0_2_ADDR_OFFST_3		0x058
+#define BAM_VI0_2_ADDR_OFFST_4		0x05c
+#define BAM_VI0_2_ADDR_OFFST_5		0x060
+#define BAM_VI0_2_ADDR_OFFST_6		0x064
+#define BAM_VI0_2_ADDR_OFFST_7		0x068
+
+
+#define BAM_VI1_0_DMA_BUF_MODE		0x06c
+#define BAM_VI1_0_ADDR_OFFST_0		0x070
+#define BAM_VI1_0_ADDR_OFFST_1		0x074
+#define BAM_VI1_0_ADDR_OFFST_2		0x078
+#define BAM_VI1_0_ADDR_OFFST_3		0x07c
+#define BAM_VI1_0_ADDR_OFFST_4		0x080
+#define BAM_VI1_0_ADDR_OFFST_5		0x084
+#define BAM_VI1_0_ADDR_OFFST_6		0x088
+#define BAM_VI1_0_ADDR_OFFST_7		0x08c
+
+#define BAM_VI1_1_DMA_BUF_MODE		0x090
+#define BAM_VI1_1_ADDR_OFFST_0		0x094
+#define BAM_VI1_1_ADDR_OFFST_1		0x098
+#define BAM_VI1_1_ADDR_OFFST_2		0x09c
+#define BAM_VI1_1_ADDR_OFFST_3		0x0a0
+#define BAM_VI1_1_ADDR_OFFST_4		0x0a4
+#define BAM_VI1_1_ADDR_OFFST_5		0x0a8
+#define BAM_VI1_1_ADDR_OFFST_6		0x0ac
+#define BAM_VI1_1_ADDR_OFFST_7		0x0b0
+
+#define BAM_VI1_2_DMA_BUF_MODE		0x0b4
+#define BAM_VI1_2_ADDR_OFFST_0		0x0b8
+#define BAM_VI1_2_ADDR_OFFST_1		0x0bc
+#define BAM_VI1_2_ADDR_OFFST_2		0x0c0
+#define BAM_VI1_2_ADDR_OFFST_3		0x0c4
+#define BAM_VI1_2_ADDR_OFFST_4		0x0c8
+#define BAM_VI1_2_ADDR_OFFST_5		0x0cc
+#define BAM_VI1_2_ADDR_OFFST_6		0x0d0
+#define BAM_VI1_2_ADDR_OFFST_7		0x0d4
+
+
+#define BAM_FGPI0_DMA_BUF_MODE		0x0d8
+#define BAM_FGPI0_ADDR_OFFST_0		0x0dc
+#define BAM_FGPI0_ADDR_OFFST_1		0x0e0
+#define BAM_FGPI0_ADDR_OFFST_2		0x0e4
+#define BAM_FGPI0_ADDR_OFFST_3		0x0e8
+#define BAM_FGPI0_ADDR_OFFST_4		0x0ec
+#define BAM_FGPI0_ADDR_OFFST_5		0x0f0
+#define BAM_FGPI0_ADDR_OFFST_6		0x0f4
+#define BAM_FGPI0_ADDR_OFFST_7		0x0f8
+
+#define BAM_FGPI1_DMA_BUF_MODE		0x0fc
+#define BAM_FGPI1_ADDR_OFFST_0		0x100
+#define BAM_FGPI1_ADDR_OFFST_1		0x104
+#define BAM_FGPI1_ADDR_OFFST_2		0x108
+#define BAM_FGPI1_ADDR_OFFST_3		0x10c
+#define BAM_FGPI1_ADDR_OFFST_4		0x110
+#define BAM_FGPI1_ADDR_OFFST_5		0x114
+#define BAM_FGPI1_ADDR_OFFST_6		0x118
+#define BAM_FGPI1_ADDR_OFFST_7		0x11c
+
+#define BAM_FGPI2_DMA_BUF_MODE		0x120
+#define BAM_FGPI2_ADDR_OFFST_0		0x124
+#define BAM_FGPI2_ADDR_OFFST_1		0x128
+#define BAM_FGPI2_ADDR_OFFST_2		0x12c
+#define BAM_FGPI2_ADDR_OFFST_3		0x130
+#define BAM_FGPI2_ADDR_OFFST_4		0x134
+#define BAM_FGPI2_ADDR_OFFST_5		0x138
+#define BAM_FGPI2_ADDR_OFFST_6		0x13c
+#define BAM_FGPI2_ADDR_OFFST_7		0x140
+
+#define BAM_FGPI3_DMA_BUF_MODE		0x144
+#define BAM_FGPI3_ADDR_OFFST_0		0x148
+#define BAM_FGPI3_ADDR_OFFST_1		0x14c
+#define BAM_FGPI3_ADDR_OFFST_2		0x150
+#define BAM_FGPI3_ADDR_OFFST_3		0x154
+#define BAM_FGPI3_ADDR_OFFST_4		0x158
+#define BAM_FGPI3_ADDR_OFFST_5		0x15c
+#define BAM_FGPI3_ADDR_OFFST_6		0x160
+#define BAM_FGPI3_ADDR_OFFST_7		0x164
+
+
+#define BAM_AI0_DMA_BUF_MODE		0x168
+#define BAM_AI0_ADDR_OFFST_0		0x16c
+#define BAM_AI0_ADDR_OFFST_1		0x170
+#define BAM_AI0_ADDR_OFFST_2		0x174
+#define BAM_AI0_ADDR_OFFST_3		0x178
+#define BAM_AI0_ADDR_OFFST_4		0x17c
+#define BAM_AIO_ADDR_OFFST_5		0x180
+#define BAM_AI0_ADDR_OFFST_6		0x184
+#define BAM_AIO_ADDR_OFFST_7		0x188
+
+#define BAM_AI1_DMA_BUF_MODE		0x18c
+#define BAM_AI1_ADDR_OFFST_0		0x190
+#define BAM_AI1_ADDR_OFFST_1		0x194
+#define BAM_AI1_ADDR_OFFST_2		0x198
+#define BAM_AI1_ADDR_OFFST_3		0x19c
+#define BAM_AI1_ADDR_OFFST_4		0x1a0
+#define BAM_AI1_ADDR_OFFST_5		0x1a4
+#define BAM_AI1_ADDR_OFFST_6		0x1a8
+#define BAM_AI1_ADDR_OFFST_7		0x1ac
+
+#define BAM_SW_RST			0xff0
+#define BAM_SW_RESET			(0x00000001 <<  0)
+
+
+
+
+
+/* -------------- MMU Registers -------------- */
+
+#define MMU_MODE			0x000
+
+#define MMU_DMA_CONFIG0			0x004
+#define MMU_DMA_CONFIG1			0x008
+#define MMU_DMA_CONFIG2			0x00c
+#define MMU_DMA_CONFIG3			0x010
+#define MMU_DMA_CONFIG4			0x014
+#define MMU_DMA_CONFIG5			0x018
+#define MMU_DMA_CONFIG6			0x01c
+#define MMU_DMA_CONFIG7			0x020
+#define MMU_DMA_CONFIG8			0x024
+#define MMU_DMA_CONFIG9			0x028
+#define MMU_DMA_CONFIG10		0x02c
+#define MMU_DMA_CONFIG11		0x030
+#define MMU_DMA_CONFIG12		0x034
+#define MMU_DMA_CONFIG13		0x038
+#define MMU_DMA_CONFIG14		0x03c
+#define MMU_DMA_CONFIG15		0x040
+
+#define MMU_SW_RST			0xff0
+#define MMU_SW_RESET			(0x0001 <<  0)
+
+#define MMU_PTA_BASE0			0x044 /* DMA 0 */
+#define MMU_PTA_BASE1			0x084 /* DMA 1 */
+#define MMU_PTA_BASE2			0x0c4 /* DMA 2 */
+#define MMU_PTA_BASE3			0x104 /* DMA 3 */
+#define MMU_PTA_BASE4			0x144 /* DMA 4 */
+#define MMU_PTA_BASE5			0x184 /* DMA 5 */
+#define MMU_PTA_BASE6			0x1c4 /* DMA 6 */
+#define MMU_PTA_BASE7			0x204 /* DMA 7 */
+#define MMU_PTA_BASE8			0x244 /* DMA 8 */
+#define MMU_PTA_BASE9			0x284 /* DMA 9 */
+#define MMU_PTA_BASE10			0x2c4 /* DMA 10 */
+#define MMU_PTA_BASE11			0x304 /* DMA 11 */
+#define MMU_PTA_BASE12			0x344 /* DMA 12 */
+#define MMU_PTA_BASE13			0x384 /* DMA 13 */
+#define MMU_PTA_BASE14			0x3c4 /* DMA 14 */
+#define MMU_PTA_BASE15			0x404 /* DMA 15 */
+
+#define MMU_PTA_BASE			0x044 /* DMA 0 */
+#define MMU_PTA_OFFSET			0x40
+
+#define PTA_BASE(__ch)			(MMU_PTA_BASE + (MMU_PTA_OFFSET * __ch))
+
+#define MMU_PTA0_LSB(__ch)		PTA_BASE(__ch) + 0x00
+#define MMU_PTA0_MSB(__ch)		PTA_BASE(__ch) + 0x04
+#define MMU_PTA1_LSB(__ch)		PTA_BASE(__ch) + 0x08
+#define MMU_PTA1_MSB(__ch)		PTA_BASE(__ch) + 0x0c
+#define MMU_PTA2_LSB(__ch)		PTA_BASE(__ch) + 0x10
+#define MMU_PTA2_MSB(__ch)		PTA_BASE(__ch) + 0x14
+#define MMU_PTA3_LSB(__ch)		PTA_BASE(__ch) + 0x18
+#define MMU_PTA3_MSB(__ch)		PTA_BASE(__ch) + 0x1c
+#define MMU_PTA4_LSB(__ch)		PTA_BASE(__ch) + 0x20
+#define MMU_PTA4_MSB(__ch)		PTA_BASE(__ch) + 0x24
+#define MMU_PTA5_LSB(__ch)		PTA_BASE(__ch) + 0x28
+#define MMU_PTA5_MSB(__ch)		PTA_BASE(__ch) + 0x2c
+#define MMU_PTA6_LSB(__ch)		PTA_BASE(__ch) + 0x30
+#define MMU_PTA6_MSB(__ch)		PTA_BASE(__ch) + 0x34
+#define MMU_PTA7_LSB(__ch)		PTA_BASE(__ch) + 0x38
+#define MMU_PTA7_MSB(__ch)		PTA_BASE(__ch) + 0x3c
+
+#endif /* __SAA716x_DMA_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_cmd.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_cmd.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_cmd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_cmd.c	2012-06-18 22:34:17.044032272 +0200
@@ -0,0 +1,412 @@
+#include <linux/types.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/osd.h>
+
+#include "saa716x_phi_reg.h"
+
+#include "saa716x_phi.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+#include "saa716x_ff.h"
+#include "saa716x_ff_cmd.h"
+
+
+int sti7109_cmd_init(struct sti7109_dev *sti7109)
+{
+	mutex_init(&sti7109->cmd_lock);
+	mutex_init(&sti7109->osd_cmd_lock);
+	mutex_init(&sti7109->data_lock);
+
+	init_waitqueue_head(&sti7109->boot_finish_wq);
+	sti7109->boot_finished = 0;
+
+	init_waitqueue_head(&sti7109->cmd_ready_wq);
+	sti7109->cmd_ready = 0;
+
+	init_waitqueue_head(&sti7109->result_avail_wq);
+	sti7109->result_avail = 0;
+
+	init_waitqueue_head(&sti7109->osd_cmd_ready_wq);
+	sti7109->osd_cmd_ready = 0;
+	init_waitqueue_head(&sti7109->osd_result_avail_wq);
+	sti7109->osd_result_avail = 0;
+
+	sti7109->data_handle = 0;
+	sti7109->data_buffer = (u8 *) (sti7109->iobuf + TSOUT_LEN + TSBUF_LEN);
+	init_waitqueue_head(&sti7109->data_ready_wq);
+	sti7109->data_ready = 0;
+	init_waitqueue_head(&sti7109->block_done_wq);
+	sti7109->block_done = 0;
+	return 0;
+}
+
+static int sti7109_do_raw_cmd(struct sti7109_dev * sti7109)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	unsigned long timeout;
+
+	timeout = 1 * HZ;
+	timeout = wait_event_interruptible_timeout(sti7109->cmd_ready_wq,
+						   sti7109->cmd_ready == 1,
+						   timeout);
+
+	if (timeout == -ERESTARTSYS || sti7109->cmd_ready == 0) {
+		if (timeout == -ERESTARTSYS) {
+			/* a signal arrived */
+			dprintk(SAA716x_ERROR, 1, "cmd ERESTARTSYS");
+			return -ERESTARTSYS;
+		}
+		dprintk(SAA716x_ERROR, 1,
+			"timed out waiting for command ready");
+		return -EIO;
+	}
+
+	sti7109->cmd_ready = 0;
+	sti7109->result_avail = 0;
+	saa716x_phi_write(saa716x, ADDR_CMD_DATA, sti7109->cmd_data,
+			  sti7109->cmd_len);
+	SAA716x_EPWR(PHI_1, FPGA_ADDR_PHI_ISET, ISR_CMD_MASK);
+
+	if (sti7109->result_max_len > 0) {
+		timeout = 1 * HZ;
+		timeout = wait_event_interruptible_timeout(
+				sti7109->result_avail_wq,
+				sti7109->result_avail == 1,
+				timeout);
+
+		if (timeout == -ERESTARTSYS || sti7109->result_avail == 0) {
+			sti7109->result_len = 0;
+			if (timeout == -ERESTARTSYS) {
+				/* a signal arrived */
+				dprintk(SAA716x_ERROR, 1, "result ERESTARTSYS");
+				return -ERESTARTSYS;
+			}
+			dprintk(SAA716x_ERROR, 1,
+				"timed out waiting for command result");
+			return -EIO;
+		}
+
+		if (sti7109->result_len > sti7109->result_max_len) {
+			sti7109->result_len = sti7109->result_max_len;
+			dprintk(SAA716x_NOTICE, 1,
+				"not enough space in result buffer");
+		}
+	}
+
+	return 0;
+}
+
+int sti7109_raw_cmd(struct sti7109_dev * sti7109, osd_raw_cmd_t * cmd)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	int err;
+
+	if (cmd->cmd_len > SIZE_CMD_DATA) {
+		dprintk(SAA716x_ERROR, 1, "command too long");
+		return -EFAULT;
+	}
+
+	mutex_lock(&sti7109->cmd_lock);
+
+	err = -EFAULT;
+	if (copy_from_user(sti7109->cmd_data, (void __user *)cmd->cmd_data,
+			   cmd->cmd_len))
+		goto out;
+
+	sti7109->cmd_len = cmd->cmd_len;
+	sti7109->result_max_len = cmd->result_len;
+
+	err = sti7109_do_raw_cmd(sti7109);
+	if (err)
+		goto out;
+
+	cmd->result_len = sti7109->result_len;
+	if (sti7109->result_len > 0) {
+		if (copy_to_user((void __user *)cmd->result_data,
+				 sti7109->result_data,
+				 sti7109->result_len))
+			err = -EFAULT;
+	}
+
+out:
+	mutex_unlock(&sti7109->cmd_lock);
+	return err;
+}
+
+static int sti7109_do_raw_osd_cmd(struct sti7109_dev * sti7109)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	unsigned long timeout;
+
+	timeout = 1 * HZ;
+	timeout = wait_event_interruptible_timeout(sti7109->osd_cmd_ready_wq,
+						   sti7109->osd_cmd_ready == 1,
+						   timeout);
+
+	if (timeout == -ERESTARTSYS || sti7109->osd_cmd_ready == 0) {
+		if (timeout == -ERESTARTSYS) {
+			/* a signal arrived */
+			dprintk(SAA716x_ERROR, 1, "osd cmd ERESTARTSYS");
+			return -ERESTARTSYS;
+		}
+		dprintk(SAA716x_ERROR, 1,
+			"timed out waiting for osd command ready");
+		return -EIO;
+	}
+
+	sti7109->osd_cmd_ready = 0;
+	sti7109->osd_result_avail = 0;
+	saa716x_phi_write(saa716x, ADDR_OSD_CMD_DATA, sti7109->osd_cmd_data,
+			  sti7109->osd_cmd_len);
+	SAA716x_EPWR(PHI_1, FPGA_ADDR_PHI_ISET, ISR_OSD_CMD_MASK);
+
+	if (sti7109->osd_result_max_len > 0) {
+		timeout = 1 * HZ;
+		timeout = wait_event_interruptible_timeout(
+				sti7109->osd_result_avail_wq,
+				sti7109->osd_result_avail == 1,
+				timeout);
+
+		if (timeout == -ERESTARTSYS || sti7109->osd_result_avail == 0) {
+			sti7109->osd_result_len = 0;
+			if (timeout == -ERESTARTSYS) {
+				/* a signal arrived */
+				dprintk(SAA716x_ERROR, 1,
+					"osd result ERESTARTSYS");
+				return -ERESTARTSYS;
+			}
+			dprintk(SAA716x_ERROR, 1,
+				"timed out waiting for osd command result");
+			return -EIO;
+		}
+
+		if (sti7109->osd_result_len > sti7109->osd_result_max_len) {
+			sti7109->osd_result_len = sti7109->osd_result_max_len;
+			dprintk(SAA716x_NOTICE, 1,
+				"not enough space in result buffer");
+		}
+	}
+
+	return 0;
+}
+
+int sti7109_raw_osd_cmd(struct sti7109_dev * sti7109, osd_raw_cmd_t * cmd)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	int err;
+
+	if (cmd->cmd_len > SIZE_OSD_CMD_DATA) {
+		dprintk(SAA716x_ERROR, 1, "command too long");
+		return -EFAULT;
+	}
+
+	mutex_lock(&sti7109->osd_cmd_lock);
+
+	err = -EFAULT;
+	if (copy_from_user(sti7109->osd_cmd_data, (void __user *)cmd->cmd_data,
+			   cmd->cmd_len))
+		goto out;
+
+	sti7109->osd_cmd_len = cmd->cmd_len;
+	sti7109->osd_result_max_len = cmd->result_len;
+
+	err = sti7109_do_raw_osd_cmd(sti7109);
+	if (err)
+		goto out;
+
+	cmd->result_len = sti7109->osd_result_len;
+	if (sti7109->osd_result_len > 0) {
+		if (copy_to_user((void __user *)cmd->result_data,
+				 sti7109->osd_result_data,
+				 sti7109->osd_result_len))
+			err = -EFAULT;
+	}
+
+out:
+	mutex_unlock(&sti7109->osd_cmd_lock);
+	return err;
+}
+
+static int sti7109_do_raw_data(struct sti7109_dev * sti7109, osd_raw_data_t * data)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	unsigned long timeout;
+	u16 blockSize;
+	u16 lastBlockSize;
+	u16 numBlocks;
+	u16 blockIndex;
+	u8 blockHeader[SIZE_BLOCK_HEADER];
+	u8 * blockPtr;
+	int activeBlock;
+
+	timeout = 1 * HZ;
+	timeout = wait_event_interruptible_timeout(sti7109->data_ready_wq,
+						   sti7109->data_ready == 1,
+						   timeout);
+
+	if (timeout == -ERESTARTSYS || sti7109->data_ready == 0) {
+		if (timeout == -ERESTARTSYS) {
+			/* a signal arrived */
+			dprintk(SAA716x_ERROR, 1, "data ERESTARTSYS");
+			return -ERESTARTSYS;
+		}
+		dprintk(SAA716x_ERROR, 1, "timed out waiting for data ready");
+		return -EIO;
+	}
+
+	sti7109->data_ready = 0;
+
+	/*
+	 * 8 bytes is the size of the block header. Block header structure is:
+	 * 16 bit - block index
+	 * 16 bit - number of blocks
+	 * 16 bit - current block data size
+	 * 16 bit - block handle. This is used to reference the data in the
+	 *          command that uses it.
+	 */
+	blockSize = (SIZE_BLOCK_DATA / 2) - SIZE_BLOCK_HEADER;
+	numBlocks = data->data_length / blockSize;
+	lastBlockSize = data->data_length % blockSize;
+	if (lastBlockSize > 0)
+		numBlocks++;
+
+	blockHeader[2] = (u8) (numBlocks >> 8);
+	blockHeader[3] = (u8) numBlocks;
+	blockHeader[6] = (u8) (sti7109->data_handle >> 8);
+	blockHeader[7] = (u8) sti7109->data_handle;
+	blockPtr = sti7109->data_buffer;
+	activeBlock = 0;
+	for (blockIndex = 0; blockIndex < numBlocks; blockIndex++) {
+		u32 addr;
+
+		if (lastBlockSize && (blockIndex == (numBlocks - 1)))
+			blockSize = lastBlockSize;
+
+		blockHeader[0] = (uint8_t) (blockIndex >> 8);
+		blockHeader[1] = (uint8_t) blockIndex;
+		blockHeader[4] = (uint8_t) (blockSize >> 8);
+		blockHeader[5] = (uint8_t) blockSize;
+
+		addr = ADDR_BLOCK_DATA + activeBlock * (SIZE_BLOCK_DATA / 2);
+		saa716x_phi_write(saa716x, addr, blockHeader,
+				  SIZE_BLOCK_HEADER);
+		saa716x_phi_write(saa716x, addr + SIZE_BLOCK_HEADER, blockPtr,
+				  blockSize);
+		activeBlock = (activeBlock + 1) & 1;
+		if (blockIndex > 0) {
+			timeout = 1 * HZ;
+			timeout = wait_event_timeout(sti7109->block_done_wq,
+						     sti7109->block_done == 1,
+						     timeout);
+
+			if (sti7109->block_done == 0) {
+				dprintk(SAA716x_ERROR, 1,
+					"timed out waiting for block done");
+				return -EIO;
+			}
+		}
+		sti7109->block_done = 0;
+		SAA716x_EPWR(PHI_1, FPGA_ADDR_PHI_ISET, ISR_BLOCK_MASK);
+		blockPtr += blockSize;
+	}
+	timeout = 1 * HZ;
+	timeout = wait_event_timeout(sti7109->block_done_wq,
+				     sti7109->block_done == 1,
+				     timeout);
+
+	if (sti7109->block_done == 0) {
+		dprintk(SAA716x_ERROR, 1, "timed out waiting for block done");
+		return -EIO;
+	}
+	sti7109->block_done = 0;
+
+	data->data_handle = sti7109->data_handle;
+	sti7109->data_handle++;
+	return 0;
+}
+
+int sti7109_raw_data(struct sti7109_dev * sti7109, osd_raw_data_t * data)
+{
+	struct saa716x_dev * saa716x = sti7109->dev;
+	int err;
+
+	if (data->data_length > MAX_DATA_LEN) {
+		dprintk(SAA716x_ERROR, 1, "data too big");
+		return -EFAULT;
+	}
+
+	mutex_lock(&sti7109->data_lock);
+
+	err = -EFAULT;
+	if (copy_from_user(sti7109->data_buffer,
+			   (void __user *)data->data_buffer,
+			   data->data_length))
+		goto out;
+
+	err = sti7109_do_raw_data(sti7109, data);
+	if (err)
+		goto out;
+
+out:
+	mutex_unlock(&sti7109->data_lock);
+	return err;
+}
+
+int sti7109_cmd_get_fw_version(struct sti7109_dev *sti7109, u32 *fw_version)
+{
+	int ret_val = -EINVAL;
+
+	mutex_lock(&sti7109->cmd_lock);
+
+	sti7109->cmd_data[0] = 0x00;
+	sti7109->cmd_data[1] = 0x04;
+	sti7109->cmd_data[2] = 0x00;
+	sti7109->cmd_data[3] = 0x00;
+	sti7109->cmd_data[4] = 0x00;
+	sti7109->cmd_data[5] = 0x00;
+	sti7109->cmd_len = 6;
+	sti7109->result_max_len = MAX_RESULT_LEN;
+
+	ret_val = sti7109_do_raw_cmd(sti7109);
+	if (ret_val == 0) {
+		*fw_version = (sti7109->result_data[6] << 16)
+			    | (sti7109->result_data[7] << 8)
+			    | sti7109->result_data[8];
+	}
+
+	mutex_unlock(&sti7109->cmd_lock);
+
+	return ret_val;
+}
+
+int sti7109_cmd_get_video_format(struct sti7109_dev *sti7109, video_size_t *vs)
+{
+	int ret_val = -EINVAL;
+
+	mutex_lock(&sti7109->cmd_lock);
+
+	sti7109->cmd_data[0] = 0x00;
+	sti7109->cmd_data[1] = 0x05; /* command length */
+	sti7109->cmd_data[2] = 0x00;
+	sti7109->cmd_data[3] = 0x01; /* A/V decoder command group */
+	sti7109->cmd_data[4] = 0x00;
+	sti7109->cmd_data[5] = 0x10; /* get video format info command */
+	sti7109->cmd_data[6] = 0x00; /* decoder index 0 */
+	sti7109->cmd_len = 7;
+	sti7109->result_max_len = MAX_RESULT_LEN;
+
+	ret_val = sti7109_do_raw_cmd(sti7109);
+	if (ret_val == 0) {
+		vs->w = (sti7109->result_data[7] << 8)
+		      | sti7109->result_data[8];
+		vs->h = (sti7109->result_data[9] << 8)
+		      | sti7109->result_data[10];
+		vs->aspect_ratio = sti7109->result_data[11] >> 4;
+	}
+
+	mutex_unlock(&sti7109->cmd_lock);
+
+	return ret_val;
+}
+
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_cmd.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_cmd.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_cmd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_cmd.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,16 @@
+#ifndef __SAA716x_FF_CMD_H
+#define __SAA716x_FF_CMD_H
+
+extern int sti7109_cmd_init(struct sti7109_dev *sti7109);
+extern int sti7109_raw_cmd(struct sti7109_dev * sti7109,
+			   osd_raw_cmd_t * cmd);
+extern int sti7109_raw_osd_cmd(struct sti7109_dev * sti7109,
+			       osd_raw_cmd_t * cmd);
+extern int sti7109_raw_data(struct sti7109_dev * sti7109,
+			    osd_raw_data_t * data);
+extern int sti7109_cmd_get_fw_version(struct sti7109_dev *sti7109,
+				      u32 *fw_version);
+extern int sti7109_cmd_get_video_format(struct sti7109_dev *sti7109,
+					video_size_t *vs);
+
+#endif /* __SAA716x_FF_CMD_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_ff.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_ff.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,158 @@
+#ifndef __SAA716x_FF_H
+#define __SAA716x_FF_H
+
+#include "dvb_filter.h"
+#include "dvb_ringbuffer.h"
+
+#define TECHNOTREND			0x13c2
+#define S2_6400_DUAL_S2_PREMIUM_DEVEL	0x3009
+#define S2_6400_DUAL_S2_PREMIUM_PROD	0x300A
+
+#define TT_PREMIUM_GPIO_POWER_ENABLE	27
+#define TT_PREMIUM_GPIO_RESET_BACKEND	26
+#define TT_PREMIUM_GPIO_FPGA_CS1	17
+#define TT_PREMIUM_GPIO_FPGA_CS0	16
+#define TT_PREMIUM_GPIO_FPGA_PROGRAMN	15
+#define TT_PREMIUM_GPIO_FPGA_DONE	14
+#define TT_PREMIUM_GPIO_FPGA_INITN	13
+
+/* fpga interrupt register addresses */
+#define FPGA_ADDR_PHI_ICTRL	0x8000 /* PHI General control of the PC => STB interrupt controller */
+#define FPGA_ADDR_PHI_ISR	0x8010 /* PHI Interrupt Status Register */
+#define FPGA_ADDR_PHI_ISET	0x8020 /* PHI Interrupt Set Register */
+#define FPGA_ADDR_PHI_ICLR	0x8030 /* PHI Interrupt Clear Register */
+#define FPGA_ADDR_EMI_ICTRL	0x8100 /* EMI General control of the STB => PC interrupt controller */
+#define FPGA_ADDR_EMI_ISR	0x8110 /* EMI Interrupt Status Register */
+#define FPGA_ADDR_EMI_ISET	0x8120 /* EMI Interrupt Set Register */
+#define FPGA_ADDR_EMI_ICLR	0x8130 /* EMI Interrupt Clear Register */
+
+/* fpga TS router register addresses */
+#define FPGA_ADDR_TSR_CTRL	0x8200 /* TS router control register */
+#define FPGA_ADDR_TSR_MUX1	0x8210 /* TS multiplexer 1 selection register */
+#define FPGA_ADDR_TSR_MUX2	0x8220 /* TS multiplexer 2 selection register */
+#define FPGA_ADDR_TSR_MUX3	0x8230 /* TS multiplexer 3 selection register */
+#define FPGA_ADDR_TSR_MUXCI1	0x8240 /* TS multiplexer CI 1 selection register */
+#define FPGA_ADDR_TSR_MUXCI2	0x8250 /* TS multiplexer CI 2 selection register */
+
+#define FPGA_ADDR_TSR_BRFE1	0x8280 /* bit rate for TS coming from frontend 1 */
+#define FPGA_ADDR_TSR_BRFE2	0x8284 /* bit rate for TS coming from frontend 2 */
+#define FPGA_ADDR_TSR_BRFF1	0x828C /* bit rate for TS coming from FIFO 1 */
+#define FPGA_ADDR_TSR_BRO1	0x8294 /* bit rate for TS going to output 1 */
+#define FPGA_ADDR_TSR_BRO2	0x8298 /* bit rate for TS going to output 2 */
+#define FPGA_ADDR_TSR_BRO3	0x829C /* bit rate for TS going to output 3 */
+
+/* fpga TS FIFO register addresses */
+#define FPGA_ADDR_FIFO_CTRL	0x8300 /* FIFO control register */
+#define FPGA_ADDR_FIFO_STAT	0x8310 /* FIFO status register */
+
+#define FPGA_ADDR_VERSION	0x80F0 /* FPGA bitstream version register */
+
+#define FPGA_ADDR_PIO_CTRL	0x8500 /* FPGA GPIO control register */
+
+#define ISR_CMD_MASK		0x0001 /* interrupt source for normal cmds (osd, fre, av, ...) */
+#define ISR_READY_MASK		0x0002 /* interrupt source for command acknowledge */
+#define ISR_BLOCK_MASK		0x0004 /* interrupt source for single block transfers and acknowledge */
+#define ISR_DATA_MASK		0x0008 /* interrupt source for data transfer acknowledge */
+#define ISR_BOOT_FINISH_MASK	0x0010 /* interrupt source for boot finish indication */
+#define ISR_AUDIO_PTS_MASK	0x0020 /* interrupt source for audio PTS */
+#define ISR_VIDEO_PTS_MASK	0x0040 /* interrupt source for video PTS */
+#define ISR_CURRENT_STC_MASK	0x0080 /* interrupt source for current system clock */
+#define ISR_REMOTE_EVENT_MASK	0x0100 /* interrupt source for remote events */
+#define ISR_DVO_FORMAT_MASK	0x0200 /* interrupt source for DVO format change */
+#define ISR_OSD_CMD_MASK	0x0400 /* interrupt source for OSD cmds */
+#define ISR_OSD_READY_MASK	0x0800 /* interrupt source for OSD command acknowledge */
+#define ISR_FE_CMD_MASK		0x1000 /* interrupt source for frontend cmds */
+#define ISR_FE_READY_MASK	0x2000 /* interrupt source for frontend command acknowledge */
+#define ISR_LOG_MESSAGE_MASK	0x4000 /* interrupt source for log messages */
+#define ISR_FIFO1_EMPTY_MASK	0x8000 /* interrupt source for FIFO1 empty */
+
+#define ADDR_CMD_DATA		0x0000 /* address for cmd data in fpga dpram */
+#define ADDR_OSD_CMD_DATA	0x01A0 /* address for OSD cmd data */
+#define ADDR_FE_CMD_DATA	0x05C0 /* address for frontend cmd data */
+#define ADDR_BLOCK_DATA		0x0600 /* address for block data */
+#define ADDR_AUDIO_PTS		0x3E00 /* address for audio PTS (64 Bits) */
+#define ADDR_VIDEO_PTS		0x3E08 /* address for video PTS (64 Bits) */
+#define ADDR_CURRENT_STC	0x3E10 /* address for system clock (64 Bits) */
+#define ADDR_DVO_FORMAT		0x3E18 /* address for DVO format 32 Bits) */
+#define ADDR_REMOTE_EVENT	0x3F00 /* address for remote events (32 Bits) */
+#define ADDR_LOG_MESSAGE	0x3F80 /* address for log messages */
+
+#define SIZE_CMD_DATA		0x01A0 /* maximum size for command data (416 Bytes) */
+#define SIZE_OSD_CMD_DATA	0x0420 /* maximum size for OSD command data (1056 Bytes) */
+#define SIZE_FE_CMD_DATA	0x0040 /* maximum size for frontend command data (64 Bytes) */
+#define SIZE_BLOCK_DATA		0x3800 /* maximum size for block data (14 kB) */
+#define SIZE_LOG_MESSAGE_DATA	0x0080 /* maximum size for log message data (128 Bytes) */
+
+#define SIZE_BLOCK_HEADER	8      /* block header size */
+
+#define MAX_RESULT_LEN		256
+#define MAX_DATA_LEN		(1024 * 1024)
+
+#define TSOUT_LEN		(1024 * TS_SIZE)
+#define TSBUF_LEN		(8 * 1024)
+
+/* place to store all the necessary device information */
+struct sti7109_dev {
+	struct saa716x_dev	*dev;
+	struct dvb_device	*osd_dev;
+	struct dvb_device	*video_dev;
+	struct dvb_device	*audio_dev;
+
+	void			*iobuf;	 /* memory for all buffers */
+	struct dvb_ringbuffer	tsout;   /* buffer for TS output */
+	u8			*tsbuf;  /* temp ts buffer */
+
+	struct tasklet_struct	fifo_tasklet;
+
+	wait_queue_head_t	boot_finish_wq;
+	int			boot_finished;
+
+	wait_queue_head_t	cmd_ready_wq;
+	int			cmd_ready;
+	u8			cmd_data[SIZE_CMD_DATA];
+	u32			cmd_len;
+
+	wait_queue_head_t	result_avail_wq;
+	int			result_avail;
+	u8			result_data[MAX_RESULT_LEN];
+	u32			result_len;
+	u32			result_max_len;
+
+	wait_queue_head_t	osd_cmd_ready_wq;
+	int			osd_cmd_ready;
+	u8			osd_cmd_data[SIZE_OSD_CMD_DATA];
+	u32			osd_cmd_len;
+
+	wait_queue_head_t	osd_result_avail_wq;
+	int			osd_result_avail;
+	u8			osd_result_data[MAX_RESULT_LEN];
+	u32			osd_result_len;
+	u32			osd_result_max_len;
+
+	u16			data_handle;
+	u8			*data_buffer; /* raw data transfer buffer */
+	wait_queue_head_t	data_ready_wq;
+	int			data_ready;
+	wait_queue_head_t	block_done_wq;
+	int			block_done;
+
+	struct mutex		cmd_lock;
+	struct mutex		osd_cmd_lock;
+	struct mutex		data_lock;
+
+	u64			audio_pts;
+	u64			video_pts;
+	u64			current_stc;
+
+	u32			int_count_enable;
+	u32			total_int_count;
+	u32			fgpi_int_count[2];
+	u32			i2c_int_count[2];
+	u32			ext_int_total_count;
+	u32			ext_int_source_count[16];
+	u32			last_int_ticks;
+
+	u16			fpga_version;
+};
+
+#endif /* __SAA716x_FF_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_ir.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_ir.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_ir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_ir.c	2012-06-18 23:09:30.134033355 +0200
@@ -0,0 +1,265 @@
+/*
+ * Driver for the remote control of the TT6400 DVB-S2 card
+ *
+ * Copyright (C) 2010 Oliver Endriss <o.endriss@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/input.h>
+
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+#include "saa716x_ff.h"
+
+
+/* infrared remote control */
+struct infrared {
+	u16			key_map[128];
+	struct input_dev	*input_dev;
+	char			input_phys[32];
+	struct timer_list	keyup_timer;
+	struct tasklet_struct	tasklet;
+	u32			command;
+	u32			device_mask;
+	u8			protocol;
+	u16			last_key;
+	u16			last_toggle;
+	bool			delay_timer_finished;
+};
+
+#define IR_RC5		0
+#define UP_TIMEOUT	(HZ*7/25)
+
+
+/* key-up timer */
+static void ir_emit_keyup(unsigned long parm)
+{
+	struct infrared *ir = (struct infrared *) parm;
+
+	if (!ir || !test_bit(ir->last_key, ir->input_dev->key))
+		return;
+
+	input_report_key(ir->input_dev, ir->last_key, 0);
+	input_sync(ir->input_dev);
+}
+
+
+/* tasklet */
+static void ir_emit_key(unsigned long parm)
+{
+	struct saa716x_dev *saa716x = (struct saa716x_dev *) parm;
+	struct infrared *ir = saa716x->ir_priv;
+	u32 ircom = ir->command;
+	u8 data;
+	u8 addr;
+	u16 toggle;
+	u16 keycode;
+
+	/* extract device address and data */
+	if (ircom & 0x80000000) { /* CEC remote command */
+		addr = 0;
+		data = ircom & 0x7F;
+		toggle = 0;
+	} else {
+		switch (ir->protocol) {
+		case IR_RC5: /* extended RC5: 5 bits device address, 7 bits data */
+			addr = (ircom >> 6) & 0x1f;
+			/* data bits 1..6 */
+			data = ircom & 0x3f;
+			/* data bit 7 (inverted) */
+			if (!(ircom & 0x1000))
+				data |= 0x40;
+			toggle = ircom & 0x0800;
+			break;
+
+		default:
+			printk(KERN_ERR "%s: invalid protocol %x\n",
+				__func__, ir->protocol);
+			return;
+		}
+	}
+
+	input_event(ir->input_dev, EV_MSC, MSC_RAW, (addr << 16) | data);
+	input_event(ir->input_dev, EV_MSC, MSC_SCAN, data);
+
+	keycode = ir->key_map[data];
+
+	dprintk(SAA716x_DEBUG, 0,
+		"%s: code %08x -> addr %i data 0x%02x -> keycode %i\n",
+		__func__, ircom, addr, data, keycode);
+
+	/* check device address */
+	if (!(ir->device_mask & (1 << addr)))
+		return;
+
+	if (!keycode) {
+		printk(KERN_WARNING "%s: code %08x -> addr %i data 0x%02x -> unknown key!\n",
+			__func__, ircom, addr, data);
+		return;
+	}
+
+	if (timer_pending(&ir->keyup_timer)) {
+		del_timer(&ir->keyup_timer);
+		if (ir->last_key != keycode || toggle != ir->last_toggle) {
+			ir->delay_timer_finished = false;
+			input_event(ir->input_dev, EV_KEY, ir->last_key, 0);
+			input_event(ir->input_dev, EV_KEY, keycode, 1);
+			input_sync(ir->input_dev);
+		} else if (ir->delay_timer_finished) {
+			input_event(ir->input_dev, EV_KEY, keycode, 2);
+			input_sync(ir->input_dev);
+		}
+	} else {
+		ir->delay_timer_finished = false;
+		input_event(ir->input_dev, EV_KEY, keycode, 1);
+		input_sync(ir->input_dev);
+	}
+
+	ir->last_key = keycode;
+	ir->last_toggle = toggle;
+
+	ir->keyup_timer.expires = jiffies + UP_TIMEOUT;
+	add_timer(&ir->keyup_timer);
+
+}
+
+
+/* register with input layer */
+static void ir_register_keys(struct infrared *ir)
+{
+	int i;
+
+	set_bit(EV_KEY, ir->input_dev->evbit);
+	set_bit(EV_REP, ir->input_dev->evbit);
+	set_bit(EV_MSC, ir->input_dev->evbit);
+
+	set_bit(MSC_RAW, ir->input_dev->mscbit);
+	set_bit(MSC_SCAN, ir->input_dev->mscbit);
+
+	memset(ir->input_dev->keybit, 0, sizeof(ir->input_dev->keybit));
+
+	for (i = 0; i < ARRAY_SIZE(ir->key_map); i++) {
+		if (ir->key_map[i] > KEY_MAX)
+			ir->key_map[i] = 0;
+		else if (ir->key_map[i] > KEY_RESERVED)
+			set_bit(ir->key_map[i], ir->input_dev->keybit);
+	}
+
+	ir->input_dev->keycode = ir->key_map;
+	ir->input_dev->keycodesize = sizeof(ir->key_map[0]);
+	ir->input_dev->keycodemax = ARRAY_SIZE(ir->key_map);
+}
+
+
+/* called by the input driver after rep[REP_DELAY] ms */
+static void ir_repeat_key(unsigned long parm)
+{
+	struct infrared *ir = (struct infrared *) parm;
+
+	ir->delay_timer_finished = true;
+}
+
+
+/* interrupt handler */
+void saa716x_ir_handler(struct saa716x_dev *saa716x, u32 ir_cmd)
+{
+	struct infrared *ir = saa716x->ir_priv;
+
+	if (!ir)
+		return;
+
+	ir->command = ir_cmd;
+	tasklet_schedule(&ir->tasklet);
+}
+
+
+int saa716x_ir_init(struct saa716x_dev *saa716x)
+{
+	struct input_dev *input_dev;
+	struct infrared *ir;
+	int rc;
+	int i;
+
+	if (!saa716x)
+		return -ENOMEM;
+
+	ir = kzalloc(sizeof(struct infrared), GFP_KERNEL);
+	if (!ir)
+		return -ENOMEM;
+
+	init_timer(&ir->keyup_timer);
+	ir->keyup_timer.function = ir_emit_keyup;
+	ir->keyup_timer.data = (unsigned long) ir;
+
+	input_dev = input_allocate_device();
+	if (!input_dev)
+		goto err;
+
+	ir->input_dev = input_dev;
+	input_dev->name = "TT6400 DVB IR receiver";
+	snprintf(ir->input_phys, sizeof(ir->input_phys),
+		"pci-%s/ir0", pci_name(saa716x->pdev));
+	input_dev->phys = ir->input_phys;
+	input_dev->id.bustype = BUS_PCI;
+	input_dev->id.version = 1;
+	input_dev->id.vendor = saa716x->pdev->subsystem_vendor;
+	input_dev->id.product = saa716x->pdev->subsystem_device;
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
+	input_dev->dev.parent = &saa716x->pdev->dev;
+//#else
+//	input_dev->cdev.dev = &saa716x->pdev->dev;
+//#endif
+	rc = input_register_device(input_dev);
+	if (rc)
+		goto err;
+
+	/* TODO: fix setup/keymap */
+	ir->protocol = IR_RC5;
+	ir->device_mask = 0xffffffff;
+	for (i = 0; i < ARRAY_SIZE(ir->key_map); i++)
+		ir->key_map[i] = i+1;
+	ir_register_keys(ir);
+
+	/* override repeat timer */
+	input_dev->timer.function = ir_repeat_key;
+	input_dev->timer.data = (unsigned long) ir;
+
+	tasklet_init(&ir->tasklet, ir_emit_key, (unsigned long) saa716x);
+	saa716x->ir_priv = ir;
+
+	return 0;
+
+err:
+	if (ir->input_dev)
+		input_free_device(ir->input_dev);
+	kfree(ir);
+	return -ENOMEM;
+}
+
+
+void saa716x_ir_exit(struct saa716x_dev *saa716x)
+{
+	struct infrared *ir = saa716x->ir_priv;
+
+	saa716x->ir_priv = NULL;
+	tasklet_kill(&ir->tasklet);
+	del_timer_sync(&ir->keyup_timer);
+	input_unregister_device(ir->input_dev);
+	kfree(ir);
+}
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_main.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_main.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_ff_main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_ff_main.c	2012-06-18 23:05:10.324033223 +0200
@@ -0,0 +1,1535 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/byteorder.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <linux/i2c.h>
+
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <linux/dvb/osd.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_dma_reg.h"
+#include "saa716x_fgpi_reg.h"
+#include "saa716x_greg_reg.h"
+#include "saa716x_phi_reg.h"
+#include "saa716x_spi_reg.h"
+#include "saa716x_msi_reg.h"
+
+#include "saa716x_vip.h"
+#include "saa716x_aip.h"
+#include "saa716x_msi.h"
+#include "saa716x_adap.h"
+#include "saa716x_gpio.h"
+#include "saa716x_phi.h"
+#include "saa716x_rom.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+#include "saa716x_ff.h"
+#include "saa716x_ff_cmd.h"
+
+#include "../frontends/stv6110x.h"
+#include "../frontends/stv090x.h"
+#include "../frontends/isl6423.h"
+
+unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
+
+unsigned int int_type;
+module_param(int_type, int, 0644);
+MODULE_PARM_DESC(int_type, "force Interrupt Handler type: 0=INT-A, 1=MSI, 2=MSI-X. default INT-A mode");
+
+unsigned int int_count_enable;
+module_param(int_count_enable, int, 0644);
+MODULE_PARM_DESC(int_count_enable, "enable counting of interrupts");
+
+#define DRIVER_NAME	"SAA716x FF"
+
+static int saa716x_ff_fpga_init(struct saa716x_dev *saa716x)
+{
+	struct sti7109_dev *sti7109 = saa716x->priv;
+	int fpgaInit;
+	int fpgaDone;
+	int rounds;
+	int ret;
+	const struct firmware *fw;
+
+	/* request the FPGA firmware, this will block until someone uploads it */
+	ret = request_firmware(&fw, "dvb-ttpremium-fpga-01.fw", &saa716x->pdev->dev);
+	if (ret) {
+		if (ret == -ENOENT) {
+			printk(KERN_ERR "dvb-ttpremium: could not load FPGA firmware,"
+			       " file not found: dvb-ttpremium-fpga-01.fw\n");
+			printk(KERN_ERR "dvb-ttpremium: usually this should be in "
+			       "/usr/lib/hotplug/firmware or /lib/firmware\n");
+		} else
+			printk(KERN_ERR "dvb-ttpremium: cannot request firmware"
+			       " (error %i)\n", ret);
+		return -EINVAL;
+	}
+
+	/* set FPGA PROGRAMN high */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_FPGA_PROGRAMN, 1);
+	msleep(10);
+
+	/* set FPGA PROGRAMN low to set it into configuration mode */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_FPGA_PROGRAMN, 0);
+	msleep(10);
+
+	/* set FPGA PROGRAMN high to start configuration process */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_FPGA_PROGRAMN, 1);
+
+	rounds = 0;
+	fpgaInit = saa716x_gpio_read(saa716x, TT_PREMIUM_GPIO_FPGA_INITN);
+	while (fpgaInit == 0 && rounds < 5000) {
+		//msleep(1);
+		fpgaInit = saa716x_gpio_read(saa716x, TT_PREMIUM_GPIO_FPGA_INITN);
+		rounds++;
+	}
+	dprintk(SAA716x_INFO, 1, "SAA716x FF FPGA INITN=%d, rounds=%d",
+		fpgaInit, rounds);
+
+	SAA716x_EPWR(SPI, SPI_CLOCK_COUNTER, 0x08);
+	SAA716x_EPWR(SPI, SPI_CONTROL_REG, SPI_MODE_SELECT);
+
+	msleep(10);
+
+	fpgaDone = saa716x_gpio_read(saa716x, TT_PREMIUM_GPIO_FPGA_DONE);
+	dprintk(SAA716x_INFO, 1, "SAA716x FF FPGA DONE=%d", fpgaDone);
+	dprintk(SAA716x_INFO, 1, "SAA716x FF FPGA write bitstream");
+	saa716x_spi_write(saa716x, fw->data, fw->size);
+	dprintk(SAA716x_INFO, 1, "SAA716x FF FPGA write bitstream done");
+	fpgaDone = saa716x_gpio_read(saa716x, TT_PREMIUM_GPIO_FPGA_DONE);
+	dprintk(SAA716x_INFO, 1, "SAA716x FF FPGA DONE=%d", fpgaDone);
+
+	msleep(10);
+
+	release_firmware(fw);
+
+	if (!fpgaDone) {
+		printk(KERN_ERR "SAA716x FF FPGA is not responding, did you "
+				"connect the power supply?\n");
+		return -EINVAL;
+	}
+
+	sti7109->fpga_version = SAA716x_EPRD(PHI_1, FPGA_ADDR_VERSION);
+	printk(KERN_INFO "SAA716x FF FPGA version %X.%02X\n",
+		sti7109->fpga_version >> 8, sti7109->fpga_version & 0xFF);
+
+	return 0;
+}
+
+static int saa716x_ff_st7109_init(struct saa716x_dev *saa716x)
+{
+	int i;
+	int length;
+	u32 requestedBlock;
+	u32 writtenBlock;
+	u32 numBlocks;
+	u32 blockSize;
+	u32 lastBlockSize;
+	u64 startTime;
+	u64 currentTime;
+	u64 waitTime;
+	int ret;
+	const struct firmware *fw;
+	u32 loaderVersion;
+
+	/* request the st7109 loader, this will block until someone uploads it */
+	ret = request_firmware(&fw, "dvb-ttpremium-loader-01.fw", &saa716x->pdev->dev);
+	if (ret) {
+		if (ret == -ENOENT) {
+			printk(KERN_ERR "dvb-ttpremium: could not load ST7109 loader,"
+			       " file not found: dvb-ttpremium-loader-01.fw\n");
+			printk(KERN_ERR "dvb-ttpremium: usually this should be in "
+			       "/usr/lib/hotplug/firmware or /lib/firmware\n");
+		} else
+			printk(KERN_ERR "dvb-ttpremium: cannot request firmware"
+			       " (error %i)\n", ret);
+		return -EINVAL;
+	}
+	loaderVersion = (fw->data[0x1385] << 8) | fw->data[0x1384];
+	printk(KERN_INFO "SAA716x FF loader version %X.%02X\n",
+		loaderVersion >> 8, loaderVersion & 0xFF);
+
+	saa716x_phi_write(saa716x, 0, fw->data, fw->size);
+	msleep(10);
+
+	release_firmware(fw);
+
+	/* take ST out of reset */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_RESET_BACKEND, 1);
+
+	startTime = jiffies;
+	waitTime = 0;
+	do {
+		requestedBlock = SAA716x_EPRD(PHI_1, 0x3ffc);
+		if (requestedBlock == 1)
+			break;
+
+		currentTime = jiffies;
+		waitTime = currentTime - startTime;
+	} while (waitTime < (1 * HZ));
+
+	if (waitTime >= 1 * HZ) {
+		dprintk(SAA716x_ERROR, 1, "STi7109 seems to be DEAD!");
+		return -1;
+	}
+	dprintk(SAA716x_INFO, 1, "STi7109 ready after %llu ticks", waitTime);
+
+	/* request the st7109 firmware, this will block until someone uploads it */
+	ret = request_firmware(&fw, "dvb-ttpremium-st7109-01.fw", &saa716x->pdev->dev);
+	if (ret) {
+		if (ret == -ENOENT) {
+			printk(KERN_ERR "dvb-ttpremium: could not load ST7109 firmware,"
+			       " file not found: dvb-ttpremium-st7109-01.fw\n");
+			printk(KERN_ERR "dvb-ttpremium: usually this should be in "
+			       "/usr/lib/hotplug/firmware or /lib/firmware\n");
+		} else
+			printk(KERN_ERR "dvb-ttpremium: cannot request firmware"
+			       " (error %i)\n", ret);
+		return -EINVAL;
+	}
+
+	dprintk(SAA716x_INFO, 1, "SAA716x FF download ST7109 firmware");
+	writtenBlock = 0;
+	blockSize = 0x3c00;
+	length = fw->size;
+	numBlocks = length / blockSize;
+	lastBlockSize = length % blockSize;
+	for (i = 0; i < length; i += blockSize) {
+		writtenBlock++;
+		/* write one block (last may differ from blockSize) */
+		if (lastBlockSize && writtenBlock == (numBlocks + 1))
+			saa716x_phi_write(saa716x, 0, &fw->data[i], lastBlockSize);
+		else
+			saa716x_phi_write(saa716x, 0, &fw->data[i], blockSize);
+
+		SAA716x_EPWR(PHI_1, 0x3ff8, writtenBlock);
+		startTime = jiffies;
+		waitTime = 0;
+		do {
+			requestedBlock = SAA716x_EPRD(PHI_1, 0x3ffc);
+			if (requestedBlock == (writtenBlock + 1))
+				break;
+
+			currentTime = jiffies;
+			waitTime = currentTime - startTime;
+		} while (waitTime < (1 * HZ));
+
+		if (waitTime >= 1 * HZ) {
+			dprintk(SAA716x_ERROR, 1, "STi7109 seems to be DEAD!");
+			release_firmware(fw);
+			return -1;
+		}
+	}
+
+	/* disable frontend support through ST firmware */
+	SAA716x_EPWR(PHI_1, 0x3ff4, 1);
+
+	/* indicate end of transfer */
+	writtenBlock++;
+	writtenBlock |= 0x80000000;
+	SAA716x_EPWR(PHI_1, 0x3ff8, writtenBlock);
+
+	dprintk(SAA716x_INFO, 1, "SAA716x FF download ST7109 firmware done");
+
+	release_firmware(fw);
+
+	return 0;
+}
+
+static int saa716x_usercopy(struct dvb_device *dvbdev,
+			    unsigned int cmd, unsigned long arg,
+			    int (*func)(struct dvb_device *dvbdev,
+			    unsigned int cmd, void *arg))
+{
+	char    sbuf[128];
+	void    *mbuf = NULL;
+	void    *parg = NULL;
+	int     err  = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *) arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd),GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	if ((err = func(dvbdev, cmd, parg)) == -ENOIOCTLCMD)
+		err = -EINVAL;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd))
+	{
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//static int dvb_osd_ioctl(struct inode *inode, struct file *file,
+//#else
+static long dvb_osd_ioctl(struct file *file,
+//#endif
+			 unsigned int cmd, unsigned long arg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct sti7109_dev *sti7109 = dvbdev->priv;
+	int err = -EINVAL;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	if (cmd == OSD_RAW_CMD) {
+		osd_raw_cmd_t raw_cmd;
+		u8 hdr[4];
+
+		err = -EFAULT;
+		if (copy_from_user(&raw_cmd, (void __user *)arg,
+				   _IOC_SIZE(cmd)))
+			goto out;
+
+		if (copy_from_user(hdr, (void __user *)raw_cmd.cmd_data, 4))
+			goto out;
+
+		if (hdr[3] == 4)
+			err = sti7109_raw_osd_cmd(sti7109, &raw_cmd);
+		else
+			err = sti7109_raw_cmd(sti7109, &raw_cmd);
+
+		if (err)
+			goto out;
+
+		if (copy_to_user((void __user *)arg, &raw_cmd, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+	}
+	else if (cmd == OSD_RAW_DATA) {
+		osd_raw_data_t raw_data;
+
+		err = -EFAULT;
+		if (copy_from_user(&raw_data, (void __user *)arg,
+				   _IOC_SIZE(cmd)))
+			goto out;
+
+		err = sti7109_raw_data(sti7109, &raw_data);
+		if (err)
+			goto out;
+
+		if (copy_to_user((void __user *)arg, &raw_data, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+	}
+
+out:
+	return err;
+}
+
+static struct file_operations dvb_osd_fops = {
+	.owner		= THIS_MODULE,
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//	.ioctl		= dvb_osd_ioctl,
+//#else
+	.unlocked_ioctl	= dvb_osd_ioctl,
+//#endif
+	.open		= dvb_generic_open,
+	.release	= dvb_generic_release,
+};
+
+static struct dvb_device dvbdev_osd = {
+	.priv		= NULL,
+	.users		= 2,
+	.writers	= 2,
+	.fops		= &dvb_osd_fops,
+	.kernel_ioctl	= NULL,
+};
+
+static int saa716x_ff_osd_exit(struct saa716x_dev *saa716x)
+{
+	struct sti7109_dev *sti7109 = saa716x->priv;
+
+	dvb_unregister_device(sti7109->osd_dev);
+	return 0;
+}
+
+static int saa716x_ff_osd_init(struct saa716x_dev *saa716x)
+{
+	struct saa716x_adapter *saa716x_adap	= saa716x->saa716x_adap;
+	struct sti7109_dev *sti7109		= saa716x->priv;
+
+	dvb_register_device(&saa716x_adap->dvb_adapter,
+			    &sti7109->osd_dev,
+			    &dvbdev_osd,
+			    sti7109,
+			    DVB_DEVICE_OSD);
+
+	return 0;
+}
+
+static int do_dvb_audio_ioctl(struct dvb_device *dvbdev,
+			      unsigned int cmd, void *parg)
+{
+	struct sti7109_dev *sti7109	= dvbdev->priv;
+	//struct saa716x_dev *saa716x	= sti7109->dev;
+	int ret = 0;
+
+	switch (cmd) {
+	case AUDIO_GET_PTS:
+	{
+		*(u64 *)parg = sti7109->audio_pts;
+		break;
+	}
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+	return ret;
+}
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//static int dvb_audio_ioctl(struct inode *inode, struct file *file,
+//#else
+static long dvb_audio_ioctl(struct file *file,
+//#endif
+			   unsigned int cmd, unsigned long arg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	return saa716x_usercopy (dvbdev, cmd, arg, do_dvb_audio_ioctl);
+}
+
+static struct file_operations dvb_audio_fops = {
+	.owner		= THIS_MODULE,
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//	.ioctl		= dvb_audio_ioctl,
+//#else
+	.unlocked_ioctl	= dvb_audio_ioctl,
+//#endif
+	.open		= dvb_generic_open,
+	.release	= dvb_generic_release,
+};
+
+static struct dvb_device dvbdev_audio = {
+	.priv		= NULL,
+	.users		= 1,
+	.writers	= 1,
+	.fops		= &dvb_audio_fops,
+	.kernel_ioctl	= NULL,
+};
+
+static int saa716x_ff_audio_exit(struct saa716x_dev *saa716x)
+{
+	struct sti7109_dev *sti7109 = saa716x->priv;
+
+	dvb_unregister_device(sti7109->audio_dev);
+	return 0;
+}
+
+static int saa716x_ff_audio_init(struct saa716x_dev *saa716x)
+{
+	struct saa716x_adapter *saa716x_adap	= saa716x->saa716x_adap;
+	struct sti7109_dev *sti7109		= saa716x->priv;
+
+	dvb_register_device(&saa716x_adap->dvb_adapter,
+			    &sti7109->audio_dev,
+			    &dvbdev_audio,
+			    sti7109,
+			    DVB_DEVICE_AUDIO);
+
+	return 0;
+}
+
+static void fifo_worker(unsigned long data)
+{
+	struct saa716x_dev *saa716x = (struct saa716x_dev *) data;
+	struct sti7109_dev *sti7109 = saa716x->priv;
+	u32 fifoCtrl;
+	u32 fifoStat;
+	u16 fifoSize;
+	u16 fifoUsage;
+	u16 fifoFree;
+	int len;
+
+	fifoCtrl = SAA716x_EPRD(PHI_1, FPGA_ADDR_FIFO_CTRL);
+	fifoStat = SAA716x_EPRD(PHI_1, FPGA_ADDR_FIFO_STAT);
+	fifoSize = (u16) (fifoStat >> 16);
+	fifoUsage = (u16) fifoStat;
+	fifoFree = fifoSize - fifoUsage;
+	spin_lock(&sti7109->tsout.lock);
+	len = dvb_ringbuffer_avail(&sti7109->tsout);
+	if (len > fifoFree)
+		len = fifoFree;
+	if (len >= TS_SIZE)
+	{
+		while (len >= TS_SIZE)
+		{
+			dvb_ringbuffer_read(&sti7109->tsout, sti7109->tsbuf, (size_t) TS_SIZE);
+			saa716x_phi_write_fifo(saa716x, sti7109->tsbuf, TS_SIZE);
+			len -= TS_SIZE;
+		}
+		wake_up(&sti7109->tsout.queue);
+		fifoCtrl |= 0x4;
+		SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, fifoCtrl);
+	}
+	spin_unlock(&sti7109->tsout.lock);
+}
+
+#define FREE_COND_TS (dvb_ringbuffer_free(&sti7109->tsout) >= TS_SIZE)
+
+static ssize_t dvb_video_write(struct file *file, const char __user *buf,
+			       size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev	= file->private_data;
+	struct sti7109_dev *sti7109	= dvbdev->priv;
+	struct saa716x_dev *saa716x	= sti7109->dev;
+	unsigned long todo = count;
+
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+		return -EPERM;
+/*
+	if (av7110->videostate.stream_source != VIDEO_SOURCE_MEMORY)
+		return -EPERM;
+*/
+	if ((file->f_flags & O_NONBLOCK) && !FREE_COND_TS)
+		return -EWOULDBLOCK;
+
+	while (todo >= TS_SIZE) {
+		if (!FREE_COND_TS) {
+			if (file->f_flags & O_NONBLOCK)
+				break;
+			if (wait_event_interruptible(sti7109->tsout.queue, FREE_COND_TS))
+				break;
+		}
+		dvb_ringbuffer_write(&sti7109->tsout, buf, TS_SIZE);
+		todo -= TS_SIZE;
+		buf += TS_SIZE;
+	}
+
+	if (count > todo) {
+		u32 fifoCtrl;
+
+		fifoCtrl = SAA716x_EPRD(PHI_1, FPGA_ADDR_FIFO_CTRL);
+		fifoCtrl |= 0x4;
+		SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, fifoCtrl);
+	}
+
+	return count - todo;
+}
+
+static unsigned int dvb_video_poll(struct file *file, poll_table *wait)
+{
+	struct dvb_device *dvbdev	= file->private_data;
+	struct sti7109_dev *sti7109	= dvbdev->priv;
+	unsigned int mask = 0;
+
+	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
+		poll_wait(file, &sti7109->tsout.queue, wait);
+
+	if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
+		if (1/*sti7109->playing*/) {
+			if (FREE_COND_TS)
+				mask |= (POLLOUT | POLLWRNORM);
+		} else /* if not playing: may play if asked for */
+			mask |= (POLLOUT | POLLWRNORM);
+	}
+
+	return mask;
+}
+
+static int do_dvb_video_ioctl(struct dvb_device *dvbdev,
+			      unsigned int cmd, void *parg)
+{
+	struct sti7109_dev *sti7109	= dvbdev->priv;
+	struct saa716x_dev *saa716x	= sti7109->dev;
+	int ret = 0;
+
+	switch (cmd) {
+	case VIDEO_SELECT_SOURCE:
+	{
+		video_stream_source_t stream_source;
+
+		stream_source = (video_stream_source_t) parg;
+		if (stream_source == VIDEO_SOURCE_DEMUX) {
+			/* stop and reset FIFO 1 */
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, 1);
+		}
+		else {
+			dvb_ringbuffer_flush_spinlock_wakeup(&sti7109->tsout);
+			/* reset FIFO 1 */
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, 1);
+			/* start FIFO 1 */
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, 2);
+		}
+		break;
+	}
+	case VIDEO_CLEAR_BUFFER:
+	{
+		dvb_ringbuffer_flush_spinlock_wakeup(&sti7109->tsout);
+		break;
+	}
+	case VIDEO_GET_PTS:
+	{
+		*(u64 *)parg = sti7109->video_pts;
+		break;
+	}
+	case VIDEO_GET_SIZE:
+	{
+		ret = sti7109_cmd_get_video_format(sti7109, (video_size_t *) parg);
+		break;
+	}
+	default:
+		ret = -ENOIOCTLCMD;
+		break;
+	}
+	return ret;
+}
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//static int dvb_video_ioctl(struct inode *inode, struct file *file,
+//#else
+static long dvb_video_ioctl(struct file *file,
+//#endif
+			   unsigned int cmd, unsigned long arg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+
+	if (!dvbdev)
+		return -ENODEV;
+
+	return saa716x_usercopy (dvbdev, cmd, arg, do_dvb_video_ioctl);
+}
+
+static struct file_operations dvb_video_fops = {
+	.owner		= THIS_MODULE,
+	.write		= dvb_video_write,
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 36) && !defined(EXPERIMENTAL_TREE)
+//	.ioctl		= dvb_video_ioctl,
+//#else
+	.unlocked_ioctl	= dvb_video_ioctl,
+//#endif
+	.open		= dvb_generic_open,
+	.release	= dvb_generic_release,
+	.poll		= dvb_video_poll,
+};
+
+static struct dvb_device dvbdev_video = {
+	.priv		= NULL,
+	.users		= 1,
+	.writers	= 1,
+	.fops		= &dvb_video_fops,
+	.kernel_ioctl	= NULL,
+};
+
+static int saa716x_ff_video_exit(struct saa716x_dev *saa716x)
+{
+	struct sti7109_dev *sti7109 = saa716x->priv;
+
+	tasklet_kill(&sti7109->fifo_tasklet);
+	dvb_unregister_device(sti7109->video_dev);
+	return 0;
+}
+
+static int saa716x_ff_video_init(struct saa716x_dev *saa716x)
+{
+	struct saa716x_adapter *saa716x_adap	= saa716x->saa716x_adap;
+	struct sti7109_dev *sti7109		= saa716x->priv;
+
+	dvb_ringbuffer_init(&sti7109->tsout, sti7109->iobuf, TSOUT_LEN);
+	sti7109->tsbuf = (u8 *) (sti7109->iobuf + TSOUT_LEN);
+
+	dvb_register_device(&saa716x_adap->dvb_adapter,
+			    &sti7109->video_dev,
+			    &dvbdev_video,
+			    sti7109,
+			    DVB_DEVICE_VIDEO);
+
+	tasklet_init(&sti7109->fifo_tasklet, fifo_worker,
+		     (unsigned long)saa716x);
+
+	return 0;
+}
+
+static int __devinit saa716x_ff_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct saa716x_dev *saa716x;
+	struct sti7109_dev *sti7109;
+	int err = 0;
+	u32 value;
+	unsigned long timeout;
+	u32 fw_version;
+
+	saa716x = kzalloc(sizeof (struct saa716x_dev), GFP_KERNEL);
+	if (saa716x == NULL) {
+		printk(KERN_ERR "saa716x_budget_pci_probe ERROR: out of memory\n");
+		err = -ENOMEM;
+		goto fail0;
+	}
+
+	saa716x->verbose	= verbose;
+	saa716x->int_type	= int_type;
+	saa716x->pdev		= pdev;
+	saa716x->config		= (struct saa716x_config *) pci_id->driver_data;
+
+	err = saa716x_pci_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x PCI Initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_cgu_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x CGU Init failed");
+		goto fail1;
+	}
+
+	err = saa716x_core_boot(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Core Boot failed");
+		goto fail2;
+	}
+	dprintk(SAA716x_DEBUG, 1, "SAA716x Core Boot Success");
+
+	err = saa716x_msi_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x MSI Init failed");
+		goto fail2;
+	}
+
+	err = saa716x_jetpack_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Jetpack core initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_i2c_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x I2C Initialization failed");
+		goto fail3;
+	}
+
+	err = saa716x_phi_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x PHI Initialization failed");
+		goto fail3;
+	}
+
+	saa716x_gpio_init(saa716x);
+
+	/* prepare the sti7109 device struct */
+	sti7109 = kzalloc(sizeof(struct sti7109_dev), GFP_KERNEL);
+	if (!sti7109) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x: out of memory");
+		goto fail3;
+	}
+
+	sti7109->dev = saa716x;
+
+	sti7109->iobuf = vmalloc(TSOUT_LEN + TSBUF_LEN + MAX_DATA_LEN);
+	if (!sti7109->iobuf)
+		goto fail4;
+
+	sti7109_cmd_init(sti7109);
+
+	sti7109->int_count_enable = int_count_enable;
+	sti7109->total_int_count = 0;
+	memset(sti7109->fgpi_int_count, 0, sizeof(sti7109->fgpi_int_count));
+	memset(sti7109->i2c_int_count, 0, sizeof(sti7109->i2c_int_count));
+	sti7109->ext_int_total_count = 0;
+	memset(sti7109->ext_int_source_count, 0, sizeof(sti7109->ext_int_source_count));
+	sti7109->last_int_ticks = jiffies;
+
+	saa716x->priv = sti7109;
+
+	saa716x_gpio_set_output(saa716x, TT_PREMIUM_GPIO_POWER_ENABLE);
+	saa716x_gpio_set_output(saa716x, TT_PREMIUM_GPIO_RESET_BACKEND);
+	saa716x_gpio_set_output(saa716x, TT_PREMIUM_GPIO_FPGA_CS0);
+	saa716x_gpio_set_mode(saa716x, TT_PREMIUM_GPIO_FPGA_CS0, 1);
+	saa716x_gpio_set_output(saa716x, TT_PREMIUM_GPIO_FPGA_CS1);
+	saa716x_gpio_set_mode(saa716x, TT_PREMIUM_GPIO_FPGA_CS1, 1);
+	saa716x_gpio_set_output(saa716x, TT_PREMIUM_GPIO_FPGA_PROGRAMN);
+	saa716x_gpio_set_input(saa716x, TT_PREMIUM_GPIO_FPGA_DONE);
+	saa716x_gpio_set_input(saa716x, TT_PREMIUM_GPIO_FPGA_INITN);
+
+	/* hold ST in reset */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_RESET_BACKEND, 0);
+
+	/* enable board power */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_POWER_ENABLE, 1);
+	msleep(100);
+
+	err = saa716x_ff_fpga_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x FF FPGA Initialization failed");
+		goto fail5;
+	}
+
+	/* configure TS muxer */
+	if (sti7109->fpga_version < 0x110) {
+		/* select FIFO 1 for TS mux 3 */
+		SAA716x_EPWR(PHI_1, FPGA_ADDR_TSR_MUX3, 4);
+	} else {
+		/* select FIFO 1 for TS mux 3 */
+		SAA716x_EPWR(PHI_1, FPGA_ADDR_TSR_MUX3, 1);
+	}
+
+	/* enable interrupts from ST7109 -> PC */
+	SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICTRL, 0x3);
+
+	value = SAA716x_EPRD(MSI, MSI_CONFIG33);
+	value &= 0xFCFFFFFF;
+	value |= MSI_INT_POL_EDGE_FALL;
+	SAA716x_EPWR(MSI, MSI_CONFIG33, value);
+	SAA716x_EPWR(MSI, MSI_INT_ENA_SET_H, MSI_INT_EXTINT_0);
+
+	/* enable tuner reset */
+	SAA716x_EPWR(PHI_1, FPGA_ADDR_PIO_CTRL, 0);
+	msleep(50);
+	/* disable tuner reset */
+	SAA716x_EPWR(PHI_1, FPGA_ADDR_PIO_CTRL, 1);
+
+	err = saa716x_ff_st7109_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x FF STi7109 initialization failed");
+		goto fail5;
+	}
+
+	err = saa716x_dump_eeprom(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM dump failed");
+	}
+
+	err = saa716x_eeprom_data(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM dump failed");
+	}
+
+	/* enable FGPI2 and FGPI3 for TS inputs */
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x0689F04);
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x280);
+
+	err = saa716x_dvb_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x DVB initialization failed");
+		goto fail6;
+	}
+
+	/* wait a maximum of 10 seconds for the STi7109 to boot */
+	timeout = 10 * HZ;
+	timeout = wait_event_interruptible_timeout(sti7109->boot_finish_wq,
+						   sti7109->boot_finished == 1,
+						   timeout);
+
+	if (timeout == -ERESTARTSYS || sti7109->boot_finished == 0) {
+		if (timeout == -ERESTARTSYS) {
+			/* a signal arrived */
+			goto fail6;
+		}
+		dprintk(SAA716x_ERROR, 1, "timed out waiting for boot finish");
+		err = -1;
+		goto fail6;
+	}
+	dprintk(SAA716x_INFO, 1, "STi7109 finished booting");
+
+	err = saa716x_ff_video_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x FF VIDEO initialization failed");
+		goto fail7;
+	}
+
+	err = saa716x_ff_audio_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x FF AUDIO initialization failed");
+		goto fail8;
+	}
+
+	err = saa716x_ff_osd_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x FF OSD initialization failed");
+		goto fail9;
+	}
+
+	err = sti7109_cmd_get_fw_version(sti7109, &fw_version);
+	if (!err) {
+		printk(KERN_INFO "SAA716x FF firmware version %X.%X.%X\n",
+			(fw_version >> 16) & 0xFF, (fw_version >> 8) & 0xFF,
+			fw_version & 0xFF);
+	}
+
+	err = saa716x_ir_init(saa716x);
+	if (err)
+		goto fail9;
+
+	return 0;
+
+fail9:
+	saa716x_ff_osd_exit(saa716x);
+fail8:
+	saa716x_ff_audio_exit(saa716x);
+fail7:
+	saa716x_ff_video_exit(saa716x);
+fail6:
+	saa716x_dvb_exit(saa716x);
+fail5:
+	SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_H, MSI_INT_EXTINT_0);
+
+	/* disable board power */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_POWER_ENABLE, 0);
+
+	vfree(sti7109->iobuf);
+fail4:
+	kfree(sti7109);
+fail3:
+	saa716x_i2c_exit(saa716x);
+fail2:
+	saa716x_pci_exit(saa716x);
+fail1:
+	kfree(saa716x);
+fail0:
+	return err;
+}
+
+static void __devexit saa716x_ff_pci_remove(struct pci_dev *pdev)
+{
+	struct saa716x_dev *saa716x = pci_get_drvdata(pdev);
+	struct sti7109_dev *sti7109 = saa716x->priv;
+
+	saa716x_ir_exit(saa716x);
+
+	saa716x_ff_osd_exit(saa716x);
+
+	saa716x_ff_audio_exit(saa716x);
+
+	saa716x_ff_video_exit(saa716x);
+
+	saa716x_dvb_exit(saa716x);
+
+	SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_H, MSI_INT_EXTINT_0);
+
+	/* disable board power */
+	saa716x_gpio_write(saa716x, TT_PREMIUM_GPIO_POWER_ENABLE, 0);
+
+	vfree(sti7109->iobuf);
+
+	saa716x->priv = NULL;
+	kfree(sti7109);
+
+	saa716x_i2c_exit(saa716x);
+	saa716x_pci_exit(saa716x);
+	kfree(saa716x);
+}
+
+static void demux_worker(unsigned long data)
+{
+	struct saa716x_fgpi_stream_port *fgpi_entry = (struct saa716x_fgpi_stream_port *)data;
+	struct saa716x_dev *saa716x = fgpi_entry->saa716x;
+	struct dvb_demux *demux;
+	u32 fgpi_index;
+	u32 i;
+	u32 write_index;
+
+	fgpi_index = fgpi_entry->dma_channel - 6;
+	demux = NULL;
+	for (i = 0; i < saa716x->config->adapters; i++) {
+		if (saa716x->config->adap_config[i].ts_port == fgpi_index) {
+			demux = &saa716x->saa716x_adap[i].demux;
+			break;
+		}
+	}
+	if (demux == NULL) {
+		printk(KERN_ERR "%s: unexpected channel %u\n",
+		       __func__, fgpi_entry->dma_channel);
+		return;
+	}
+
+	write_index = saa716x_fgpi_get_write_index(saa716x, fgpi_index);
+	if (write_index < 0)
+		return;
+
+	dprintk(SAA716x_DEBUG, 1, "dma buffer = %d", write_index);
+
+	if (write_index == fgpi_entry->read_index) {
+		printk(KERN_DEBUG "%s: called but nothing to do\n", __func__);
+		return;
+	}
+
+	do {
+		u8 *data = (u8 *)fgpi_entry->dma_buf[fgpi_entry->read_index].mem_virt;
+
+		pci_dma_sync_sg_for_cpu(saa716x->pdev,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].sg_list,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].list_len,
+			PCI_DMA_FROMDEVICE);
+
+		dvb_dmx_swfilter(demux, data, 348 * 188);
+
+		fgpi_entry->read_index = (fgpi_entry->read_index + 1) & 7;
+	} while (write_index != fgpi_entry->read_index);
+}
+
+static irqreturn_t saa716x_ff_pci_irq(int irq, void *dev_id)
+{
+	struct saa716x_dev *saa716x	= (struct saa716x_dev *) dev_id;
+	struct sti7109_dev *sti7109;
+	u32 msiStatusL;
+	u32 msiStatusH;
+	u32 phiISR;
+
+	if (unlikely(saa716x == NULL)) {
+		printk("%s: saa716x=NULL", __func__);
+		return IRQ_NONE;
+	}
+	sti7109 = saa716x->priv;
+	if (unlikely(sti7109 == NULL)) {
+		printk("%s: sti7109=NULL", __func__);
+		return IRQ_NONE;
+	}
+	if (sti7109->int_count_enable)
+		sti7109->total_int_count++;
+#if 0
+	dprintk(SAA716x_DEBUG, 1, "VI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(VI0, INT_STATUS),
+		SAA716x_EPRD(VI1, INT_STATUS),
+		SAA716x_EPRD(VI0, INT_ENABLE),
+		SAA716x_EPRD(VI1, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(FGPI0, INT_STATUS),
+		SAA716x_EPRD(FGPI1, INT_STATUS),
+		SAA716x_EPRD(FGPI0, INT_ENABLE),
+		SAA716x_EPRD(FGPI0, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 2=<%02x> 3=<%02x>, CTL 2=<%02x> 3=<%02x>",
+		SAA716x_EPRD(FGPI2, INT_STATUS),
+		SAA716x_EPRD(FGPI3, INT_STATUS),
+		SAA716x_EPRD(FGPI2, INT_ENABLE),
+		SAA716x_EPRD(FGPI3, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "AI STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(AI0, AI_STATUS),
+		SAA716x_EPRD(AI1, AI_STATUS),
+		SAA716x_EPRD(AI0, AI_CTL),
+		SAA716x_EPRD(AI1, AI_CTL));
+
+	dprintk(SAA716x_DEBUG, 1, "MSI STAT L=<%02x> H=<%02x>, CTL L=<%02x> H=<%02x>",
+		SAA716x_EPRD(MSI, MSI_INT_STATUS_L),
+		SAA716x_EPRD(MSI, MSI_INT_STATUS_H),
+		SAA716x_EPRD(MSI, MSI_INT_ENA_L),
+		SAA716x_EPRD(MSI, MSI_INT_ENA_H));
+
+	dprintk(SAA716x_DEBUG, 1, "I2C STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(I2C_A, INT_STATUS),
+		SAA716x_EPRD(I2C_B, INT_STATUS),
+		SAA716x_EPRD(I2C_A, INT_ENABLE),
+		SAA716x_EPRD(I2C_B, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "DCS STAT=<%02x>, CTL=<%02x>",
+		SAA716x_EPRD(DCS, DCSC_INT_STATUS),
+		SAA716x_EPRD(DCS, DCSC_INT_ENABLE));
+#endif
+	msiStatusL = SAA716x_EPRD(MSI, MSI_INT_STATUS_L);
+	SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, msiStatusL);
+	msiStatusH = SAA716x_EPRD(MSI, MSI_INT_STATUS_H);
+	SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_H, msiStatusH);
+
+	if (msiStatusL) {
+		if (msiStatusL & MSI_INT_TAGACK_FGPI_2) {
+			if (sti7109->int_count_enable)
+				sti7109->fgpi_int_count[0]++;
+			tasklet_schedule(&saa716x->fgpi[2].tasklet);
+		}
+		if (msiStatusL & MSI_INT_TAGACK_FGPI_3) {
+			if (sti7109->int_count_enable)
+				sti7109->fgpi_int_count[1]++;
+			tasklet_schedule(&saa716x->fgpi[3].tasklet);
+		}
+	}
+	if (msiStatusH) {
+		//dprintk(SAA716x_INFO, 1, "msiStatusH: %08X", msiStatusH);
+	}
+
+	if (msiStatusH & MSI_INT_I2CINT_0) {
+		if (sti7109->int_count_enable)
+			sti7109->i2c_int_count[0]++;
+		saa716x->i2c[0].i2c_op = 0;
+		wake_up(&saa716x->i2c[0].i2c_wq);
+	}
+	if (msiStatusH & MSI_INT_I2CINT_1) {
+		if (sti7109->int_count_enable)
+			sti7109->i2c_int_count[1]++;
+		saa716x->i2c[1].i2c_op = 0;
+		wake_up(&saa716x->i2c[1].i2c_wq);
+	}
+
+	if (msiStatusH & MSI_INT_EXTINT_0) {
+
+		phiISR = SAA716x_EPRD(PHI_1, FPGA_ADDR_EMI_ISR);
+		//dprintk(SAA716x_INFO, 1, "interrupt status register: %08X", phiISR);
+
+		if (sti7109->int_count_enable) {
+			int i;
+			sti7109->ext_int_total_count++;
+			for (i = 0; i < 16; i++)
+				if (phiISR & (1 << i))
+					sti7109->ext_int_source_count[i]++;
+		}
+
+		if (phiISR & ISR_CMD_MASK) {
+
+			u32 value;
+			u32 length;
+			/*dprintk(SAA716x_INFO, 1, "CMD interrupt source");*/
+
+			value = SAA716x_EPRD(PHI_1, ADDR_CMD_DATA);
+			value = __cpu_to_be32(value);
+			length = (value >> 16) + 2;
+
+			/*dprintk(SAA716x_INFO, 1, "CMD length: %d", length);*/
+
+			if (length > MAX_RESULT_LEN) {
+				dprintk(SAA716x_ERROR, 1, "CMD length %d > %d", length, MAX_RESULT_LEN);
+				length = MAX_RESULT_LEN;
+			}
+
+			saa716x_phi_read(saa716x, ADDR_CMD_DATA, sti7109->result_data, length);
+			sti7109->result_len = length;
+			sti7109->result_avail = 1;
+			wake_up(&sti7109->result_avail_wq);
+
+			phiISR &= ~ISR_CMD_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_CMD_MASK);
+		}
+
+		if (phiISR & ISR_READY_MASK) {
+			/*dprintk(SAA716x_INFO, 1, "READY interrupt source");*/
+			sti7109->cmd_ready = 1;
+			wake_up(&sti7109->cmd_ready_wq);
+			phiISR &= ~ISR_READY_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_READY_MASK);
+		}
+
+		if (phiISR & ISR_OSD_CMD_MASK) {
+
+			u32 value;
+			u32 length;
+			/*dprintk(SAA716x_INFO, 1, "OSD CMD interrupt source");*/
+
+			value = SAA716x_EPRD(PHI_1, ADDR_OSD_CMD_DATA);
+			value = __cpu_to_be32(value);
+			length = (value >> 16) + 2;
+
+			/*dprintk(SAA716x_INFO, 1, "OSD CMD length: %d", length);*/
+
+			if (length > MAX_RESULT_LEN) {
+				dprintk(SAA716x_ERROR, 1, "OSD CMD length %d > %d", length, MAX_RESULT_LEN);
+				length = MAX_RESULT_LEN;
+			}
+
+			saa716x_phi_read(saa716x, ADDR_OSD_CMD_DATA, sti7109->osd_result_data, length);
+			sti7109->osd_result_len = length;
+			sti7109->osd_result_avail = 1;
+			wake_up(&sti7109->osd_result_avail_wq);
+
+			phiISR &= ~ISR_OSD_CMD_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_OSD_CMD_MASK);
+		}
+
+		if (phiISR & ISR_OSD_READY_MASK) {
+			/*dprintk(SAA716x_INFO, 1, "OSD_READY interrupt source");*/
+			sti7109->osd_cmd_ready = 1;
+			wake_up(&sti7109->osd_cmd_ready_wq);
+			phiISR &= ~ISR_OSD_READY_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_OSD_READY_MASK);
+		}
+
+		if (phiISR & ISR_BLOCK_MASK) {
+			/*dprintk(SAA716x_INFO, 1, "BLOCK interrupt source");*/
+			sti7109->block_done = 1;
+			wake_up(&sti7109->block_done_wq);
+			phiISR &= ~ISR_BLOCK_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_BLOCK_MASK);
+		}
+
+		if (phiISR & ISR_DATA_MASK) {
+			/*dprintk(SAA716x_INFO, 1, "DATA interrupt source");*/
+			sti7109->data_ready = 1;
+			wake_up(&sti7109->data_ready_wq);
+			phiISR &= ~ISR_DATA_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_DATA_MASK);
+		}
+
+		if (phiISR & ISR_BOOT_FINISH_MASK) {
+			/*dprintk(SAA716x_INFO, 1, "BOOT FINISH interrupt source");*/
+			sti7109->boot_finished = 1;
+			wake_up(&sti7109->boot_finish_wq);
+			phiISR &= ~ISR_BOOT_FINISH_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_BOOT_FINISH_MASK);
+		}
+
+		if (phiISR & ISR_AUDIO_PTS_MASK) {
+			u8 data[8];
+
+			saa716x_phi_read(saa716x, ADDR_AUDIO_PTS, data, 8);
+			sti7109->audio_pts = (((u64) data[3] & 0x01) << 32)
+					    | ((u64) data[4] << 24)
+					    | ((u64) data[5] << 16)
+					    | ((u64) data[6] << 8)
+					    | ((u64) data[7]);
+
+			phiISR &= ~ISR_AUDIO_PTS_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_AUDIO_PTS_MASK);
+
+			/*dprintk(SAA716x_INFO, 1, "AUDIO PTS: %llX", sti7109->audio_pts);*/
+		}
+
+		if (phiISR & ISR_VIDEO_PTS_MASK) {
+			u8 data[8];
+
+			saa716x_phi_read(saa716x, ADDR_VIDEO_PTS, data, 8);
+			sti7109->video_pts = (((u64) data[3] & 0x01) << 32)
+					    | ((u64) data[4] << 24)
+					    | ((u64) data[5] << 16)
+					    | ((u64) data[6] << 8)
+					    | ((u64) data[7]);
+
+			phiISR &= ~ISR_VIDEO_PTS_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_VIDEO_PTS_MASK);
+
+			/*dprintk(SAA716x_INFO, 1, "VIDEO PTS: %llX", sti7109->video_pts);*/
+		}
+
+		if (phiISR & ISR_CURRENT_STC_MASK) {
+			u8 data[8];
+
+			saa716x_phi_read(saa716x, ADDR_CURRENT_STC, data, 8);
+			sti7109->current_stc = (((u64) data[3] & 0x01) << 32)
+					      | ((u64) data[4] << 24)
+					      | ((u64) data[5] << 16)
+					      | ((u64) data[6] << 8)
+					      | ((u64) data[7]);
+
+			phiISR &= ~ISR_CURRENT_STC_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_CURRENT_STC_MASK);
+
+			/*dprintk(SAA716x_INFO, 1, "CURRENT STC: %llu", sti7109->current_stc);*/
+		}
+
+		if (phiISR & ISR_REMOTE_EVENT_MASK) {
+			u8 data[4];
+			u32 remote_event;
+
+			saa716x_phi_read(saa716x, ADDR_REMOTE_EVENT, data, 4);
+			remote_event = (data[3] << 24)
+				     | (data[2] << 16)
+				     | (data[1] << 8)
+				     | (data[0]);
+			memset(data, 0, sizeof(data));
+			saa716x_phi_write(saa716x, ADDR_REMOTE_EVENT, data, 4);
+
+			phiISR &= ~ISR_REMOTE_EVENT_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_REMOTE_EVENT_MASK);
+
+			if (remote_event == 0) {
+				dprintk(SAA716x_ERROR, 1, "REMOTE EVENT: %X ignored", remote_event);
+			} else {
+				dprintk(SAA716x_INFO, 1, "REMOTE EVENT: %X", remote_event);
+				saa716x_ir_handler(saa716x, remote_event);
+			}
+		}
+
+		if (phiISR & ISR_DVO_FORMAT_MASK) {
+			u8 data[4];
+			u32 format;
+
+			saa716x_phi_read(saa716x, ADDR_DVO_FORMAT, data, 4);
+			format = (data[0] << 24)
+			       | (data[1] << 16)
+			       | (data[2] << 8)
+			       | (data[3]);
+
+			phiISR &= ~ISR_DVO_FORMAT_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_DVO_FORMAT_MASK);
+
+			dprintk(SAA716x_INFO, 1, "DVO FORMAT CHANGE: %u", format);
+		}
+
+		if (phiISR & ISR_LOG_MESSAGE_MASK) {
+			char message[SIZE_LOG_MESSAGE_DATA];
+
+			saa716x_phi_read(saa716x, ADDR_LOG_MESSAGE, message,
+					 SIZE_LOG_MESSAGE_DATA);
+
+			phiISR &= ~ISR_LOG_MESSAGE_MASK;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, ISR_LOG_MESSAGE_MASK);
+
+			dprintk(SAA716x_INFO, 1, "LOG MESSAGE: %.*s",
+				SIZE_LOG_MESSAGE_DATA, message);
+		}
+
+		if (phiISR & ISR_FIFO1_EMPTY_MASK) {
+			u32 fifoCtrl;
+
+			/*dprintk(SAA716x_INFO, 1, "FIFO EMPTY interrupt source");*/
+			fifoCtrl = SAA716x_EPRD(PHI_1, FPGA_ADDR_FIFO_CTRL);
+			fifoCtrl &= ~0x4;
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_FIFO_CTRL, fifoCtrl);
+			tasklet_schedule(&sti7109->fifo_tasklet);
+			phiISR &= ~ISR_FIFO1_EMPTY_MASK;
+		}
+
+		if (phiISR) {
+			dprintk(SAA716x_INFO, 1, "unknown interrupt source");
+			SAA716x_EPWR(PHI_1, FPGA_ADDR_EMI_ICLR, phiISR);
+		}
+	}
+
+	if (sti7109->int_count_enable) {
+		if (jiffies - sti7109->last_int_ticks >= HZ) {
+			dprintk(SAA716x_INFO, 1, "int count: t: %d, f:%d %d, i:%d %d,"
+				"e: %d (%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d)",
+				sti7109->total_int_count,
+				sti7109->fgpi_int_count[0],
+				sti7109->fgpi_int_count[1],
+				sti7109->i2c_int_count[0],
+				sti7109->i2c_int_count[1],
+				sti7109->ext_int_total_count,
+				sti7109->ext_int_source_count[0],
+				sti7109->ext_int_source_count[1],
+				sti7109->ext_int_source_count[2],
+				sti7109->ext_int_source_count[3],
+				sti7109->ext_int_source_count[4],
+				sti7109->ext_int_source_count[5],
+				sti7109->ext_int_source_count[6],
+				sti7109->ext_int_source_count[7],
+				sti7109->ext_int_source_count[8],
+				sti7109->ext_int_source_count[9],
+				sti7109->ext_int_source_count[10],
+				sti7109->ext_int_source_count[11],
+				sti7109->ext_int_source_count[12],
+				sti7109->ext_int_source_count[13],
+				sti7109->ext_int_source_count[14],
+				sti7109->ext_int_source_count[15]);
+			sti7109->total_int_count = 0;
+			memset(sti7109->fgpi_int_count, 0, sizeof(sti7109->fgpi_int_count));
+			memset(sti7109->i2c_int_count, 0, sizeof(sti7109->i2c_int_count));
+			sti7109->ext_int_total_count = 0;
+			memset(sti7109->ext_int_source_count, 0, sizeof(sti7109->ext_int_source_count));
+			sti7109->last_int_ticks = jiffies;
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+#define SAA716x_MODEL_S2_6400_DUAL	"Technotrend S2 6400 Dual S2 Premium"
+#define SAA716x_DEV_S2_6400_DUAL	"2x DVB-S/S2 + Hardware decode"
+
+static struct stv090x_config tt6400_stv090x_config = {
+	.device			= STV0900,
+	.demod_mode		= STV090x_DUAL,
+	.clk_mode		= STV090x_CLK_EXT,
+
+	.xtal			= 13500000,
+	.address		= 0x68,
+
+	.ts1_mode		= STV090x_TSMODE_SERIAL_CONTINUOUS,
+	.ts2_mode		= STV090x_TSMODE_SERIAL_CONTINUOUS,
+	.ts1_clk		= 135000000,
+	.ts2_clk		= 135000000,
+
+	.repeater_level		= STV090x_RPTLEVEL_16,
+
+	.tuner_init		= NULL,
+	.tuner_set_mode		= NULL,
+	.tuner_set_frequency	= NULL,
+	.tuner_get_frequency	= NULL,
+	.tuner_set_bandwidth	= NULL,
+	.tuner_get_bandwidth	= NULL,
+	.tuner_set_bbgain	= NULL,
+	.tuner_get_bbgain	= NULL,
+	.tuner_set_refclk	= NULL,
+	.tuner_get_status	= NULL,
+};
+
+static struct stv6110x_config tt6400_stv6110x_config = {
+	.addr			= 0x60,
+	.refclk			= 27000000,
+	.clk_div		= 2,
+};
+
+static struct isl6423_config tt6400_isl6423_config[2] = {
+	{
+		.current_max		= SEC_CURRENT_515m,
+		.curlim			= SEC_CURRENT_LIM_ON,
+		.mod_extern		= 1,
+		.addr			= 0x09,
+	},
+	{
+		.current_max		= SEC_CURRENT_515m,
+		.curlim			= SEC_CURRENT_LIM_ON,
+		.mod_extern		= 1,
+		.addr			= 0x08,
+	}
+};
+
+
+static int saa716x_s26400_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x	= adapter->saa716x;
+	struct saa716x_i2c *i2c		= saa716x->i2c;
+	struct i2c_adapter *i2c_adapter	= &i2c[SAA716x_I2C_BUS_A].i2c_adapter;
+
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	if (count == 0 || count == 1) {
+		adapter->fe = dvb_attach(stv090x_attach,
+					 &tt6400_stv090x_config,
+					 i2c_adapter,
+					 STV090x_DEMODULATOR_0 + count);
+
+		if (adapter->fe) {
+			struct stv6110x_devctl *ctl;
+			ctl = dvb_attach(stv6110x_attach,
+					 adapter->fe,
+					 &tt6400_stv6110x_config,
+					 i2c_adapter);
+
+			tt6400_stv090x_config.tuner_init	  = ctl->tuner_init;
+			tt6400_stv090x_config.tuner_sleep	  = ctl->tuner_sleep;
+			tt6400_stv090x_config.tuner_set_mode	  = ctl->tuner_set_mode;
+			tt6400_stv090x_config.tuner_set_frequency = ctl->tuner_set_frequency;
+			tt6400_stv090x_config.tuner_get_frequency = ctl->tuner_get_frequency;
+			tt6400_stv090x_config.tuner_set_bandwidth = ctl->tuner_set_bandwidth;
+			tt6400_stv090x_config.tuner_get_bandwidth = ctl->tuner_get_bandwidth;
+			tt6400_stv090x_config.tuner_set_bbgain	  = ctl->tuner_set_bbgain;
+			tt6400_stv090x_config.tuner_get_bbgain	  = ctl->tuner_get_bbgain;
+			tt6400_stv090x_config.tuner_set_refclk	  = ctl->tuner_set_refclk;
+			tt6400_stv090x_config.tuner_get_status	  = ctl->tuner_get_status;
+
+			if (count == 1) {
+				/* call the init function once to initialize
+				   tuner's clock output divider and demod's
+				   master clock */
+				/* The second tuner drives the STV0900 so
+				   call it only for adapter 1 */
+				if (adapter->fe->ops.init)
+					adapter->fe->ops.init(adapter->fe);
+			}
+
+			dvb_attach(isl6423_attach,
+				   adapter->fe,
+				   i2c_adapter,
+				   &tt6400_isl6423_config[count]);
+
+		}
+	}
+	return 0;
+}
+
+static struct saa716x_config saa716x_s26400_config = {
+	.model_name		= SAA716x_MODEL_S2_6400_DUAL,
+	.dev_type		= SAA716x_DEV_S2_6400_DUAL,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 2,
+	.frontend_attach	= saa716x_s26400_frontend_attach,
+	.irq_handler		= saa716x_ff_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+	.i2c_mode		= SAA716x_I2C_MODE_IRQ_BUFFERED,
+
+	.adap_config		= {
+		{
+			/* Adapter 0 */
+			.ts_port = 2,
+			.worker = demux_worker
+		},{
+			/* Adapter 1 */
+			.ts_port = 3,
+			.worker = demux_worker
+		}
+	}
+};
+
+
+static struct pci_device_id saa716x_ff_pci_table[] = {
+
+	MAKE_ENTRY(TECHNOTREND, S2_6400_DUAL_S2_PREMIUM_DEVEL, SAA7160, &saa716x_s26400_config),  /* S2 6400 Dual development version */
+	MAKE_ENTRY(TECHNOTREND, S2_6400_DUAL_S2_PREMIUM_PROD, SAA7160, &saa716x_s26400_config), /* S2 6400 Dual production version */
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, saa716x_ff_pci_table);
+
+static struct pci_driver saa716x_ff_pci_driver = {
+	.name			= DRIVER_NAME,
+	.id_table		= saa716x_ff_pci_table,
+	.probe			= saa716x_ff_pci_probe,
+	.remove			= saa716x_ff_pci_remove,
+};
+
+static int __devinit saa716x_ff_init(void)
+{
+	return pci_register_driver(&saa716x_ff_pci_driver);
+}
+
+static void __devexit saa716x_ff_exit(void)
+{
+	return pci_unregister_driver(&saa716x_ff_pci_driver);
+}
+
+module_init(saa716x_ff_init);
+module_exit(saa716x_ff_exit);
+
+MODULE_DESCRIPTION("SAA716x FF driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,389 @@
+#include <linux/kernel.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_fgpi_reg.h"
+#include "saa716x_dma_reg.h"
+#include "saa716x_msi_reg.h"
+
+#include "saa716x_dma.h"
+#include "saa716x_fgpi.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+static const u32 mmu_pta_base[] = {
+	MMU_PTA_BASE0,
+	MMU_PTA_BASE1,
+	MMU_PTA_BASE2,
+	MMU_PTA_BASE3,
+	MMU_PTA_BASE4,
+	MMU_PTA_BASE5,
+	MMU_PTA_BASE6,
+	MMU_PTA_BASE7,
+	MMU_PTA_BASE8,
+	MMU_PTA_BASE9,
+	MMU_PTA_BASE10,
+	MMU_PTA_BASE11,
+	MMU_PTA_BASE12,
+	MMU_PTA_BASE13,
+	MMU_PTA_BASE14,
+	MMU_PTA_BASE15,
+};
+
+static const u32 mmu_dma_cfg[] = {
+	MMU_DMA_CONFIG0,
+	MMU_DMA_CONFIG1,
+	MMU_DMA_CONFIG2,
+	MMU_DMA_CONFIG3,
+	MMU_DMA_CONFIG4,
+	MMU_DMA_CONFIG5,
+	MMU_DMA_CONFIG6,
+	MMU_DMA_CONFIG7,
+	MMU_DMA_CONFIG8,
+	MMU_DMA_CONFIG9,
+	MMU_DMA_CONFIG10,
+	MMU_DMA_CONFIG11,
+	MMU_DMA_CONFIG12,
+	MMU_DMA_CONFIG13,
+	MMU_DMA_CONFIG14,
+	MMU_DMA_CONFIG15,
+};
+
+static const u32 fgpi_ch[] = {
+	FGPI0,
+	FGPI1,
+	FGPI2,
+	FGPI3
+};
+
+static const u32 bamdma_bufmode[] = {
+	BAM_FGPI0_DMA_BUF_MODE,
+	BAM_FGPI1_DMA_BUF_MODE,
+	BAM_FGPI2_DMA_BUF_MODE,
+	BAM_FGPI3_DMA_BUF_MODE
+};
+
+static const u32 msi_int_tagack[] = {
+	MSI_INT_TAGACK_FGPI_0,
+	MSI_INT_TAGACK_FGPI_1,
+	MSI_INT_TAGACK_FGPI_2,
+	MSI_INT_TAGACK_FGPI_3
+};
+
+static const u32 msi_int_ovrflw[] = {
+	MSI_INT_OVRFLW_FGPI_0,
+	MSI_INT_OVRFLW_FGPI_1,
+	MSI_INT_OVRFLW_FGPI_2,
+	MSI_INT_OVRFLW_FGPI_3
+};
+
+static const u32 msi_int_avint[] = {
+	MSI_INT_AVINT_FGPI_0,
+	MSI_INT_AVINT_FGPI_1,
+	MSI_INT_AVINT_FGPI_2,
+	MSI_INT_AVINT_FGPI_3
+};
+
+void saa716x_fgpiint_disable(struct saa716x_dmabuf *dmabuf, int channel)
+{
+	struct saa716x_dev *saa716x = dmabuf->saa716x;
+
+	u32 fgpi_port;
+
+	fgpi_port = fgpi_ch[channel];
+
+	SAA716x_EPWR(fgpi_port, INT_ENABLE, 0); /* disable FGPI IRQ */
+	SAA716x_EPWR(fgpi_port, INT_CLR_STATUS, 0x7f); /* clear status */
+}
+EXPORT_SYMBOL_GPL(saa716x_fgpiint_disable);
+
+int saa716x_fgpi_get_write_index(struct saa716x_dev *saa716x, u32 fgpi_index)
+{
+	u32 fgpi_base;
+	u32 buf_mode_reg;
+	u32 buf_mode;
+
+ 	switch (fgpi_index) {
+	case 0: /* FGPI_0 */
+		fgpi_base = FGPI0;
+		buf_mode_reg = BAM_FGPI0_DMA_BUF_MODE;
+		break;
+
+	case 1: /* FGPI_1 */
+		fgpi_base = FGPI1;
+		buf_mode_reg = BAM_FGPI1_DMA_BUF_MODE;
+		break;
+
+	case 2: /* FGPI_2 */
+		fgpi_base = FGPI2;
+		buf_mode_reg = BAM_FGPI2_DMA_BUF_MODE;
+		break;
+
+	case 3: /* FGPI_3 */
+		fgpi_base = FGPI3;
+		buf_mode_reg = BAM_FGPI3_DMA_BUF_MODE;
+		break;
+
+	default:
+		printk(KERN_ERR "%s: unexpected fgpi %u\n",
+		       __func__, fgpi_index);
+		return -1;
+	}
+
+	buf_mode = SAA716x_EPRD(BAM, buf_mode_reg);
+	if (saa716x->revision < 2) {
+		/* workaround for revision 1: restore buffer numbers on BAM */
+		SAA716x_EPWR(fgpi_base, INT_CLR_STATUS, 0x7F);
+		SAA716x_EPWR(BAM, buf_mode_reg, buf_mode | 7);
+	}
+	return (buf_mode >> 3) & 0x7;
+}
+EXPORT_SYMBOL_GPL(saa716x_fgpi_get_write_index);
+
+static u32 saa716x_init_ptables(struct saa716x_dmabuf *dmabuf, int channel)
+{
+	struct saa716x_dev *saa716x = dmabuf->saa716x;
+
+	u32 config, i;
+
+	for (i = 0; i < FGPI_BUFFERS; i++)
+		BUG_ON((dmabuf[i].mem_ptab_phys == 0));
+
+	config = mmu_dma_cfg[channel]; /* DMACONFIGx */
+
+	SAA716x_EPWR(MMU, config, (FGPI_BUFFERS - 1));
+	SAA716x_EPWR(MMU, MMU_PTA0_LSB(channel), PTA_LSB(dmabuf[0].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA0_MSB(channel), PTA_MSB(dmabuf[0].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA1_LSB(channel), PTA_LSB(dmabuf[1].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA1_MSB(channel), PTA_MSB(dmabuf[1].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA2_LSB(channel), PTA_LSB(dmabuf[2].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA2_MSB(channel), PTA_MSB(dmabuf[2].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA3_LSB(channel), PTA_LSB(dmabuf[3].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA3_MSB(channel), PTA_MSB(dmabuf[3].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA4_LSB(channel), PTA_LSB(dmabuf[4].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA4_MSB(channel), PTA_MSB(dmabuf[4].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA5_LSB(channel), PTA_LSB(dmabuf[5].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA5_MSB(channel), PTA_MSB(dmabuf[5].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA6_LSB(channel), PTA_LSB(dmabuf[6].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA6_MSB(channel), PTA_MSB(dmabuf[6].mem_ptab_phys)); /* High */
+	SAA716x_EPWR(MMU, MMU_PTA7_LSB(channel), PTA_LSB(dmabuf[7].mem_ptab_phys)); /* Low */
+	SAA716x_EPWR(MMU, MMU_PTA7_MSB(channel), PTA_MSB(dmabuf[7].mem_ptab_phys)); /* High */
+
+	return 0;
+}
+
+int saa716x_fgpi_setparams(struct saa716x_dmabuf *dmabuf,
+			   struct fgpi_stream_params *stream_params,
+			   int port)
+{
+	struct saa716x_dev *saa716x = dmabuf->saa716x;
+
+	u32 fgpi_port, buf_mode, val, mid;
+	u32 D1_XY_END, offst_1, offst_2;
+	int i = 0;
+
+	fgpi_port = fgpi_ch[port];
+	buf_mode = bamdma_bufmode[port];
+
+	/* Reset FGPI block */
+	SAA716x_EPWR(fgpi_port, FGPI_SOFT_RESET, FGPI_SOFTWARE_RESET);
+
+	/* Reset DMA channel */
+	SAA716x_EPWR(BAM, buf_mode, 0x00000040);
+	saa716x_init_ptables(dmabuf, saa716x->fgpi[port].dma_channel);
+
+
+	/* monitor BAM reset */
+	val = SAA716x_EPRD(BAM, buf_mode);
+	while (val && (i < 100)) {
+		msleep(30);
+		val = SAA716x_EPRD(BAM, buf_mode);
+		i++;
+	}
+
+	if (val) {
+		dprintk(SAA716x_ERROR, 1, "Error: BAM FGPI Reset failed!");
+		return -EIO;
+	}
+
+	/* set buffer count */
+	SAA716x_EPWR(BAM, buf_mode, FGPI_BUFFERS - 1);
+
+	/* initialize all available address offsets */
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_0(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_1(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_2(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_3(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_4(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_5(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_6(port), 0x0);
+	SAA716x_EPWR(BAM, BAM_FGPI_ADDR_OFFST_7(port), 0x0);
+
+	/* get module ID */
+	mid = SAA716x_EPRD(fgpi_port, FGPI_MODULE_ID);
+	if (mid != 0x14b0100)
+		dprintk(SAA716x_ERROR, 1, "FGPI Id<%04x> is not supported", mid);
+
+	/* Initialize FGPI block */
+	SAA716x_EPWR(fgpi_port, FGPI_REC_SIZE, stream_params->samples * (stream_params->bits / 8));
+	SAA716x_EPWR(fgpi_port, FGPI_STRIDE, stream_params->pitch);
+
+	offst_1 = 0;
+	offst_2 = 0;
+	switch (stream_params->stream_type) {
+	case FGPI_TRANSPORT_STREAM:
+		SAA716x_EPWR(fgpi_port, FGPI_CONTROL, 0x00000080);
+		SAA716x_EPWR(fgpi_port, FGPI_SIZE, stream_params->lines);
+		break;
+
+	case FGPI_PROGRAM_STREAM:
+		SAA716x_EPWR(fgpi_port, FGPI_CONTROL, 0x00000088);
+		SAA716x_EPWR(fgpi_port, FGPI_SIZE, stream_params->lines);
+		break;
+
+	case FGPI_VIDEO_STREAM:
+		SAA716x_EPWR(fgpi_port, FGPI_CONTROL, 0x00000088);
+		SAA716x_EPWR(fgpi_port, FGPI_D1_XY_START, 0x00000002);
+
+		if ((stream_params->stream_flags & FGPI_INTERLACED) &&
+		    (stream_params->stream_flags & FGPI_ODD_FIELD) &&
+		    (stream_params->stream_flags & FGPI_EVEN_FIELD)) {
+
+			SAA716x_EPWR(fgpi_port, FGPI_SIZE, stream_params->lines / 2);
+			SAA716x_EPWR(fgpi_port, FGPI_STRIDE, 768 * 4); /* interlaced stride of 2 lines */
+
+			D1_XY_END  = (stream_params->samples << 16);
+			D1_XY_END |= (stream_params->lines / 2) + 2;
+
+			if (stream_params->stream_flags & FGPI_PAL)
+				offst_1 = 768 * 2;
+			else
+				offst_2 = 768 * 2;
+
+		} else {
+			SAA716x_EPWR(fgpi_port, FGPI_SIZE, stream_params->lines);
+			SAA716x_EPWR(fgpi_port, FGPI_STRIDE, 768 * 2); /* stride of 1 line */
+
+			D1_XY_END  = stream_params->samples << 16;
+			D1_XY_END |= stream_params->lines + 2;
+		}
+
+		SAA716x_EPWR(fgpi_port, FGPI_D1_XY_END, D1_XY_END);
+		break;
+
+	default:
+		SAA716x_EPWR(fgpi_port, FGPI_CONTROL, 0x00000080);
+		break;
+	}
+
+	SAA716x_EPWR(fgpi_port, FGPI_BASE_1, ((saa716x->fgpi[port].dma_channel) << 21) + offst_1);
+	SAA716x_EPWR(fgpi_port, FGPI_BASE_2, ((saa716x->fgpi[port].dma_channel) << 21) + offst_2);
+
+	return 0;
+}
+
+int saa716x_fgpi_start(struct saa716x_dev *saa716x, int port,
+		       struct fgpi_stream_params *stream_params)
+{
+	u32 fgpi_port;
+	u32 config;
+	u32 val;
+	u32 i;
+
+	fgpi_port = fgpi_ch[port];
+
+	SAA716x_EPWR(fgpi_port, FGPI_INTERFACE, 0);
+	msleep(10);
+
+	if (saa716x_fgpi_setparams(saa716x->fgpi[port].dma_buf, stream_params, port) != 0) {
+		return -EIO;
+	}
+
+	config = mmu_dma_cfg[saa716x->fgpi[port].dma_channel]; /* DMACONFIGx */
+
+	val = SAA716x_EPRD(MMU, config);
+	SAA716x_EPWR(MMU, config, val & ~0x40);
+	SAA716x_EPWR(MMU, config, val | 0x40);
+
+	SAA716x_EPWR(fgpi_port, INT_ENABLE, 0x7F);
+
+	val = SAA716x_EPRD(MMU, config);
+	i = 0;
+	while (i < 500) {
+		if (val & 0x80)
+			break;
+		msleep(10);
+		val = SAA716x_EPRD(MMU, config);
+		i++;
+	}
+
+	if (!(val & 0x80)) {
+		dprintk(SAA716x_ERROR, 1, "Error: PTE pre-fetch failed!");
+		return -EIO;
+	}
+
+	val = SAA716x_EPRD(fgpi_port, FGPI_CONTROL);
+	val |= 0x3000;
+
+	saa716x_set_clk_external(saa716x, saa716x->fgpi[port].dma_channel);
+
+	SAA716x_EPWR(fgpi_port, FGPI_CONTROL, val);
+
+	SAA716x_EPWR(MSI, MSI_INT_ENA_SET_L, msi_int_tagack[port]);
+
+	return 0;
+}
+
+int saa716x_fgpi_stop(struct saa716x_dev *saa716x, int port)
+{
+	u32 fgpi_port;
+	u32 val;
+
+	fgpi_port = fgpi_ch[port];
+
+	SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_L, msi_int_tagack[port]);
+
+	val = SAA716x_EPRD(fgpi_port, FGPI_CONTROL);
+	val &= ~0x3000;
+	SAA716x_EPWR(fgpi_port, FGPI_CONTROL, val);
+
+	saa716x_set_clk_internal(saa716x, saa716x->fgpi[port].dma_channel);
+
+	return 0;
+}
+
+int saa716x_fgpi_init(struct saa716x_dev *saa716x, int port,
+		      void (*worker)(unsigned long))
+{
+	int i;
+	int ret;
+
+	saa716x->fgpi[port].dma_channel = port + 6;
+	for (i = 0; i < FGPI_BUFFERS; i++)
+	{
+		/* TODO: what is a good size for TS DMA buffer? */
+		ret = saa716x_dmabuf_alloc(saa716x, &saa716x->fgpi[port].dma_buf[i], 16 * SAA716x_PAGE_SIZE);
+		if (ret < 0) {
+			return ret;
+		}
+	}
+	saa716x->fgpi[port].saa716x = saa716x;
+	tasklet_init(&saa716x->fgpi[port].tasklet, worker,
+		     (unsigned long)&saa716x->fgpi[port]);
+	saa716x->fgpi[port].read_index = 0;
+
+	return 0;
+}
+
+int saa716x_fgpi_exit(struct saa716x_dev *saa716x, int port)
+{
+	int i;
+
+	tasklet_kill(&saa716x->fgpi[port].tasklet);
+	for (i = 0; i < FGPI_BUFFERS; i++)
+	{
+		saa716x_dmabuf_free(saa716x, &saa716x->fgpi[port].dma_buf[i]);
+	}
+
+	return 0;
+}
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi.h	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,112 @@
+#ifndef __SAA716x_FGPI_H
+#define __SAA716x_FGPI_H
+
+#include <linux/interrupt.h>
+
+#define FGPI_BUFFERS		8
+#define PTA_LSB(__mem)		((u32 ) (__mem))
+#define PTA_MSB(__mem)		((u32 ) ((u64)(__mem) >> 32))
+
+#define BAM_DMA_BUF_MODE_BASE		0x0d8
+#define BAM_DMA_BUF_MODE_OFFSET		0x24
+
+#define BAM_DMA_BUF_MODE(__ch)		(BAM_DMA_BUF_MODE_BASE + (BAM_DMA_BUF_MODE_OFFSET * __ch))
+
+#define BAM_FGPI_ADDR_OFFST_BASE	0x0dc
+#define BAM_FGPI_ADDR_OFFST_OFFSET	0x24
+
+#define BAM_FGPI_ADDR_OFFSET(__ch)	(BAM_FGPI_ADDR_OFFST_BASE + (BAM_FGPI_ADDR_OFFST_OFFSET * __ch))
+
+#define BAM_FGPI_ADDR_OFFST_0(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x00
+#define BAM_FGPI_ADDR_OFFST_1(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x04
+#define BAM_FGPI_ADDR_OFFST_2(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x08
+#define BAM_FGPI_ADDR_OFFST_3(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x0c
+#define BAM_FGPI_ADDR_OFFST_4(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x10
+#define BAM_FGPI_ADDR_OFFST_5(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x14
+#define BAM_FGPI_ADDR_OFFST_6(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x18
+#define BAM_FGPI_ADDR_OFFST_7(__ch)	BAM_FGPI_ADDR_OFFSET(__ch) + 0x1c
+
+struct saa716x_dmabuf;
+
+/*
+ * Port supported streams
+ *
+ * FGPI_AUDIO_STREAM
+ * FGPI_VIDEO_STREAM
+ * FGPI_VBI_STREAM
+ * FGPI_TRANSPORT_STREAM
+ * FGPI_PROGRAM_STREAM
+ */
+enum fgpi_stream_type {
+	FGPI_AUDIO_STREAM	= 0x01,
+	FGPI_VIDEO_STREAM	= 0x02,
+	FGPI_VBI_STREAM		= 0x04,
+	FGPI_TRANSPORT_STREAM	= 0x08,
+	FGPI_PROGRAM_STREAM	= 0x10
+};
+
+/*
+ * Stream port flags
+ *
+ * FGPI_ODD_FIELD
+ * FGPI_EVEN_FIELD
+ * FGPI_HD_0
+ * FGPI_HD_1
+ * FGPI_PAL
+ * FGPI_NTSC
+ */
+enum fgpi_stream_flags {
+	FGPI_ODD_FIELD		= 0x0001,
+	FGPI_EVEN_FIELD		= 0x0002,
+	FGPI_INTERLACED		= 0x0004,
+	FGPI_HD0		= 0x0010,
+	FGPI_HD1		= 0x0020,
+	FGPI_PAL		= 0x0040,
+	FGPI_NTSC		= 0x0080,
+	FGPI_NO_SCALER		= 0x0100,
+};
+
+/*
+ * Stream port parameters
+ * bits: Bits per sample
+ * samples: samples perline
+ * lines: number of lines
+ * pitch: stream pitch in bytes
+ * offset: offset to first valid line
+ */
+struct fgpi_stream_params {
+	u32			bits;
+	u32			samples;
+	u32			lines;
+
+	s32			pitch;
+
+	u32			offset;
+	u32			page_tables;
+
+	enum fgpi_stream_flags	stream_flags;
+	enum fgpi_stream_type	stream_type;
+};
+
+struct saa716x_dmabuf;
+
+struct saa716x_fgpi_stream_port {
+	u8			dma_channel;
+	struct saa716x_dmabuf	dma_buf[FGPI_BUFFERS];
+	struct saa716x_dev	*saa716x;
+	struct tasklet_struct	tasklet;
+	u8			read_index;
+};
+
+extern void saa716x_fgpiint_disable(struct saa716x_dmabuf *dmabuf, int channel);
+extern int saa716x_fgpi_get_write_index(struct saa716x_dev *saa716x,
+					u32 fgpi_index);
+extern int saa716x_fgpi_start(struct saa716x_dev *saa716x, int port,
+			      struct fgpi_stream_params *stream_params);
+extern int saa716x_fgpi_stop(struct saa716x_dev *saa716x, int port);
+
+extern int saa716x_fgpi_init(struct saa716x_dev *saa716x, int port,
+			     void (*worker)(unsigned long));
+extern int saa716x_fgpi_exit(struct saa716x_dev *saa716x, int port);
+
+#endif /* __SAA716x_FGPI_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_fgpi_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_fgpi_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,74 @@
+#ifndef __SAA716x_FGPI_REG_H
+#define __SAA716x_FGPI_REG_H
+
+/* -------------- FGPI Registers -------------- */
+
+#define FGPI_CONTROL			0x000
+#define FGPI_CAPTURE_ENABLE_2		(0x00000001 << 13)
+#define FGPI_CAPTURE_ENABLE_1		(0x00000001 << 12)
+#define FGPI_MODE			(0x00000001 << 11)
+#define FGPI_SAMPLE_SIZE		(0x00000003 <<  8)
+#define FGPI_BUF_SYNC_MSG_STOP		(0x00000003 <<  5)
+#define FGPI_REC_START_MSG_START	(0x00000003 <<  2)
+#define FGPI_TSTAMP_SELECT		(0x00000001 <<  1)
+#define FGPI_VAR_LENGTH			(0x00000001 <<  0)
+
+#define FGPI_BASE_1			0x004
+#define FGPI_BASE_2			0x008
+#define FGPI_SIZE			0x00c
+#define FGPI_REC_SIZE			0x010
+#define FGPI_STRIDE			0x014
+#define FGPI_NUM_RECORD_1		0x018
+#define FGPI_NUM_RECORD_2		0x01c
+#define FGPI_THRESHOLD_1		0x020
+#define FGPI_THRESHOLD_2		0x024
+#define FGPI_D1_XY_START		0x028
+#define FGPI_D1_XY_END			0x02c
+
+#define INT_STATUS			0xfe0
+#define FGPI_BUF1_ACTIVE		(0x00000001 <<  7)
+#define FGPI_OVERFLOW			(0x00000001 <<  6)
+#define FGPI_MBE			(0x00000001 <<  5)
+#define FGPI_UNDERRUN			(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED		(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED		(0x00000001 <<  2)
+#define FGPI_BUF2_FULL			(0x00000001 <<  1)
+#define FGPI_BUF1_FULL			(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define FGPI_OVERFLOW_ENA		(0x00000001 <<  6)
+#define FGPI_MBE_ENA			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_ENA		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_ENA	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_ENA	(0x00000001 <<  2)
+#define FGPI_BUF2_FULL_ENA		(0x00000001 <<  1)
+#define FGPI_BUF1_FULL_ENA		(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define FGPI_OVERFLOW_ACK		(0x00000001 <<  6)
+#define FGPI_MBE_ACK			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_ACK		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_ACK	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_ACK	(0x00000001 <<  2)
+#define FGPI_BUF2_DONE_ACK		(0x00000001 <<  1)
+#define FGPI_BUF1_DONE_ACK		(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define FGPI_OVERFLOW_SET		(0x00000001 <<  6)
+#define FGPI_MBE_SET			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_SET		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_SET	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_SET	(0x00000001 <<  2)
+#define FGPI_BUF2_DONE_SET		(0x00000001 <<  1)
+#define FGPI_BUF1_DONE_SET		(0x00000001 <<  0)
+
+#define FGPI_SOFT_RESET			0xff0
+#define FGPI_SOFTWARE_RESET		(0x00000001 <<  0)
+
+#define FGPI_INTERFACE			0xff4
+#define FGPI_DISABLE_BUS_IF		(0x00000001 <<  0)
+
+#define FGPI_MOD_ID_EXT			0xff8
+#define FGPI_MODULE_ID			0xffc
+
+#endif /* __SAA716x_FGPI_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,140 @@
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_gpio_reg.h"
+
+#include "saa716x_gpio.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+void saa716x_gpio_init(struct saa716x_dev *saa716x)
+{
+	spin_lock_init(&saa716x->gpio_lock);
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_init);
+
+int saa716x_get_gpio_mode(struct saa716x_dev *saa716x, u32 *config)
+{
+	*config = SAA716x_EPRD(GPIO, GPIO_WR_MODE);
+
+	return 0;
+}
+
+int saa716x_set_gpio_mode(struct saa716x_dev *saa716x, u32 mask, u32 config)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&saa716x->gpio_lock, flags);
+	reg = SAA716x_EPRD(GPIO, GPIO_WR_MODE);
+	reg &= ~mask;
+	reg |= (config & mask);
+	SAA716x_EPWR(GPIO, GPIO_WR_MODE, reg);
+	spin_unlock_irqrestore(&saa716x->gpio_lock, flags);
+
+	return 0;
+}
+
+u32 saa716x_gpio_rd(struct saa716x_dev *saa716x)
+{
+	return SAA716x_EPRD(GPIO, GPIO_RD);
+}
+
+void saa716x_gpio_wr(struct saa716x_dev *saa716x, u32 data)
+{
+	SAA716x_EPWR(GPIO, GPIO_WR, data);
+}
+
+void saa716x_gpio_ctl(struct saa716x_dev *saa716x, u32 mask, u32 bits)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&saa716x->gpio_lock, flags);
+
+	reg  = SAA716x_EPRD(GPIO, GPIO_OEN);
+	reg &= mask;
+	reg |= bits;
+	SAA716x_EPWR(GPIO, GPIO_OEN, reg);
+
+	spin_unlock_irqrestore(&saa716x->gpio_lock, flags);
+}
+
+void saa716x_gpio_bits(struct saa716x_dev *saa716x, u32 bits)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&saa716x->gpio_lock, flags);
+
+	reg  = SAA716x_EPRD(GPIO, GPIO_WR);
+	reg &= ~bits;
+	/* TODO ! add maskable config bits in here */
+	/* reg |= (config->mask & bits) */
+	reg |= bits;
+	SAA716x_EPWR(GPIO, GPIO_WR, reg);
+
+	spin_unlock_irqrestore(&saa716x->gpio_lock, flags);
+}
+
+void saa716x_gpio_set_output(struct saa716x_dev *saa716x, int gpio)
+{
+	uint32_t value;
+
+	value = SAA716x_EPRD(GPIO, GPIO_OEN);
+	value &= ~(1 << gpio);
+	SAA716x_EPWR(GPIO, GPIO_OEN, value);
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_set_output);
+
+void saa716x_gpio_set_input(struct saa716x_dev *saa716x, int gpio)
+{
+	uint32_t value;
+
+	value = SAA716x_EPRD(GPIO, GPIO_OEN);
+	value |= 1 << gpio;
+	SAA716x_EPWR(GPIO, GPIO_OEN, value);
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_set_input);
+
+void saa716x_gpio_set_mode(struct saa716x_dev *saa716x, int gpio, int mode)
+{
+	uint32_t value;
+
+	value = SAA716x_EPRD(GPIO, GPIO_WR_MODE);
+	if (mode)
+		value |= 1 << gpio;
+	else
+		value &= ~(1 << gpio);
+	SAA716x_EPWR(GPIO, GPIO_WR_MODE, value);
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_set_mode);
+
+void saa716x_gpio_write(struct saa716x_dev *saa716x, int gpio, int set)
+{
+	uint32_t value;
+	unsigned long flags;
+
+	spin_lock_irqsave(&saa716x->gpio_lock, flags);
+	value = SAA716x_EPRD(GPIO, GPIO_WR);
+	if (set)
+		value |= 1 << gpio;
+	else
+		value &= ~(1 << gpio);
+	SAA716x_EPWR(GPIO, GPIO_WR, value);
+	spin_unlock_irqrestore(&saa716x->gpio_lock, flags);
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_write);
+
+int saa716x_gpio_read(struct saa716x_dev *saa716x, int gpio)
+{
+	uint32_t value;
+
+	value = SAA716x_EPRD(GPIO, GPIO_RD);
+	if (value & (1 << gpio))
+		return 1;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_gpio_read);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,26 @@
+#ifndef __SAA716x_GPIO_H
+#define __SAA716x_GPIO_H
+
+#define BOOT_MODE	GPIO_31 | GPIO_30
+#define AV_UNIT_B	GPIO_25
+#define AV_UNIT_A	GPIO_24
+#define AV_INTR_B	GPIO_01
+#define AV_INTR_A	GPIO_00
+
+struct saa716x_dev;
+
+extern void saa716x_gpio_init(struct saa716x_dev *saa716x);
+
+extern u32 saa716x_gpio_rd(struct saa716x_dev *saa716x);
+extern void saa716x_gpio_wr(struct saa716x_dev *saa716x, u32 data);
+extern void saa716x_gpio_ctl(struct saa716x_dev *saa716x, u32 mask, u32 bits);
+
+extern void saa716x_gpio_bits(struct saa716x_dev *saa716x, u32 bits);
+
+extern void saa716x_gpio_set_output(struct saa716x_dev *saa716x, int gpio);
+extern void saa716x_gpio_set_input(struct saa716x_dev *saa716x, int gpio);
+extern void saa716x_gpio_set_mode(struct saa716x_dev *saa716x, int gpio, int mode);
+extern void saa716x_gpio_write(struct saa716x_dev *saa716x, int gpio, int set);
+extern int saa716x_gpio_read(struct saa716x_dev *saa716x, int gpio);
+
+#endif /* __SAA716x_GPIO_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_gpio_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_gpio_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,47 @@
+#ifndef __SAA716x_GPIO_REG_H
+#define __SAA716x_GPIO_REG_H
+
+/* -------------- GPIO Registers -------------- */
+
+#define GPIO_RD				0x000
+#define GPIO_WR				0x004
+#define GPIO_WR_MODE			0x008
+#define GPIO_OEN			0x00c
+
+#define GPIO_SW_RST			0xff0
+#define GPIO_SW_RESET			(0x00000001 <<  0)
+
+#define GPIO_31				(1 << 31)
+#define GPIO_30				(1 << 30)
+#define GPIO_29				(1 << 29)
+#define GPIO_28				(1 << 28)
+#define GPIO_27				(1 << 27)
+#define GPIO_26				(1 << 26)
+#define GPIO_25				(1 << 25)
+#define GPIO_24				(1 << 24)
+#define GPIO_23				(1 << 23)
+#define GPIO_22				(1 << 22)
+#define GPIO_21				(1 << 21)
+#define GPIO_20				(1 << 20)
+#define GPIO_19				(1 << 19)
+#define GPIO_18				(1 << 18)
+#define GPIO_17				(1 << 17)
+#define GPIO_16				(1 << 16)
+#define GPIO_15				(1 << 15)
+#define GPIO_14				(1 << 14)
+#define GPIO_13				(1 << 13)
+#define GPIO_12				(1 << 12)
+#define GPIO_11				(1 << 11)
+#define GPIO_10				(1 << 10)
+#define GPIO_09				(1 <<  9)
+#define GPIO_08				(1 <<  8)
+#define GPIO_07				(1 <<  7)
+#define GPIO_06				(1 <<  6)
+#define GPIO_05				(1 <<  5)
+#define GPIO_04				(1 <<  4)
+#define GPIO_03				(1 <<  3)
+#define GPIO_02				(1 <<  2)
+#define GPIO_01				(1 <<  1)
+#define GPIO_00				(1 <<  0)
+
+#endif /* __SAA716x_GPIO_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_greg.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_greg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,42 @@
+#include <linux/kernel.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_greg_reg.h"
+#include "saa716x_greg.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+static u32 g_save[12];
+
+void saa716x_greg_save(struct saa716x_dev *saa716x)
+{
+	g_save[0] = SAA716x_EPRD(GREG, GREG_SUBSYS_CONFIG);
+	g_save[1] = SAA716x_EPRD(GREG, GREG_MSI_BAR_PMCSR);
+	g_save[2] = SAA716x_EPRD(GREG, GREG_PMCSR_DATA_1);
+	g_save[3] = SAA716x_EPRD(GREG, GREG_PMCSR_DATA_2);
+	g_save[4] = SAA716x_EPRD(GREG, GREG_VI_CTRL);
+	g_save[5] = SAA716x_EPRD(GREG, GREG_FGPI_CTRL);
+	g_save[6] = SAA716x_EPRD(GREG, GREG_RSTU_CTRL);
+	g_save[7] = SAA716x_EPRD(GREG, GREG_I2C_CTRL);
+	g_save[8] = SAA716x_EPRD(GREG, GREG_OVFLW_CTRL);
+	g_save[9] = SAA716x_EPRD(GREG, GREG_TAG_ACK_FLEN);
+
+	g_save[10] = SAA716x_EPRD(GREG, GREG_VIDEO_IN_CTRL);
+}
+
+void saa716x_greg_restore(struct saa716x_dev *saa716x)
+{
+	SAA716x_EPWR(GREG, GREG_SUBSYS_CONFIG, g_save[0]);
+	SAA716x_EPWR(GREG, GREG_MSI_BAR_PMCSR, g_save[1]);
+	SAA716x_EPWR(GREG, GREG_PMCSR_DATA_1, g_save[2]);
+	SAA716x_EPWR(GREG, GREG_PMCSR_DATA_2, g_save[3]);
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, g_save[4]);
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, g_save[5]);
+	SAA716x_EPWR(GREG, GREG_RSTU_CTRL, g_save[6]);
+	SAA716x_EPWR(GREG, GREG_I2C_CTRL, g_save[7]);
+	SAA716x_EPWR(GREG, GREG_OVFLW_CTRL, g_save[8]);
+	SAA716x_EPWR(GREG, GREG_TAG_ACK_FLEN, g_save[9]);
+
+	SAA716x_EPWR(GREG, GREG_VIDEO_IN_CTRL, g_save[10]);
+}
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_greg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_greg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,9 @@
+#ifndef __SAA716x_GREG_H
+#define __SAA716x_GREG_H
+
+struct saa716x_dev;
+
+extern void saa716x_greg_save(struct saa716x_dev *saa716x);
+extern void saa716x_greg_restore(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_GREG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_greg_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_greg_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_greg_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,91 @@
+#ifndef __SAA716x_GREG_REG_H
+#define __SAA716x_GREG_REG_H
+
+/* -------------- GREG Registers -------------- */
+
+#define GREG_SUBSYS_CONFIG		0x000
+#define GREG_SUBSYS_ID			(0x0000ffff << 16)
+#define GREG_SUBSYS_VID			(0x0000ffff <<  0)
+
+#define GREG_MSI_BAR_PMCSR		0x004
+#define GREG_PMCSR_SCALE_7		(0x00000003 << 30)
+#define GREG_PMCSR_SCALE_6		(0x00000003 << 28)
+#define GREG_PMCSR_SCALE_5		(0x00000003 << 26)
+#define GREG_PMCSR_SCALE_4		(0x00000003 << 24)
+#define GREG_PMCSR_SCALE_3		(0x00000003 << 22)
+#define GREG_PMCSR_SCALE_2		(0x00000003 << 20)
+#define GREG_PMCSR_SCALE_1		(0x00000003 << 18)
+#define GREG_PMCSR_SCALE_0		(0x00000003 << 16)
+
+#define GREG_BAR_WIDTH_17		(0x0000001e <<  8)
+#define GREG_BAR_WIDTH_18		(0x0000001c <<  8)
+#define GREG_BAR_WIDTH_19		(0x00000018 <<  8)
+#define GREG_BAR_WIDTH_20		(0x00000010 <<  8)
+
+#define GREG_BAR_PREFETCH		(0x00000001 <<  3)
+#define GREG_MSI_MM_CAP1		(0x00000000 <<  0) // FIXME !
+#define GREG_MSI_MM_CAP2		(0x00000001 <<  0)
+#define GREG_MSI_MM_CAP4		(0x00000002 <<  0)
+#define GREG_MSI_MM_CAP8		(0x00000003 <<  0)
+#define GREG_MSI_MM_CAP16		(0x00000004 <<  0)
+#define GREG_MSI_MM_CAP32		(0x00000005 <<  0)
+
+#define GREG_PMCSR_DATA_1		0x008
+#define GREG_PMCSR_DATA_2		0x00c
+#define GREG_VI_CTRL			0x010
+#define GREG_FGPI_CTRL			0x014
+
+#define GREG_RSTU_CTRL			0x018
+#define GREG_BOOT_READY			(0x00000001 << 13)
+#define GREG_RESET_REQ			(0x00000001 << 12)
+#define GREG_IP_RST_RELEASE		(0x00000001 << 11)
+#define GREG_ADAPTER_RST_RELEASE	(0x00000001 << 10)
+#define GREG_PCIE_CORE_RST_RELEASE	(0x00000001 <<  9)
+#define GREG_BOOT_IP_RST_RELEASE	(0x00000001 <<  8)
+#define GREG_BOOT_RST_RELEASE		(0x00000001 <<  7)
+#define GREG_CGU_RST_RELEASE		(0x00000001 <<  6)
+#define GREG_IP_RST_ASSERT		(0x00000001 <<  5)
+#define GREG_ADAPTER_RST_ASSERT		(0x00000001 <<  4)
+#define GREG_RST_ASSERT			(0x00000001 <<  3)
+#define GREG_BOOT_IP_RST_ASSERT		(0x00000001 <<  2)
+#define GREG_BOOT_RST_ASSERT		(0x00000001 <<  1)
+#define GREG_CGU_RST_ASSERT		(0x00000001 <<  0)
+
+#define GREG_I2C_CTRL			0x01c
+#define GREG_I2C_SLAVE_ADDR		(0x0000007f <<  0)
+
+#define GREG_OVFLW_CTRL			0x020
+#define GREG_OVERFLOW_ENABLE		(0x00001fff <<  0)
+
+#define GREG_TAG_ACK_FLEN		0x024
+#define GREG_TAG_ACK_FLEN_1B		(0x00000000 <<  0)
+#define GREG_TAG_ACK_FLEN_2B		(0x00000001 <<  0)
+#define GREG_TAG_ACK_FLEN_4B		(0x00000002 <<  0)
+#define GREG_TAG_ACK_FLEN_8B		(0x00000003 <<  0)
+
+#define GREG_VIDEO_IN_CTRL		0x028
+
+#define GREG_SPARE_1			0x02c
+#define GREG_SPARE_2			0x030
+#define GREG_SPARE_3			0x034
+#define GREG_SPARE_4			0x038
+#define GREG_SPARE_5			0x03c
+#define GREG_SPARE_6			0x040
+#define GREG_SPARE_7			0x044
+#define GREG_SPARE_8			0x048
+#define GREG_SPARE_9			0x04c
+#define GREG_SPARE_10			0x050
+#define GREG_SPARE_11			0x054
+#define GREG_SPARE_12			0x058
+#define GREG_SPARE_13			0x05c
+#define GREG_SPARE_14			0x060
+#define GREG_SPARE_15			0x064
+
+#define GREG_FAIL_DISABLE		0x068
+#define GREG_BOOT_FAIL_DISABLE		(0x00000001 <<  0)
+
+#define GREG_SW_RST			0xff0
+#define GREG_SW_RESET			(0x00000001 <<  0)
+
+
+#endif /* __SAA716x_GREG_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_hybrid.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_hybrid.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_hybrid.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_hybrid.c	2012-06-18 23:15:05.104033527 +0200
@@ -0,0 +1,726 @@
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <linux/i2c.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_gpio_reg.h"
+#include "saa716x_greg_reg.h"
+#include "saa716x_msi_reg.h"
+
+#include "saa716x_adap.h"
+#include "saa716x_i2c.h"
+#include "saa716x_msi.h"
+#include "saa716x_hybrid.h"
+#include "saa716x_gpio.h"
+#include "saa716x_rom.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+#include "../frontends/zl10353.h"
+#include "../frontends/mb86a16.h"
+#include "../frontends/tda1004x.h"
+#include "../tuners/tda827x.h"
+
+unsigned int verbose;
+module_param(verbose, int, 0644);
+MODULE_PARM_DESC(verbose, "verbose startup messages, default is 1 (yes)");
+
+unsigned int int_type;
+module_param(int_type, int, 0644);
+MODULE_PARM_DESC(int_type, "force Interrupt Handler type: 0=INT-A, 1=MSI, 2=MSI-X. default INT-A mode");
+
+#define DRIVER_NAME	"SAA716x Hybrid"
+
+static int __devinit saa716x_hybrid_pci_probe(struct pci_dev *pdev, const struct pci_device_id *pci_id)
+{
+	struct saa716x_dev *saa716x;
+	int err = 0;
+
+	saa716x = kzalloc(sizeof (struct saa716x_dev), GFP_KERNEL);
+	if (saa716x == NULL) {
+		printk(KERN_ERR "saa716x_hybrid_pci_probe ERROR: out of memory\n");
+		err = -ENOMEM;
+		goto fail0;
+	}
+
+	saa716x->verbose	= verbose;
+	saa716x->int_type	= int_type;
+	saa716x->pdev		= pdev;
+	saa716x->config		= (struct saa716x_config *) pci_id->driver_data;
+
+	err = saa716x_pci_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x PCI Initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_cgu_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x CGU Init failed");
+		goto fail1;
+	}
+
+	err = saa716x_core_boot(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Core Boot failed");
+		goto fail2;
+	}
+	dprintk(SAA716x_DEBUG, 1, "SAA716x Core Boot Success");
+
+	err = saa716x_msi_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x MSI Init failed");
+		goto fail2;
+	}
+
+	err = saa716x_jetpack_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x Jetpack core Initialization failed");
+		goto fail1;
+	}
+
+	err = saa716x_i2c_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x I2C Initialization failed");
+		goto fail3;
+	}
+
+	saa716x_gpio_init(saa716x);
+
+	err = saa716x_dump_eeprom(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM dump failed");
+	}
+
+	err = saa716x_eeprom_data(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x EEPROM dump failed");
+	}
+
+	/* enable decoders on 7162 */
+	if (pdev->device == SAA7162) {
+		saa716x_gpio_set_output(saa716x, 24);
+		saa716x_gpio_set_output(saa716x, 25);
+
+		saa716x_gpio_write(saa716x, 24, 0);
+		saa716x_gpio_write(saa716x, 25, 0);
+
+		msleep(10);
+
+		saa716x_gpio_write(saa716x, 24, 1);
+		saa716x_gpio_write(saa716x, 25, 1);
+	}
+
+	/* set default port mapping */
+	SAA716x_EPWR(GREG, GREG_VI_CTRL, 0x2C688F44);
+	/* enable FGPI3 and FGPI0 for TS input from Port 3 and 6 */
+	SAA716x_EPWR(GREG, GREG_FGPI_CTRL, 0x894);
+
+	err = saa716x_dvb_init(saa716x);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x DVB initialization failed");
+		goto fail4;
+	}
+
+	return 0;
+
+fail4:
+	saa716x_dvb_exit(saa716x);
+fail3:
+	saa716x_i2c_exit(saa716x);
+fail2:
+	saa716x_pci_exit(saa716x);
+fail1:
+	kfree(saa716x);
+fail0:
+	return err;
+}
+
+static void __devexit saa716x_hybrid_pci_remove(struct pci_dev *pdev)
+{
+	struct saa716x_dev *saa716x = pci_get_drvdata(pdev);
+
+	saa716x_dvb_exit(saa716x);
+	saa716x_i2c_exit(saa716x);
+	saa716x_pci_exit(saa716x);
+	kfree(saa716x);
+}
+
+static irqreturn_t saa716x_hybrid_pci_irq(int irq, void *dev_id)
+{
+	struct saa716x_dev *saa716x	= (struct saa716x_dev *) dev_id;
+
+	u32 stat_h, stat_l, mask_h, mask_l;
+
+	if (unlikely(saa716x == NULL)) {
+		printk("%s: saa716x=NULL", __func__);
+		return IRQ_NONE;
+	}
+
+	stat_l = SAA716x_EPRD(MSI, MSI_INT_STATUS_L);
+	stat_h = SAA716x_EPRD(MSI, MSI_INT_STATUS_H);
+	mask_l = SAA716x_EPRD(MSI, MSI_INT_ENA_L);
+	mask_h = SAA716x_EPRD(MSI, MSI_INT_ENA_H);
+
+	dprintk(SAA716x_DEBUG, 1, "MSI STAT L=<%02x> H=<%02x>, CTL L=<%02x> H=<%02x>",
+		stat_l, stat_h, mask_l, mask_h);
+
+	if (!((stat_l & mask_l) || (stat_h & mask_h)))
+		return IRQ_NONE;
+
+	if (stat_l)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, stat_l);
+
+	if (stat_h)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_H, stat_h);
+
+	saa716x_msi_event(saa716x, stat_l, stat_h);
+#if 0
+	dprintk(SAA716x_DEBUG, 1, "VI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(VI0, INT_STATUS),
+		SAA716x_EPRD(VI1, INT_STATUS),
+		SAA716x_EPRD(VI0, INT_ENABLE),
+		SAA716x_EPRD(VI1, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 0=<%02x> 1=<%02x>, CTL 1=<%02x> 2=<%02x>",
+		SAA716x_EPRD(FGPI0, INT_STATUS),
+		SAA716x_EPRD(FGPI1, INT_STATUS),
+		SAA716x_EPRD(FGPI0, INT_ENABLE),
+		SAA716x_EPRD(FGPI0, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "FGPI STAT 2=<%02x> 3=<%02x>, CTL 2=<%02x> 3=<%02x>",
+		SAA716x_EPRD(FGPI2, INT_STATUS),
+		SAA716x_EPRD(FGPI3, INT_STATUS),
+		SAA716x_EPRD(FGPI2, INT_ENABLE),
+		SAA716x_EPRD(FGPI3, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "AI STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(AI0, AI_STATUS),
+		SAA716x_EPRD(AI1, AI_STATUS),
+		SAA716x_EPRD(AI0, AI_CTL),
+		SAA716x_EPRD(AI1, AI_CTL));
+
+	dprintk(SAA716x_DEBUG, 1, "I2C STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(I2C_A, INT_STATUS),
+		SAA716x_EPRD(I2C_B, INT_STATUS),
+		SAA716x_EPRD(I2C_A, INT_ENABLE),
+		SAA716x_EPRD(I2C_B, INT_ENABLE));
+
+	dprintk(SAA716x_DEBUG, 1, "DCS STAT=<%02x>, CTL=<%02x>",
+		SAA716x_EPRD(DCS, DCSC_INT_STATUS),
+		SAA716x_EPRD(DCS, DCSC_INT_ENABLE));
+#endif
+
+	if (stat_l) {
+		if (stat_l & MSI_INT_TAGACK_FGPI_0) {
+			tasklet_schedule(&saa716x->fgpi[0].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_1) {
+			tasklet_schedule(&saa716x->fgpi[1].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_2) {
+			tasklet_schedule(&saa716x->fgpi[2].tasklet);
+		}
+		if (stat_l & MSI_INT_TAGACK_FGPI_3) {
+			tasklet_schedule(&saa716x->fgpi[3].tasklet);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void demux_worker(unsigned long data)
+{
+	struct saa716x_fgpi_stream_port *fgpi_entry = (struct saa716x_fgpi_stream_port *)data;
+	struct saa716x_dev *saa716x = fgpi_entry->saa716x;
+	struct dvb_demux *demux;
+	u32 fgpi_index;
+	u32 i;
+	u32 write_index;
+
+	fgpi_index = fgpi_entry->dma_channel - 6;
+	demux = NULL;
+	for (i = 0; i < saa716x->config->adapters; i++) {
+		if (saa716x->config->adap_config[i].ts_port == fgpi_index) {
+			demux = &saa716x->saa716x_adap[i].demux;
+			break;
+		}
+	}
+	if (demux == NULL) {
+		printk(KERN_ERR "%s: unexpected channel %u\n",
+		       __func__, fgpi_entry->dma_channel);
+		return;
+	}
+
+	write_index = saa716x_fgpi_get_write_index(saa716x, fgpi_index);
+	if (write_index < 0)
+		return;
+
+	dprintk(SAA716x_DEBUG, 1, "dma buffer = %d", write_index);
+
+	if (write_index == fgpi_entry->read_index) {
+		printk(KERN_DEBUG "%s: called but nothing to do\n", __func__);
+		return;
+	}
+
+	do {
+		u8 *data = (u8 *)fgpi_entry->dma_buf[fgpi_entry->read_index].mem_virt;
+
+		pci_dma_sync_sg_for_cpu(saa716x->pdev,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].sg_list,
+			fgpi_entry->dma_buf[fgpi_entry->read_index].list_len,
+			PCI_DMA_FROMDEVICE);
+
+		dvb_dmx_swfilter(demux, data, 348 * 188);
+
+		fgpi_entry->read_index = (fgpi_entry->read_index + 1) & 7;
+	} while (write_index != fgpi_entry->read_index);
+}
+
+/*
+ * Twinhan/Azurewave VP-6090
+ * DVB-S Frontend: 2x MB86A16
+ * DVB-T Frontend: 2x TDA10046 + TDA8275
+ */
+#define SAA716x_MODEL_TWINHAN_VP6090	"Twinhan/Azurewave VP-6090"
+#define SAA716x_DEV_TWINHAN_VP6090	"2xDVB-S + 2xDVB-T + 2xAnalog"
+
+static int tda1004x_vp6090_request_firmware(struct dvb_frontend *fe,
+					      const struct firmware **fw,
+					      char *name)
+{
+	struct saa716x_adapter *adapter = fe->dvb->priv;
+
+	return request_firmware(fw, name, &adapter->saa716x->pdev->dev);
+}
+
+static struct tda1004x_config tda1004x_vp6090_config = {
+	.demod_address		= 0x8,
+	.invert			= 0,
+	.invert_oclk		= 0,
+	.xtal_freq		= TDA10046_XTAL_4M,
+	.agc_config		= TDA10046_AGC_DEFAULT,
+	.if_freq		= TDA10046_FREQ_3617,
+	.request_firmware	= tda1004x_vp6090_request_firmware,
+};
+
+static int vp6090_dvbs_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct saa716x_dev *saa716x = fe->dvb->priv;
+
+	switch (voltage) {
+	case SEC_VOLTAGE_13:
+		dprintk(SAA716x_ERROR, 1, "Polarization=[13V]");
+		break;
+	case SEC_VOLTAGE_18:
+		dprintk(SAA716x_ERROR, 1, "Polarization=[18V]");
+		break;
+	case SEC_VOLTAGE_OFF:
+		dprintk(SAA716x_ERROR, 1, "Frontend (dummy) POWERDOWN");
+		break;
+	default:
+		dprintk(SAA716x_ERROR, 1, "Invalid = (%d)", (u32 ) voltage);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+struct mb86a16_config vp6090_mb86a16_config = {
+	.demod_address	= 0x08,
+	.set_voltage	= vp6090_dvbs_set_voltage,
+};
+
+static int saa716x_vp6090_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	struct saa716x_i2c *i2c = &saa716x->i2c[count];
+
+	dprintk(SAA716x_ERROR, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	dprintk(SAA716x_ERROR, 1, "Adapter (%d) Power ON", count);
+
+	saa716x_gpio_set_output(saa716x, 11);
+	saa716x_gpio_set_output(saa716x, 10);
+	saa716x_gpio_write(saa716x, 11, 1);
+	saa716x_gpio_write(saa716x, 10, 1);
+	msleep(100);
+#if 0
+	dprintk(SAA716x_ERROR, 1, "Probing for MB86A16 (DVB-S/DSS)");
+	adapter->fe = mb86a16_attach(&vp6090_mb86a16_config, &i2c->i2c_adapter);
+	if (adapter->fe) {
+		dprintk(SAA716x_ERROR, 1, "found MB86A16 DVB-S/DSS frontend @0x%02x",
+			vp6090_mb86a16_config.demod_address);
+
+	} else {
+		goto exit;
+	}
+#endif
+	adapter->fe = tda10046_attach(&tda1004x_vp6090_config, &i2c->i2c_adapter);
+	if (adapter->fe == NULL) {
+		dprintk(SAA716x_ERROR, 1, "Frontend attach failed");
+		return -ENODEV;
+	} else {
+		dprintk(SAA716x_ERROR, 1, "Done!");
+		return 0;
+	}
+
+	return 0;
+}
+
+static struct saa716x_config saa716x_vp6090_config = {
+	.model_name		= SAA716x_MODEL_TWINHAN_VP6090,
+	.dev_type		= SAA716x_DEV_TWINHAN_VP6090,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_vp6090_frontend_attach,
+	.irq_handler		= saa716x_hybrid_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+/*
+ * NXP Reference design (Atlantis)
+ * 2x DVB-T Frontend: 2x TDA10046
+ * Analog Decoder: 2x Internal
+ */
+#define SAA716x_MODEL_NXP_ATLANTIS	"Atlantis reference board"
+#define SAA716x_DEV_NXP_ATLANTIS	"2x DVB-T + 2x Analog"
+
+static int tda1004x_atlantis_request_firmware(struct dvb_frontend *fe,
+					      const struct firmware **fw,
+					      char *name)
+{
+	struct saa716x_adapter *adapter = fe->dvb->priv;
+
+	return request_firmware(fw, name, &adapter->saa716x->pdev->dev);
+}
+
+static struct tda1004x_config tda1004x_atlantis_config = {
+	.demod_address		= 0x8,
+	.invert			= 0,
+	.invert_oclk		= 0,
+	.xtal_freq		= TDA10046_XTAL_16M,
+	.agc_config		= TDA10046_AGC_TDA827X,
+	.if_freq		= TDA10046_FREQ_045,
+	.request_firmware	= tda1004x_atlantis_request_firmware,
+	.tuner_address          = 0x60,
+};
+
+static struct tda827x_config tda827x_atlantis_config = {
+	.init		= NULL,
+	.sleep		= NULL,
+	.config		= 0,
+	.switch_addr	= 0,
+	.agcf		= NULL,
+};
+
+static int saa716x_atlantis_frontend_attach(struct saa716x_adapter *adapter,
+					    int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	struct saa716x_i2c *i2c;
+	u8 i2c_buf[3] = { 0x05, 0x23, 0x01 }; /* activate the silent I2C bus */
+	struct i2c_msg msg = {
+		.addr  = 0x42 >> 1,
+		.flags = 0,
+		.buf   = i2c_buf,
+		.len   = sizeof(i2c_buf)
+	};
+
+	if (count < saa716x->config->adapters) {
+		u32 reset_gpio;
+
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init",
+			count);
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count,
+			saa716x->pdev->subsystem_device);
+
+		if (count == 0) {
+			reset_gpio = 14;
+			i2c = &saa716x->i2c[SAA716x_I2C_BUS_A];
+		} else {
+			reset_gpio = 15;
+			i2c = &saa716x->i2c[SAA716x_I2C_BUS_B];
+		}
+
+		/* activate the silent I2C bus */
+		i2c_transfer(&i2c->i2c_adapter, &msg, 1);
+
+		saa716x_gpio_set_output(saa716x, reset_gpio);
+
+		/* Reset the demodulator */
+		saa716x_gpio_write(saa716x, reset_gpio, 1);
+		msleep(10);
+		saa716x_gpio_write(saa716x, reset_gpio, 0);
+		msleep(10);
+		saa716x_gpio_write(saa716x, reset_gpio, 1);
+		msleep(10);
+
+		adapter->fe = tda10046_attach(&tda1004x_atlantis_config,
+					      &i2c->i2c_adapter);
+		if (adapter->fe == NULL)
+			goto exit;
+
+		dprintk(SAA716x_ERROR, 1,
+			"found TDA10046 DVB-T frontend @0x%02x",
+			tda1004x_atlantis_config.demod_address);
+
+		if (dvb_attach(tda827x_attach, adapter->fe,
+			       tda1004x_atlantis_config.tuner_address,
+			       &i2c->i2c_adapter, &tda827x_atlantis_config)) {
+			dprintk(SAA716x_ERROR, 1, "found TDA8275 tuner @0x%02x",
+				tda1004x_atlantis_config.tuner_address);
+		} else {
+			goto exit;
+		}
+
+		dprintk(SAA716x_ERROR, 1, "Done!");
+		return 0;
+	}
+
+exit:
+	dprintk(SAA716x_ERROR, 1, "Frontend attach failed");
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_atlantis_config = {
+	.model_name		= SAA716x_MODEL_NXP_ATLANTIS,
+	.dev_type		= SAA716x_DEV_NXP_ATLANTIS,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 2,
+	.frontend_attach	= saa716x_atlantis_frontend_attach,
+	.irq_handler		= saa716x_hybrid_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+	.adap_config		= {
+		{
+			/* Adapter 0 */
+			.ts_port = 3, /* using FGPI 3 */
+			.worker = demux_worker
+		},
+		{
+			/* Adapter 1 */
+			.ts_port = 0, /* using FGPI 0 */
+			.worker = demux_worker
+		}
+	}
+};
+
+/*
+ * NXP Reference design (NEMO)
+ * DVB-T Frontend: 1x TDA10046 + TDA8275
+ * Analog Decoder: External SAA7136
+ */
+#define SAA716x_MODEL_NXP_NEMO		"NEMO reference board"
+#define SAA716x_DEV_NXP_NEMO		"DVB-T + Analog"
+
+static int tda1004x_nemo_request_firmware(struct dvb_frontend *fe,
+					  const struct firmware **fw,
+					  char *name)
+{
+	struct saa716x_adapter *adapter = fe->dvb->priv;
+
+	return request_firmware(fw, name, &adapter->saa716x->pdev->dev);
+}
+
+static struct tda1004x_config tda1004x_nemo_config = {
+	.demod_address		= 0x8,
+	.invert			= 0,
+	.invert_oclk		= 0,
+	.xtal_freq		= TDA10046_XTAL_16M,
+	.agc_config		= TDA10046_AGC_TDA827X,
+	.if_freq		= TDA10046_FREQ_045,
+	.request_firmware	= tda1004x_nemo_request_firmware,
+	.tuner_address          = 0x60,
+};
+
+static struct tda827x_config tda827x_nemo_config = {
+	.init		= NULL,
+	.sleep		= NULL,
+	.config		= 0,
+	.switch_addr	= 0,
+	.agcf		= NULL,
+};
+
+static int saa716x_nemo_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+	struct saa716x_i2c *demod_i2c = &saa716x->i2c[SAA716x_I2C_BUS_B];
+	struct saa716x_i2c *tuner_i2c = &saa716x->i2c[SAA716x_I2C_BUS_A];
+
+
+	if (count  == 0) {
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+		dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+		dprintk(SAA716x_ERROR, 1, "Adapter (%d) Power ON", count);
+
+		/* GPIO 26 controls a +15dB gain */
+		saa716x_gpio_set_output(saa716x, 26);
+		saa716x_gpio_write(saa716x, 26, 0);
+
+		saa716x_gpio_set_output(saa716x, 14);
+
+		/* Reset the demodulator */
+		saa716x_gpio_write(saa716x, 14, 1);
+		msleep(10);
+		saa716x_gpio_write(saa716x, 14, 0);
+		msleep(10);
+		saa716x_gpio_write(saa716x, 14, 1);
+		msleep(10);
+
+		adapter->fe = tda10046_attach(&tda1004x_nemo_config,
+					      &demod_i2c->i2c_adapter);
+		if (adapter->fe) {
+			dprintk(SAA716x_ERROR, 1, "found TDA10046 DVB-T frontend @0x%02x",
+				tda1004x_nemo_config.demod_address);
+
+		} else {
+			goto exit;
+		}
+		if (dvb_attach(tda827x_attach, adapter->fe,
+			       tda1004x_nemo_config.tuner_address,
+			       &tuner_i2c->i2c_adapter, &tda827x_nemo_config)) {
+			dprintk(SAA716x_ERROR, 1, "found TDA8275 tuner @0x%02x",
+				tda1004x_nemo_config.tuner_address);
+		} else {
+			goto exit;
+		}
+		dprintk(SAA716x_ERROR, 1, "Done!");
+	}
+
+	return 0;
+exit:
+	dprintk(SAA716x_ERROR, 1, "Frontend attach failed");
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_nemo_config = {
+	.model_name		= SAA716x_MODEL_NXP_NEMO,
+	.dev_type		= SAA716x_DEV_NXP_NEMO,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_nemo_frontend_attach,
+	.irq_handler		= saa716x_hybrid_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+
+	.adap_config		= {
+		{
+			/* Adapter 0 */
+			.ts_port = 3, /* using FGPI 3 */
+			.worker = demux_worker
+		}
+	}
+};
+
+
+#define SAA716x_MODEL_AVERMEDIA_HC82	"Avermedia HC82 Express-54"
+#define SAA716x_DEV_AVERMEDIA_HC82	"DVB-T + Analog"
+
+#if 0
+static struct zl10353_config saa716x_averhc82_zl10353_config = {
+	.demod_address		= 0x1f,
+	.adc_clock		= 450560,
+	.if2			= 361667,
+	.no_tuner		= 1,
+	.parallel_ts		= 1,
+};
+#endif
+
+static int saa716x_averhc82_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+//	adapter->fe = zl10353_attach(&saa716x_averhc82_zl10353_config, &i2c->i2c_adapter);
+
+
+	return 0;
+}
+
+static struct saa716x_config saa716x_averhc82_config = {
+	.model_name		= SAA716x_MODEL_AVERMEDIA_HC82,
+	.dev_type		= SAA716x_DEV_AVERMEDIA_HC82,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_averhc82_frontend_attach,
+	.irq_handler		= saa716x_hybrid_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+#define SAA716x_MODEL_AVERMEDIA_H788	"Avermedia H788"
+#define SAA716x_DEV_AVERMEDIA_H788	"DVB-T + Analaog"
+
+static int saa716x_averh88_frontend_attach(struct saa716x_adapter *adapter, int count)
+{
+	struct saa716x_dev *saa716x = adapter->saa716x;
+
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) SAA716x frontend Init", count);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%d) Device ID=%02x", count, saa716x->pdev->subsystem_device);
+
+	return -ENODEV;
+}
+
+static struct saa716x_config saa716x_averh788_config = {
+	.model_name		= SAA716x_MODEL_AVERMEDIA_H788,
+	.dev_type		= SAA716x_DEV_AVERMEDIA_H788,
+	.boot_mode		= SAA716x_EXT_BOOT,
+	.adapters		= 1,
+	.frontend_attach	= saa716x_averh88_frontend_attach,
+	.irq_handler		= saa716x_hybrid_pci_irq,
+	.i2c_rate		= SAA716x_I2C_RATE_100,
+};
+
+static struct pci_device_id saa716x_hybrid_pci_table[] = {
+
+	MAKE_ENTRY(TWINHAN_TECHNOLOGIES, TWINHAN_VP_6090, SAA7162, &saa716x_vp6090_config),
+	MAKE_ENTRY(AVERMEDIA, AVERMEDIA_HC82, SAA7160, &saa716x_averhc82_config),
+	MAKE_ENTRY(AVERMEDIA, AVERMEDIA_H788, SAA7160, &saa716x_averh788_config),
+	MAKE_ENTRY(KWORLD, KWORLD_DVB_T_PE310, SAA7162, &saa716x_atlantis_config),
+	MAKE_ENTRY(NXP_REFERENCE_BOARD, PCI_ANY_ID, SAA7162, &saa716x_atlantis_config),
+	MAKE_ENTRY(NXP_REFERENCE_BOARD, PCI_ANY_ID, SAA7160, &saa716x_nemo_config),
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, saa716x_hybrid_pci_table);
+
+static struct pci_driver saa716x_hybrid_pci_driver = {
+	.name			= DRIVER_NAME,
+	.id_table		= saa716x_hybrid_pci_table,
+	.probe			= saa716x_hybrid_pci_probe,
+	.remove			= saa716x_hybrid_pci_remove,
+};
+
+static int __devinit saa716x_hybrid_init(void)
+{
+	return pci_register_driver(&saa716x_hybrid_pci_driver);
+}
+
+static void __devexit saa716x_hybrid_exit(void)
+{
+	return pci_unregister_driver(&saa716x_hybrid_pci_driver);
+}
+
+module_init(saa716x_hybrid_init);
+module_exit(saa716x_hybrid_exit);
+
+MODULE_DESCRIPTION("SAA716x Hybrid driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_hybrid.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_hybrid.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_hybrid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_hybrid.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,13 @@
+#ifndef __SAA716x_HYBRID_H
+#define __SAA716x_HYBRID_H
+
+#define TWINHAN_TECHNOLOGIES	0x1822
+#define AVERMEDIA		0x1461
+#define KWORLD			0x17DE
+
+#define TWINHAN_VP_6090		0x0027
+#define AVERMEDIA_HC82		0x2355
+#define AVERMEDIA_H788		0x1455
+#define KWORLD_DVB_T_PE310	0x7521
+
+#endif /* __SAA716x_HYBRID_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c.c	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,738 @@
+#include <linux/delay.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include <linux/i2c.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_i2c_reg.h"
+#include "saa716x_msi_reg.h"
+#include "saa716x_cgu_reg.h"
+
+#include "saa716x_i2c.h"
+#include "saa716x_msi.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+#define SAA716x_I2C_TXFAIL	(I2C_ERROR_IBE		| \
+				 I2C_ACK_INTER_MTNA	| \
+				 I2C_FAILURE_INTER_MAF)
+
+#define SAA716x_I2C_TXBUSY	(I2C_TRANSMIT		| \
+				 I2C_TRANSMIT_PROG)
+
+#define SAA716x_I2C_RXBUSY	(I2C_RECEIVE		| \
+				 I2C_RECEIVE_CLEAR)
+
+static const char* state[] = {
+	"Idle",
+	"DoneStop",
+	"Busy",
+	"TOscl",
+	"TOarb",
+	"DoneWrite",
+	"DoneRead",
+	"DoneWriteTO",
+	"DoneReadTO",
+	"NoDevice",
+	"NoACK",
+	"BUSErr",
+	"ArbLost",
+	"SEQErr",
+	"STErr"
+};
+
+int saa716x_i2c_irqevent(struct saa716x_dev *saa716x, u8 bus)
+{
+	u32 stat, mask;
+	u32 *I2C_DEV;
+
+	BUG_ON(saa716x == NULL);
+	I2C_DEV = saa716x->I2C_DEV;
+
+	stat = SAA716x_EPRD(I2C_DEV[bus], INT_STATUS);
+	mask = SAA716x_EPRD(I2C_DEV[bus], INT_ENABLE);
+	saa716x->i2c[bus].i2c_stat = stat;
+	dprintk(SAA716x_DEBUG, 0, "Bus(%d) I2C event: Status=<%s> --> Stat=<%02x> Mask=<%02x>",
+		bus, state[stat], stat, mask);
+
+	if (!(stat & mask))
+		return -1;
+
+	SAA716x_EPWR(I2C_DEV[bus], INT_CLR_STATUS, stat);
+
+	if (stat & I2C_INTERRUPT_STFNF)
+		dprintk(SAA716x_DEBUG, 0, "<STFNF> ");
+
+	if (stat & I2C_INTERRUPT_MTFNF) {
+		dprintk(SAA716x_DEBUG, 0, "<MTFNF> ");
+	}
+
+	if (stat & I2C_INTERRUPT_RFDA)
+		dprintk(SAA716x_DEBUG, 0, "<RFDA> ");
+
+	if (stat & I2C_INTERRUPTE_RFF)
+		dprintk(SAA716x_DEBUG, 0, "<RFF> ");
+
+	if (stat & I2C_SLAVE_INTERRUPT_STDR)
+		dprintk(SAA716x_DEBUG, 0, "<STDR> ");
+
+	if (stat & I2C_MASTER_INTERRUPT_MTDR) {
+		dprintk(SAA716x_DEBUG, 0, "<MTDR> ");
+	}
+
+	if (stat & I2C_ERROR_IBE)
+		dprintk(SAA716x_DEBUG, 0, "<IBE> ");
+
+	if (stat & I2C_MODE_CHANGE_INTER_MSMC)
+		dprintk(SAA716x_DEBUG, 0, "<MSMC> ");
+
+	if (stat & I2C_SLAVE_RECEIVE_INTER_SRSD)
+		dprintk(SAA716x_DEBUG, 0, "<SRSD> ");
+
+	if (stat & I2C_SLAVE_TRANSMIT_INTER_STSD)
+		dprintk(SAA716x_DEBUG, 0, "<STSD> ");
+
+	if (stat & I2C_ACK_INTER_MTNA)
+		dprintk(SAA716x_DEBUG, 0, "<MTNA> ");
+
+	if (stat & I2C_FAILURE_INTER_MAF)
+		dprintk(SAA716x_DEBUG, 0, "<MAF> ");
+
+	if (stat & I2C_INTERRUPT_MTD)
+		dprintk(SAA716x_DEBUG, 0, "<MTD> ");
+
+	return 0;
+}
+
+static irqreturn_t saa716x_i2c_irq(int irq, void *dev_id)
+{
+	struct saa716x_dev *saa716x	= (struct saa716x_dev *) dev_id;
+
+	if (unlikely(saa716x == NULL)) {
+		printk("%s: saa716x=NULL", __func__);
+		return IRQ_NONE;
+	}
+	dprintk(SAA716x_DEBUG, 1, "MSI STAT L=<%02x> H=<%02x>, CTL L=<%02x> H=<%02x>",
+		SAA716x_EPRD(MSI, MSI_INT_STATUS_L),
+		SAA716x_EPRD(MSI, MSI_INT_STATUS_H),
+		SAA716x_EPRD(MSI, MSI_INT_ENA_L),
+		SAA716x_EPRD(MSI, MSI_INT_ENA_H));
+
+	dprintk(SAA716x_DEBUG, 1, "I2C STAT 0=<%02x> 1=<%02x>, CTL 0=<%02x> 1=<%02x>",
+		SAA716x_EPRD(I2C_A, INT_STATUS),
+		SAA716x_EPRD(I2C_B, INT_STATUS),
+		SAA716x_EPRD(I2C_A, INT_CLR_STATUS),
+		SAA716x_EPRD(I2C_B, INT_CLR_STATUS));
+
+	return IRQ_HANDLED;
+}
+
+static void saa716x_term_xfer(struct saa716x_i2c *i2c, u32 I2C_DEV)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0xc0); /* Start: SCL/SDA High */
+	msleep(10);
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0x80);
+	msleep(10);
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0x00);
+	msleep(10);
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0x80);
+	msleep(10);
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0xc0);
+
+	return;
+}
+
+static void saa716x_i2c_hwdeinit(struct saa716x_i2c *i2c, u32 I2C_DEV)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+
+	/* Disable all interrupts and clear status */
+	SAA716x_EPWR(I2C_DEV, INT_CLR_ENABLE, 0x1fff);
+	SAA716x_EPWR(I2C_DEV, INT_CLR_STATUS, 0x1fff);
+}
+
+static int saa716x_i2c_hwinit(struct saa716x_i2c *i2c, u32 I2C_DEV)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	struct i2c_adapter *adapter = &i2c->i2c_adapter;
+
+	int i, err = 0;
+	u32 reg;
+
+	reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+	if (!(reg & 0xd)) {
+		dprintk(SAA716x_ERROR, 1, "Adapter (%02x) %s RESET failed, Exiting !",
+			I2C_DEV, adapter->name);
+		err = -EIO;
+		goto exit;
+	}
+
+	/* Flush queue */
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0xcc);
+
+	/* Disable all interrupts and clear status */
+	SAA716x_EPWR(I2C_DEV, INT_CLR_ENABLE, 0x1fff);
+	SAA716x_EPWR(I2C_DEV, INT_CLR_STATUS, 0x1fff);
+
+	/* Reset I2C Core and generate a delay */
+	SAA716x_EPWR(I2C_DEV, I2C_CONTROL, 0xc1);
+
+	for (i = 0; i < 100; i++) {
+		reg = SAA716x_EPRD(I2C_DEV, I2C_CONTROL);
+		if (reg == 0xc0) {
+			dprintk(SAA716x_ERROR, 1, "Adapter (%02x) %s RESET",
+				I2C_DEV, adapter->name);
+			break;
+		}
+		msleep(1);
+
+		if (i == 99)
+			err = -EIO;
+	}
+
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "Adapter (%02x) %s RESET failed",
+			I2C_DEV, adapter->name);
+
+		saa716x_term_xfer(i2c, I2C_DEV);
+		err = -EIO;
+		goto exit;
+	}
+
+	/* I2C Rate Setup */
+	switch (i2c->i2c_rate) {
+	case SAA716x_I2C_RATE_400:
+
+		dprintk(SAA716x_DEBUG, 1, "Initializing Adapter %s @ 400k", adapter->name);
+		SAA716x_EPWR(I2C_DEV, I2C_CLOCK_DIVISOR_HIGH, 0x1a); /* 0.5 * 27MHz/400kHz */
+		SAA716x_EPWR(I2C_DEV, I2C_CLOCK_DIVISOR_LOW,  0x21); /* 0.5 * 27MHz/400kHz */
+		SAA716x_EPWR(I2C_DEV, I2C_SDA_HOLD, 0x19);
+		break;
+
+	case SAA716x_I2C_RATE_100:
+
+		dprintk(SAA716x_DEBUG, 1, "Initializing Adapter %s @ 100k", adapter->name);
+		SAA716x_EPWR(I2C_DEV, I2C_CLOCK_DIVISOR_HIGH, 0x68); /* 0.5 * 27MHz/100kHz */
+		SAA716x_EPWR(I2C_DEV, I2C_CLOCK_DIVISOR_LOW,  0x87); /* 0.5 * 27MHz/100kHz */
+		SAA716x_EPWR(I2C_DEV, I2C_SDA_HOLD, 0x60);
+		break;
+
+	default:
+
+		dprintk(SAA716x_ERROR, 1, "Adapter %s Unknown Rate (Rate=0x%02x)",
+			adapter->name,
+			i2c->i2c_rate);
+
+		break;
+	}
+
+	/* Disable all interrupts and clear status */
+	SAA716x_EPWR(I2C_DEV, INT_CLR_ENABLE, 0x1fff);
+	SAA716x_EPWR(I2C_DEV, INT_CLR_STATUS, 0x1fff);
+
+	if (i2c->i2c_mode >= SAA716x_I2C_MODE_IRQ) {
+		/* Enabled interrupts:
+		* Master Transaction Done,
+		* Master Transaction Data Request
+		* (0x81)
+		*/
+		msleep(5);
+
+		SAA716x_EPWR(I2C_DEV, INT_SET_ENABLE,
+			I2C_SET_ENABLE_MTDR | I2C_SET_ENABLE_MTD);
+
+		/* Check interrupt enable status */
+		reg = SAA716x_EPRD(I2C_DEV, INT_ENABLE);
+		if (reg != 0x81) {
+
+			dprintk(SAA716x_ERROR, 1,
+				"Adapter (%d) %s Interrupt enable failed, Exiting !",
+				i,
+				adapter->name);
+
+			err = -EIO;
+			goto exit;
+		}
+	}
+
+	/* Check status */
+	reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+	if (!(reg & 0xd)) {
+
+		dprintk(SAA716x_ERROR, 1,
+			"Adapter (%02x) %s has bad state, Exiting !",
+			I2C_DEV,
+			adapter->name);
+
+		err = -EIO;
+		goto exit;
+	}
+#if 0
+	saa716x_add_irqvector(saa716x,
+				i2c_vec[i].vector,
+				i2c_vec[i].edge,
+				i2c_vec[i].handler,
+				SAA716x_I2C_ADAPTER(i));
+#endif
+	reg = SAA716x_EPRD(CGU, CGU_SCR_3);
+	dprintk(SAA716x_DEBUG, 1, "Adapter (%02x) Autowake <%d> Active <%d>",
+		I2C_DEV,
+		(reg >> 1) & 0x01,
+		reg & 0x01);
+
+	return 0;
+exit:
+	return err;
+}
+
+static int saa716x_i2c_send(struct saa716x_i2c *i2c, u32 I2C_DEV, u32 data)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	int i, err = 0;
+	u32 reg;
+
+	if (i2c->i2c_mode >= SAA716x_I2C_MODE_IRQ) {
+		/* Write to FIFO */
+		SAA716x_EPWR(I2C_DEV, TX_FIFO, data);
+		return 0;
+	}
+
+	/* Check FIFO status before TX */
+	reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+	i2c->stat_tx_prior = reg;
+	if (reg & SAA716x_I2C_TXBUSY) {
+		for (i = 0; i < 100; i++) {
+			/* TODO! check for hotplug devices */
+			msleep(10);
+			reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+
+			if (reg & SAA716x_I2C_TXBUSY) {
+				dprintk(SAA716x_ERROR, 1, "FIFO full or Blocked");
+
+				err = saa716x_i2c_hwinit(i2c, I2C_DEV);
+				if (err < 0) {
+					dprintk(SAA716x_ERROR, 1, "Error Reinit");
+					err = -EIO;
+					goto exit;
+				}
+			} else {
+				break;
+			}
+		}
+	}
+
+	/* Write to FIFO */
+	SAA716x_EPWR(I2C_DEV, TX_FIFO, data);
+
+	/* Check for data write */
+	for (i = 0; i < 1000; i++) {
+		/* TODO! check for hotplug devices */
+		reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+		if (reg & I2C_TRANSMIT_CLEAR) {
+			break;
+		}
+	}
+	i2c->stat_tx_done = reg;
+
+	if (!(reg & I2C_TRANSMIT_CLEAR)) {
+		dprintk(SAA716x_ERROR, 1, "TXFIFO not empty after Timeout, tried %d loops!", i);
+		err = -EIO;
+		goto exit;
+	}
+
+	return err;
+
+exit:
+	dprintk(SAA716x_ERROR, 1, "I2C Send failed (Err=%d)", err);
+	return err;
+}
+
+static int saa716x_i2c_recv(struct saa716x_i2c *i2c, u32 I2C_DEV, u32 *data)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	int i, err = 0;
+	u32 reg;
+
+	/* Check FIFO status before RX */
+	for (i = 0; i < 1000; i++) {
+		reg = SAA716x_EPRD(I2C_DEV, I2C_STATUS);
+		if (!(reg & SAA716x_I2C_RXBUSY)) {
+			break;
+		}
+	}
+	if (reg & SAA716x_I2C_RXBUSY) {
+		dprintk(SAA716x_INFO, 1, "FIFO empty");
+		err = -EIO;
+		goto exit;
+	}
+
+	/* Read from FIFO */
+	*data = SAA716x_EPRD(I2C_DEV, RX_FIFO);
+
+	return 0;
+exit:
+	dprintk(SAA716x_ERROR, 1, "Error Reading data, err=%d", err);
+	return err;
+}
+
+static void saa716x_i2c_irq_start(struct saa716x_i2c *i2c, u32 I2C_DEV)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+
+	if (i2c->i2c_mode == SAA716x_I2C_MODE_POLLING)
+		return;
+
+	i2c->i2c_op = 1;
+	SAA716x_EPWR(I2C_DEV, INT_CLR_STATUS, 0x1fff);
+}
+
+static int saa716x_i2c_irq_wait(struct saa716x_i2c *i2c, u32 I2C_DEV)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	unsigned long timeout;
+	int err = 0;
+
+	if (i2c->i2c_mode == SAA716x_I2C_MODE_POLLING)
+		return 0;
+
+	timeout = HZ/100 + 1; /* 10ms */
+	timeout = wait_event_interruptible_timeout(i2c->i2c_wq, i2c->i2c_op == 0, timeout);
+	if (timeout == -ERESTARTSYS || i2c->i2c_op) {
+		SAA716x_EPWR(I2C_DEV, INT_CLR_STATUS, 0x1fff);
+		if (timeout == -ERESTARTSYS) {
+			/* a signal arrived */
+			err = -ERESTARTSYS;
+		} else {
+			dprintk(SAA716x_ERROR, 1, "timed out waiting for end of xfer!");
+			err = -EIO;
+		}
+	}
+	return err;
+}
+
+static int saa716x_i2c_write_msg(struct saa716x_i2c *i2c, u32 I2C_DEV,
+				 u16 addr, u8 *buf, u16 len, u8 add_stop)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	u32 data;
+	int err;
+	int i;
+	int bytes;
+
+	saa716x_i2c_irq_start(i2c, I2C_DEV);
+
+	/* first write START with I2C address */
+	data = I2C_START_BIT | (addr << 1);
+	dprintk(SAA716x_DEBUG, 1, "length=%d Addr:0x%02x", len, data);
+	err = saa716x_i2c_send(i2c, I2C_DEV, data);
+	if (err < 0) {
+		dprintk(SAA716x_ERROR, 1, "Address write failed");
+		goto exit;
+	}
+
+	bytes = i2c->block_size - 1;
+
+	/* now write the data */
+	while (len > 0) {
+		if (bytes == i2c->block_size) {
+			/* this is not the first round, so restart irq */
+			saa716x_i2c_irq_start(i2c, I2C_DEV);
+		}
+
+		if (bytes > len)
+			bytes = len;
+
+		for (i = 0; i < bytes; i++) {
+			data = buf[i];
+			dprintk(SAA716x_DEBUG, 0, "    <W %04x> 0x%02x\n", i, data);
+			if (add_stop && i == (len - 1))
+				data |= I2C_STOP_BIT;
+			err = saa716x_i2c_send(i2c, I2C_DEV, data);
+			if (err < 0) {
+				dprintk(SAA716x_ERROR, 1, "Data send failed");
+				goto exit;
+			}
+		}
+
+		err = saa716x_i2c_irq_wait(i2c, I2C_DEV);
+		if (err < 0) {
+			goto exit;
+		}
+
+		len -= bytes;
+		buf += bytes;
+		bytes = i2c->block_size;
+	}
+
+	return 0;
+
+exit:
+	dprintk(SAA716x_ERROR, 1, "Error writing data, err=%d", err);
+	return err;
+}
+
+static int saa716x_i2c_read_msg(struct saa716x_i2c *i2c, u32 I2C_DEV,
+				u16 addr, u8 *buf, u16 len, u8 add_stop)
+{
+	struct saa716x_dev *saa716x = i2c->saa716x;
+	u32 data;
+	int err;
+	int i;
+	int bytes;
+
+	saa716x_i2c_irq_start(i2c, I2C_DEV);
+
+	/* first write START with I2C address */
+	data = I2C_START_BIT | (addr << 1) | 1;
+	dprintk(SAA716x_DEBUG, 1, "length=%d Addr:0x%02x", len, data);
+	err = saa716x_i2c_send(i2c, I2C_DEV, data);
+	if (err < 0) {
+		dprintk(SAA716x_ERROR, 1, "Address write failed");
+		goto exit;
+	}
+
+	bytes = i2c->block_size - 1;
+
+	/* now read the data */
+	while (len > 0) {
+		if (bytes == i2c->block_size) {
+			/* this is not the first round, so restart irq */
+			saa716x_i2c_irq_start(i2c, I2C_DEV);
+		}
+
+		if (bytes > len)
+			bytes = len;
+
+		for (i = 0; i < bytes; i++) {
+			data = 0x00; /* dummy write for reading */
+			if (add_stop && i == (len - 1))
+				data |= I2C_STOP_BIT;
+			err = saa716x_i2c_send(i2c, I2C_DEV, data);
+			if (err < 0) {
+				dprintk(SAA716x_ERROR, 1, "Data send failed");
+				goto exit;
+			}
+		}
+
+		err = saa716x_i2c_irq_wait(i2c, I2C_DEV);
+		if (err < 0) {
+			goto exit;
+		}
+
+		for (i = 0; i < bytes; i++) {
+			err = saa716x_i2c_recv(i2c, I2C_DEV, &data);
+			if (err < 0) {
+				dprintk(SAA716x_ERROR, 1, "Data receive failed");
+				goto exit;
+			}
+			dprintk(SAA716x_DEBUG, 0, "    <R %04x> 0x%02x\n\n", i, data);
+			buf[i] = data;
+		}
+
+		len -= bytes;
+		buf += bytes;
+		bytes = i2c->block_size;
+	}
+
+	return 0;
+
+exit:
+	dprintk(SAA716x_ERROR, 1, "Error reading data, err=%d", err);
+	return err;
+}
+
+static int saa716x_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)
+{
+	struct saa716x_i2c *i2c		= i2c_get_adapdata(adapter);
+	struct saa716x_dev *saa716x	= i2c->saa716x;
+
+	u32 DEV = SAA716x_I2C_BUS(i2c->i2c_dev);
+	int i, j, err = 0;
+	int t;
+
+	dprintk(SAA716x_DEBUG, 0, "\n");
+	dprintk(SAA716x_DEBUG, 1, "Bus(%02x) I2C transfer", DEV);
+	mutex_lock(&i2c->i2c_lock);
+
+	for (t = 0; t < 3; t++) {
+		for (i = 0; i < num; i++) {
+			if (msgs[i].flags & I2C_M_RD)
+				err = saa716x_i2c_read_msg(i2c, DEV,
+					msgs[i].addr, msgs[i].buf, msgs[i].len,
+					i == (num - 1));
+			else
+				err = saa716x_i2c_write_msg(i2c, DEV,
+					msgs[i].addr, msgs[i].buf, msgs[i].len,
+					i == (num - 1));
+			if (err < 0) {
+				err = -EIO;
+				goto retry;
+			}
+		}
+		break;
+retry:
+		dprintk(SAA716x_INFO, 1, "Error in Transfer, try %d", t);
+		for (i = 0; i < num; i++) {
+			dprintk(SAA716x_INFO, 1, "msg %d, addr = 0x%02x, len=%d, flags=0x%x",
+				i, msgs[i].addr, msgs[i].len, msgs[i].flags);
+			if (!(msgs[i].flags & I2C_M_RD)) {
+				for (j = 0; j < msgs[i].len; j++) {
+					dprintk(SAA716x_INFO, 1, "    <W %04x> 0x%02x",
+						j, msgs[i].buf[j]);
+				}
+			}
+		}
+		err = saa716x_i2c_hwinit(i2c, DEV);
+		if (err < 0) {
+			dprintk(SAA716x_ERROR, 1, "Error Reinit");
+			err = -EIO;
+			goto bail_out;
+		}
+	}
+
+	mutex_unlock(&i2c->i2c_lock);
+	return num;
+
+bail_out:
+	dprintk(SAA716x_ERROR, 1, "ERROR: Bailing out <%d>", err);
+	mutex_unlock(&i2c->i2c_lock);
+	return err;
+}
+
+static u32 saa716x_i2c_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm saa716x_algo = {
+	.master_xfer	= saa716x_i2c_xfer,
+	.functionality	= saa716x_i2c_func,
+};
+
+struct saa716x_i2cvec {
+	u32			vector;
+	enum saa716x_edge	edge;
+	irqreturn_t (*handler)(int irq, void *dev_id);
+};
+
+static const struct saa716x_i2cvec i2c_vec[] = {
+	{
+		.vector		= I2CINT_0,
+		.edge		= SAA716x_EDGE_RISING,
+		.handler	= saa716x_i2c_irq
+	}, {
+		.vector 	= I2CINT_1,
+		.edge		= SAA716x_EDGE_RISING,
+		.handler	= saa716x_i2c_irq
+	}
+};
+
+int __devinit saa716x_i2c_init(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev		= saa716x->pdev;
+	struct saa716x_i2c *i2c		= saa716x->i2c;
+	struct i2c_adapter *adapter	= NULL;
+
+	int i, err = 0;
+
+	dprintk(SAA716x_DEBUG, 1, "Initializing SAA%02x I2C Core",
+		saa716x->pdev->device);
+
+	for (i = 0; i < SAA716x_I2C_ADAPTERS; i++) {
+
+		mutex_init(&i2c->i2c_lock);
+
+		init_waitqueue_head(&i2c->i2c_wq);
+		i2c->i2c_op = 0;
+
+		i2c->i2c_dev	= i;
+		i2c->i2c_rate	= saa716x->config->i2c_rate;
+		i2c->i2c_mode	= saa716x->config->i2c_mode;
+		adapter		= &i2c->i2c_adapter;
+
+		if (i2c->i2c_mode == SAA716x_I2C_MODE_IRQ_BUFFERED)
+			i2c->block_size = 8;
+		else
+			i2c->block_size = 1;
+
+		if (adapter != NULL) {
+
+			i2c_set_adapdata(adapter, i2c);
+
+			strcpy(adapter->name, SAA716x_I2C_ADAPTER(i));
+
+			adapter->owner		= THIS_MODULE;
+			adapter->algo		= &saa716x_algo;
+			adapter->algo_data 	= NULL;
+			adapter->timeout	= 500; /* FIXME ! */
+			adapter->retries	= 3; /* FIXME ! */
+			adapter->dev.parent	= &pdev->dev;
+
+			dprintk(SAA716x_DEBUG, 1, "Initializing adapter (%d) %s",
+				i,
+				adapter->name);
+
+			err = i2c_add_adapter(adapter);
+			if (err < 0) {
+				dprintk(SAA716x_ERROR, 1, "Adapter (%d) %s init failed", i, adapter->name);
+				goto exit;
+			}
+
+			i2c->saa716x = saa716x;
+			saa716x_i2c_hwinit(i2c, SAA716x_I2C_BUS(i));
+		}
+		i2c++;
+	}
+
+	if (saa716x->config->i2c_mode >= SAA716x_I2C_MODE_IRQ) {
+		SAA716x_EPWR(MSI, MSI_INT_ENA_SET_H, MSI_INT_I2CINT_0);
+		SAA716x_EPWR(MSI, MSI_INT_ENA_SET_H, MSI_INT_I2CINT_1);
+	}
+
+	dprintk(SAA716x_DEBUG, 1, "SAA%02x I2C Core succesfully initialized",
+		saa716x->pdev->device);
+
+	return 0;
+exit:
+	return err;
+}
+EXPORT_SYMBOL_GPL(saa716x_i2c_init);
+
+int __devexit saa716x_i2c_exit(struct saa716x_dev *saa716x)
+{
+	struct saa716x_i2c *i2c		= saa716x->i2c;
+	struct i2c_adapter *adapter	= NULL;
+	int i, err = 0;
+
+	dprintk(SAA716x_DEBUG, 1, "Removing SAA%02x I2C Core", saa716x->pdev->device);
+
+	for (i = 0; i < SAA716x_I2C_ADAPTERS; i++) {
+
+		adapter = &i2c->i2c_adapter;
+#if 0
+		saa716x_remove_irqvector(saa716x, i2c_vec[i].vector);
+#endif
+		saa716x_i2c_hwdeinit(i2c, SAA716x_I2C_BUS(i));
+		dprintk(SAA716x_DEBUG, 1, "Removing adapter (%d) %s", i, adapter->name);
+
+		err = i2c_del_adapter(adapter);
+		if (err < 0) {
+			dprintk(SAA716x_ERROR, 1, "Adapter (%d) %s remove failed", i, adapter->name);
+			goto exit;
+		}
+		i2c++;
+	}
+	dprintk(SAA716x_DEBUG, 1, "SAA%02x I2C Core succesfully removed", saa716x->pdev->device);
+
+	return 0;
+
+exit:
+	return err;
+}
+EXPORT_SYMBOL_GPL(saa716x_i2c_exit);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,52 @@
+#ifndef __SAA716x_I2C_H
+#define __SAA716x_I2C_H
+
+#define SAA716x_I2C_ADAPTERS	2
+
+#define SAA716x_I2C_ADAPTER(__dev) ((	\
+	(__dev == 1) ?			\
+		"SAA716x I2C Core 1" :	\
+		"SAA716x I2C Core 0"))
+
+#define SAA716x_I2C_BUS(__x) ((__x == 1) ? 0x0000c000 : 0x0000b000)
+
+#define SAA716x_I2C_BUS_A		0x01
+#define SAA716x_I2C_BUS_B		0x00
+
+struct saa716x_dev;
+
+enum saa716x_i2c_rate {
+	SAA716x_I2C_RATE_400 = 1,
+	SAA716x_I2C_RATE_100,
+};
+
+enum saa716x_i2c_mode {
+	SAA716x_I2C_MODE_POLLING = 0,
+	SAA716x_I2C_MODE_IRQ,
+	SAA716x_I2C_MODE_IRQ_BUFFERED
+};
+
+struct saa716x_i2c {
+	struct i2c_adapter		i2c_adapter;
+	struct mutex			i2c_lock;
+	struct saa716x_dev		*saa716x;
+	u8				i2c_dev;
+
+	enum saa716x_i2c_rate		i2c_rate; /* run time */
+	enum saa716x_i2c_mode		i2c_mode;
+	u32				block_size; /* block size for buffered
+						       mode, 1 otherwise */
+	u32				i2c_stat;
+
+	u32				stat_tx_prior;
+	u32				stat_tx_done;
+	wait_queue_head_t		i2c_wq;
+	int				i2c_op;
+};
+
+extern int saa716x_i2c_init(struct saa716x_dev *saa716x);
+extern int saa716x_i2c_exit(struct saa716x_dev *saa716x);
+extern void saa716x_i2cint_disable(struct saa716x_dev *saa716x);
+extern int saa716x_i2c_irqevent(struct saa716x_dev *saa716x, u8 bus);
+
+#endif /* __SAA716x_I2C_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_i2c_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_i2c_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,145 @@
+#ifndef __SAA716x_I2C_REG_H
+#define __SAA716x_I2C_REG_H
+
+/* -------------- I2C Registers -------------- */
+
+#define RX_FIFO				0x000
+#define I2C_RX_BYTE			(0x000000ff <<  0)
+
+#define TX_FIFO				0x000
+#define I2C_STOP_BIT			(0x00000001 <<  9)
+#define I2C_START_BIT			(0x00000001 <<  8)
+#define I2C_TX_BYTE			(0x000000ff <<  0)
+
+#define I2C_STATUS			0x008
+#define I2C_TRANSMIT			(0x00000001 << 11)
+#define I2C_RECEIVE			(0x00000001 << 10)
+#define I2C_TRANSMIT_S_PROG		(0x00000001 <<  9)
+#define I2C_TRANSMIT_S_CLEAR		(0x00000001 <<  8)
+#define I2C_TRANSMIT_PROG		(0x00000001 <<  7)
+#define I2C_TRANSMIT_CLEAR		(0x00000001 <<  6)
+#define I2C_RECEIVE_PROG		(0x00000001 <<  5)
+#define I2C_RECEIVE_CLEAR		(0x00000001 <<  4)
+#define I2C_SDA_LINE			(0x00000001 <<  3)
+#define I2C_SCL_LINE			(0x00000001 <<  2)
+#define I2C_START_STOP_FLAG		(0x00000001 <<  1)
+#define I2C_MODE_STATUS			(0x00000001 <<  0)
+
+#define I2C_CONTROL			0x00c
+#define I2C_SCL_CONTROL			(0x00000001 <<  7)
+#define I2C_SDA_CONTROL			(0x00000001 <<  6)
+#define I2C_RECEIVE_PROTECT		(0x00000001 <<  5)
+#define I2C_RECEIVE_PRO_READ		(0x00000001 <<  4)
+#define I2C_TRANS_SELF_CLEAR		(0x00000001 <<  3)
+#define I2C_TRANS_S_SELF_CLEAR		(0x00000001 <<  2)
+#define I2C_SLAVE_ADDR_10BIT		(0x00000001 <<  1)
+#define I2C_RESET			(0x00000001 <<  0)
+
+#define I2C_CLOCK_DIVISOR_HIGH		0x010
+#define I2C_CLOCK_HIGH			(0x0000ffff <<  0)
+
+#define I2C_CLOCK_DIVISOR_LOW		0x014
+#define I2C_CLOCK_LOW			(0x0000ffff <<  0)
+
+#define I2C_RX_LEVEL			0x01c
+#define I2C_RECEIVE_RANGE		(0x0000007f <<  0)
+
+#define I2C_TX_LEVEL			0x020
+#define I2C_TRANSMIT_RANGE		(0x0000007f <<  0)
+
+#define I2C_SDA_HOLD			0x028
+#define I2C_HOLD_TIME			(0x0000007f <<  0)
+
+#define MODULE_CONF			0xfd4
+#define INT_CLR_ENABLE			0xfd8
+#define I2C_CLR_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_CLR_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_CLR_ENABLE_RFDA		(0x00000001 << 10)
+#define I2C_CLR_ENABLE_RFF		(0x00000001 <<  9)
+#define I2C_CLR_ENABLE_STDR		(0x00000001 <<  8)
+#define I2C_CLR_ENABLE_MTDR		(0x00000001 <<  7)
+#define I2C_CLR_ENABLE_IBE		(0x00000001 <<  6)
+#define I2C_CLR_ENABLE_MSMC		(0x00000001 <<  5)
+#define I2C_CLR_ENABLE_SRSD		(0x00000001 <<  4)
+#define I2C_CLR_ENABLE_STSD		(0x00000001 <<  3)
+#define I2C_CLR_ENABLE_MTNA		(0x00000001 <<  2)
+#define I2C_CLR_ENABLE_MAF		(0x00000001 <<  1)
+#define I2C_CLR_ENABLE_MTD		(0x00000001 <<  0)
+
+#define INT_SET_ENABLE			0xfdc
+#define I2C_SET_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_SET_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_SET_ENABLE_RFDA		(0x00000001 << 10)
+#define I2C_SET_ENABLE_RFF		(0x00000001 <<  9)
+#define I2C_SET_ENABLE_STDR		(0x00000001 <<  8)
+#define I2C_SET_ENABLE_MTDR		(0x00000001 <<  7)
+#define I2C_SET_ENABLE_IBE		(0x00000001 <<  6)
+#define I2C_SET_ENABLE_MSMC		(0x00000001 <<  5)
+#define I2C_SET_ENABLE_SRSD		(0x00000001 <<  4)
+#define I2C_SET_ENABLE_STSD		(0x00000001 <<  3)
+#define I2C_SET_ENABLE_MTNA		(0x00000001 <<  2)
+#define I2C_SET_ENABLE_MAF		(0x00000001 <<  1)
+#define I2C_SET_ENABLE_MTD		(0x00000001 <<  0)
+
+#define INT_STATUS			0xfe0
+#define I2C_INTERRUPT_STFNF		(0x00000001 << 12)
+#define I2C_INTERRUPT_MTFNF		(0x00000001 << 11)
+#define I2C_INTERRUPT_RFDA		(0x00000001 << 10)
+#define I2C_INTERRUPTE_RFF		(0x00000001 <<  9)
+#define I2C_SLAVE_INTERRUPT_STDR	(0x00000001 <<  8)
+#define I2C_MASTER_INTERRUPT_MTDR	(0x00000001 <<  7)
+#define I2C_ERROR_IBE			(0x00000001 <<  6)
+#define I2C_MODE_CHANGE_INTER_MSMC	(0x00000001 <<  5)
+#define I2C_SLAVE_RECEIVE_INTER_SRSD	(0x00000001 <<  4)
+#define I2C_SLAVE_TRANSMIT_INTER_STSD	(0x00000001 <<  3)
+#define I2C_ACK_INTER_MTNA		(0x00000001 <<  2)
+#define I2C_FAILURE_INTER_MAF		(0x00000001 <<  1)
+#define I2C_INTERRUPT_MTD		(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define I2C_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_ENABLE_RFDA			(0x00000001 << 10)
+#define I2C_ENABLE_RFF			(0x00000001 <<  9)
+#define I2C_ENABLE_STDR			(0x00000001 <<  8)
+#define I2C_ENABLE_MTDR			(0x00000001 <<  7)
+#define I2C_ENABLE_IBE			(0x00000001 <<  6)
+#define I2C_ENABLE_MSMC			(0x00000001 <<  5)
+#define I2C_ENABLE_SRSD			(0x00000001 <<  4)
+#define I2C_ENABLE_STSD			(0x00000001 <<  3)
+#define I2C_ENABLE_MTNA			(0x00000001 <<  2)
+#define I2C_ENABLE_MAF			(0x00000001 <<  1)
+#define I2C_ENABLE_MTD			(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define I2C_CLR_STATUS_STFNF		(0x00000001 << 12)
+#define I2C_CLR_STATUS_MTFNF		(0x00000001 << 11)
+#define I2C_CLR_STATUS_RFDA		(0x00000001 << 10)
+#define I2C_CLR_STATUS_RFF		(0x00000001 <<  9)
+#define I2C_CLR_STATUS_STDR		(0x00000001 <<  8)
+#define I2C_CLR_STATUS_MTDR		(0x00000001 <<  7)
+#define I2C_CLR_STATUS_IBE		(0x00000001 <<  6)
+#define I2C_CLR_STATUS_MSMC		(0x00000001 <<  5)
+#define I2C_CLR_STATUS_SRSD		(0x00000001 <<  4)
+#define I2C_CLR_STATUS_STSD		(0x00000001 <<  3)
+#define I2C_CLR_STATUS_MTNA		(0x00000001 <<  2)
+#define I2C_CLR_STATUS_MAF		(0x00000001 <<  1)
+#define I2C_CLR_STATIS_MTD		(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define I2C_SET_STATUS_STFNF		(0x00000001 << 12)
+#define I2C_SET_STATUS_MTFNF		(0x00000001 << 11)
+#define I2C_SET_STATUS_RFDA		(0x00000001 << 10)
+#define I2C_SET_STATUS_RFF		(0x00000001 <<  9)
+#define I2C_SET_STATUS_STDR		(0x00000001 <<  8)
+#define I2C_SET_STATUS_MTDR		(0x00000001 <<  7)
+#define I2C_SET_STATUS_IBE		(0x00000001 <<  6)
+#define I2C_SET_STATUS_MSMC		(0x00000001 <<  5)
+#define I2C_SET_STATUS_SRSD		(0x00000001 <<  4)
+#define I2C_SET_STATUS_STSD		(0x00000001 <<  3)
+#define I2C_SET_STATUS_MTNA		(0x00000001 <<  2)
+#define I2C_SET_STATUS_MAF		(0x00000001 <<  1)
+#define I2C_SET_STATIS_MTD		(0x00000001 <<  0)
+
+
+#endif /* __SAA716x_I2C_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_mod.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_mod.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_mod.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_mod.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,50 @@
+#ifndef __SAA716x_MOD_H
+#define __SAA716x_MOD_H
+
+/* BAR = 17 bits */
+/*
+	VI0	0x00000000
+	VI1	0x00001000
+	FGPI0	0x00002000
+	FGPI1	0x00003000
+	FGPI2	0x00004000
+	FGPI3	0x00005000
+	AI0	0x00006000
+	AI1	0x00007000
+	BAM	0x00008000
+	MMU	0x00009000
+	MSI	0x0000a000
+	I2C_B	0x0000b000
+	I2C_A	0x0000c000
+	SPI	0x0000d000
+	GPIO	0x0000e000
+	PHI_0	0x0000f000
+	CGU	0x00013000
+	DCS	0x00014000
+	GREG	0x00012000
+
+	PHI_1	0x00020000
+*/
+
+#define VI0				0x00000000
+#define VI1				0x00001000
+#define FGPI0				0x00002000
+#define FGPI1				0x00003000
+#define FGPI2				0x00004000
+#define FGPI3				0x00005000
+#define AI0				0x00006000
+#define AI1				0x00007000
+#define BAM				0x00008000
+#define MMU				0x00009000
+#define MSI				0x0000a000
+#define I2C_B				0x0000b000
+#define I2C_A				0x0000c000
+#define SPI				0x0000d000
+#define GPIO				0x0000e000
+#define	PHI_0				0x0000f000
+#define GREG				0x00012000
+#define CGU				0x00013000
+#define DCS				0x00014000
+#define PHI_1				0x00020000
+
+#endif /* __SAA716x_MOD_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_msi.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_msi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,479 @@
+#include <linux/delay.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_msi_reg.h"
+#include "saa716x_msi.h"
+#include "saa716x_spi.h"
+
+#include "saa716x_priv.h"
+
+#define SAA716x_MSI_VECTORS		50
+
+static const char *vector_name[] = {
+	"TAGACK_VI0_0",
+	"TAGACK_VI0_1",
+	"TAGACK_VI0_2",
+	"TAGACK_VI1_0",
+	"TAGACK_VI1_1",
+	"TAGACK_VI1_2",
+	"TAGACK_FGPI_0",
+	"TAGACK_FGPI_1",
+	"TAGACK_FGPI_2",
+	"TAGACK_FGPI_3",
+	"TAGACK_AI_0",
+	"TAGACK_AI_1",
+	"OVRFLW_VI0_0",
+	"OVRFLW_VI0_1",
+	"OVRFLW_VI0_2",
+	"OVRFLW_VI1_0",
+	"OVRFLW_VI1_1",
+	"OVRFLW_VI1_2",
+	"OVRFLW_FGPI_O",
+	"OVRFLW_FGPI_1",
+	"OVRFLW_FGPI_2",
+	"OVRFLW_FGPI_3",
+	"OVRFLW_AI_0",
+	"OVRFLW_AI_1",
+	"AVINT_VI0",
+	"AVINT_VI1",
+	"AVINT_FGPI_0",
+	"AVINT_FGPI_1",
+	"AVINT_FGPI_2",
+	"AVINT_FGPI_3",
+	"AVINT_AI_0",
+	"AVINT_AI_1",
+	"UNMAPD_TC_INT",
+	"EXTINT_0",
+	"EXTINT_1",
+	"EXTINT_2",
+	"EXTINT_3",
+	"EXTINT_4",
+	"EXTINT_5",
+	"EXTINT_6",
+	"EXTINT_7",
+	"EXTINT_8",
+	"EXTINT_9",
+	"EXTINT_10",
+	"EXTINT_11",
+	"EXTINT_12",
+	"EXTINT_13",
+	"EXTINT_14",
+	"EXTINT_15",
+	"I2CINT_0",
+	"I2CINT_1"
+};
+
+static u32 MSI_CONFIG_REG[51] = {
+	MSI_CONFIG0,
+	MSI_CONFIG1,
+	MSI_CONFIG2,
+	MSI_CONFIG3,
+	MSI_CONFIG4,
+	MSI_CONFIG5,
+	MSI_CONFIG6,
+	MSI_CONFIG7,
+	MSI_CONFIG8,
+	MSI_CONFIG9,
+	MSI_CONFIG10,
+	MSI_CONFIG11,
+	MSI_CONFIG12,
+	MSI_CONFIG13,
+	MSI_CONFIG14,
+	MSI_CONFIG15,
+	MSI_CONFIG16,
+	MSI_CONFIG17,
+	MSI_CONFIG18,
+	MSI_CONFIG19,
+	MSI_CONFIG20,
+	MSI_CONFIG21,
+	MSI_CONFIG22,
+	MSI_CONFIG23,
+	MSI_CONFIG24,
+	MSI_CONFIG25,
+	MSI_CONFIG26,
+	MSI_CONFIG27,
+	MSI_CONFIG28,
+	MSI_CONFIG29,
+	MSI_CONFIG30,
+	MSI_CONFIG31,
+	MSI_CONFIG32,
+	MSI_CONFIG33,
+	MSI_CONFIG34,
+	MSI_CONFIG35,
+	MSI_CONFIG36,
+	MSI_CONFIG37,
+	MSI_CONFIG38,
+	MSI_CONFIG39,
+	MSI_CONFIG40,
+	MSI_CONFIG41,
+	MSI_CONFIG42,
+	MSI_CONFIG43,
+	MSI_CONFIG44,
+	MSI_CONFIG45,
+	MSI_CONFIG46,
+	MSI_CONFIG47,
+	MSI_CONFIG48,
+	MSI_CONFIG49,
+	MSI_CONFIG50
+};
+
+int saa716x_msi_event(struct saa716x_dev *saa716x, u32 stat_l, u32 stat_h)
+{
+	dprintk(SAA716x_DEBUG, 0, "%s: MSI event ", __func__);
+
+	if (stat_l & MSI_INT_TAGACK_VI0_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[0]);
+
+	if (stat_l & MSI_INT_TAGACK_VI0_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[1]);
+
+	if (stat_l & MSI_INT_TAGACK_VI0_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[2]);
+
+	if (stat_l & MSI_INT_TAGACK_VI1_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[3]);
+
+	if (stat_l & MSI_INT_TAGACK_VI1_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[4]);
+
+	if (stat_l & MSI_INT_TAGACK_VI1_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[5]);
+
+	if (stat_l & MSI_INT_TAGACK_FGPI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[6]);
+
+	if (stat_l & MSI_INT_TAGACK_FGPI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[7]);
+
+	if (stat_l & MSI_INT_TAGACK_FGPI_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[8]);
+
+	if (stat_l & MSI_INT_TAGACK_FGPI_3)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[9]);
+
+	if (stat_l & MSI_INT_TAGACK_AI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[10]);
+
+	if (stat_l & MSI_INT_TAGACK_AI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[11]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI0_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[12]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI0_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[13]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI0_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[14]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI1_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[15]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI1_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[16]);
+
+	if (stat_l & MSI_INT_OVRFLW_VI1_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[17]);
+
+	if (stat_l & MSI_INT_OVRFLW_FGPI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[18]);
+
+	if (stat_l & MSI_INT_OVRFLW_FGPI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[19]);
+
+	if (stat_l & MSI_INT_OVRFLW_FGPI_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[20]);
+
+	if (stat_l & MSI_INT_OVRFLW_FGPI_3)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[21]);
+
+	if (stat_l & MSI_INT_OVRFLW_AI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[22]);
+
+	if (stat_l & MSI_INT_OVRFLW_AI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[23]);
+
+	if (stat_l & MSI_INT_AVINT_VI0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[24]);
+
+	if (stat_l & MSI_INT_AVINT_VI1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[25]);
+
+	if (stat_l & MSI_INT_AVINT_FGPI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[26]);
+
+	if (stat_l & MSI_INT_AVINT_FGPI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[27]);
+
+	if (stat_l & MSI_INT_AVINT_FGPI_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[28]);
+
+	if (stat_l & MSI_INT_AVINT_FGPI_3)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[29]);
+
+	if (stat_l & MSI_INT_AVINT_AI_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[30]);
+
+	if (stat_l & MSI_INT_AVINT_AI_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[31]);
+
+	if (stat_h & MSI_INT_UNMAPD_TC_INT)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[32]);
+
+	if (stat_h & MSI_INT_EXTINT_0)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[33]);
+
+	if (stat_h & MSI_INT_EXTINT_1)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[34]);
+
+	if (stat_h & MSI_INT_EXTINT_2)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[35]);
+
+	if (stat_h & MSI_INT_EXTINT_3)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[36]);
+
+	if (stat_h & MSI_INT_EXTINT_4)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[37]);
+
+	if (stat_h & MSI_INT_EXTINT_5)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[38]);
+
+	if (stat_h & MSI_INT_EXTINT_6)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[39]);
+
+	if (stat_h & MSI_INT_EXTINT_7)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[40]);
+
+	if (stat_h & MSI_INT_EXTINT_8)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[41]);
+
+	if (stat_h & MSI_INT_EXTINT_9)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[42]);
+
+	if (stat_h & MSI_INT_EXTINT_10)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[43]);
+
+	if (stat_h & MSI_INT_EXTINT_11)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[44]);
+
+	if (stat_h & MSI_INT_EXTINT_12)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[45]);
+
+	if (stat_h & MSI_INT_EXTINT_13)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[46]);
+
+	if (stat_h & MSI_INT_EXTINT_14)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[47]);
+
+	if (stat_h & MSI_INT_EXTINT_15)
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[48]);
+
+	if (stat_h & MSI_INT_I2CINT_0) {
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[49]);
+		saa716x_i2c_irqevent(saa716x, 0);
+	}
+
+	if (stat_h & MSI_INT_I2CINT_1) {
+		dprintk(SAA716x_DEBUG, 0, "<%s> ", vector_name[50]);
+		saa716x_i2c_irqevent(saa716x, 1);
+	}
+
+	dprintk(SAA716x_DEBUG, 0, "\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_msi_event);
+
+int saa716x_msi_init(struct saa716x_dev *saa716x)
+{
+	u32 ena_l, ena_h, sta_l, sta_h, mid;
+	int i;
+
+	dprintk(SAA716x_DEBUG, 1, "Initializing MSI ..");
+	saa716x->handlers = 0;
+
+	/* get module id & version */
+	mid = SAA716x_EPRD(MSI, MSI_MODULE_ID);
+	if (mid != 0x30100)
+		dprintk(SAA716x_ERROR, 1, "MSI Id<%04x> is not supported", mid);
+
+	/* let HW take care of MSI race */
+	SAA716x_EPWR(MSI, MSI_DELAY_TIMER, 0x0);
+
+	/* INTA Polarity: Active High */
+	SAA716x_EPWR(MSI, MSI_INTA_POLARITY, MSI_INTA_POLARITY_HIGH);
+
+	/*
+	 * IRQ Edge Rising: 25:24 = 0x01
+	 * Traffic Class: 18:16 = 0x00
+	 * MSI ID: 4:0 = 0x00
+	 */
+	for (i = 0; i < SAA716x_MSI_VECTORS; i++)
+		SAA716x_EPWR(MSI, MSI_CONFIG_REG[i], MSI_INT_POL_EDGE_RISE);
+
+	/* get Status */
+	ena_l = SAA716x_EPRD(MSI, MSI_INT_ENA_L);
+	ena_h = SAA716x_EPRD(MSI, MSI_INT_ENA_H);
+	sta_l = SAA716x_EPRD(MSI, MSI_INT_STATUS_L);
+	sta_h = SAA716x_EPRD(MSI, MSI_INT_STATUS_H);
+
+	/* disable and clear enabled and asserted IRQ's */
+	if (sta_l)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, sta_l);
+
+	if (sta_h)
+		SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_H, sta_h);
+
+	if (ena_l)
+		SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_L, ena_l);
+
+	if (ena_h)
+		SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_H, ena_h);
+
+	msleep(5);
+
+	/* Check IRQ's really disabled */
+	ena_l = SAA716x_EPRD(MSI, MSI_INT_ENA_L);
+	ena_h = SAA716x_EPRD(MSI, MSI_INT_ENA_H);
+	sta_l = SAA716x_EPRD(MSI, MSI_INT_STATUS_L);
+	sta_h = SAA716x_EPRD(MSI, MSI_INT_STATUS_H);
+
+	if ((ena_l == 0) && (ena_h == 0) && (sta_l == 0) && (sta_h == 0)) {
+		dprintk(SAA716x_DEBUG, 1, "Interrupts ena_l <%02x> ena_h <%02x> sta_l <%02x> sta_h <%02x>",
+			ena_l, ena_h, sta_l, sta_h);
+
+		return 0;
+	} else {
+		dprintk(SAA716x_DEBUG, 1, "I/O error");
+		return -EIO;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_msi_init);
+
+void saa716x_msiint_disable(struct saa716x_dev *saa716x)
+{
+	dprintk(SAA716x_DEBUG, 1, "Disabling Interrupts ...");
+
+	SAA716x_EPWR(MSI, MSI_INT_ENA_L, 0x0);
+	SAA716x_EPWR(MSI, MSI_INT_ENA_H, 0x0);
+	SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, 0xffffffff);
+	SAA716x_EPWR(MSI, MSI_INT_STATUS_CLR_L, 0x0000ffff);
+}
+EXPORT_SYMBOL_GPL(saa716x_msiint_disable);
+
+
+/* Map the given vector Id to the hardware bitmask. */
+static void saa716x_map_vector(struct saa716x_dev *saa716x, int vector, u32 *mask_l, u32 *mask_h)
+{
+	u32 tmp = 1;
+
+	if (vector < 32) {
+		/* Bits 0 - 31 */
+		tmp   <<= vector;
+		*mask_l = tmp;
+		*mask_h	= 0;
+	} else {
+		/* Bits 32 - 48 */
+		tmp <<= vector - 32;
+		*mask_l = 0;
+		*mask_h = tmp;
+	}
+}
+
+int saa716x_add_irqvector(struct saa716x_dev *saa716x,
+			  int vector,
+			  enum saa716x_edge edge,
+			  irqreturn_t (*handler)(int irq, void *dev_id),
+			  char *desc)
+{
+	struct saa716x_msix_entry *msix_handler = NULL;
+
+	u32 config, mask_l, mask_h, ena_l, ena_h;
+
+	BUG_ON(saa716x == NULL);
+	BUG_ON(vector > SAA716x_MSI_VECTORS);
+	dprintk(SAA716x_DEBUG, 1, "Adding Vector %d <%s>", vector, vector_name[vector]);
+
+	if ((vector > 32) && (vector < 49)) {
+		config = SAA716x_EPRD(MSI, MSI_CONFIG_REG[vector]);
+		config &= 0xfcffffff; /* clear polarity */
+
+		switch (edge) {
+		default:
+		case SAA716x_EDGE_RISING:
+			SAA716x_EPWR(MSI, MSI_CONFIG_REG[vector], config | 0x01000000);
+			break;
+
+		case SAA716x_EDGE_FALLING:
+			SAA716x_EPWR(MSI, MSI_CONFIG_REG[vector], config | 0x02000000);
+			break;
+
+		case SAA716x_EDGE_ANY:
+			SAA716x_EPWR(MSI, MSI_CONFIG_REG[vector], config | 0x03000000);
+			break;
+		}
+	}
+
+	saa716x_map_vector(saa716x, vector, &mask_l, &mask_h);
+
+	/* add callback */
+	msix_handler = &saa716x->saa716x_msix_handler[saa716x->handlers];
+	strcpy(msix_handler->desc, desc);
+	msix_handler->vector = vector;
+	msix_handler->handler = handler;
+	saa716x->handlers++;
+
+	SAA716x_EPWR(MSI, MSI_INT_ENA_SET_L, mask_l);
+	SAA716x_EPWR(MSI, MSI_INT_ENA_SET_H, mask_h);
+
+	ena_l = SAA716x_EPRD(MSI, MSI_INT_ENA_L);
+	ena_h = SAA716x_EPRD(MSI, MSI_INT_ENA_H);
+	dprintk(SAA716x_DEBUG, 1, "Interrupts ena_l <%02x> ena_h <%02x>", ena_l, ena_h);
+
+	return 0;
+}
+
+int saa716x_remove_irqvector(struct saa716x_dev *saa716x, int vector)
+{
+	struct saa716x_msix_entry *msix_handler;
+	int i;
+	u32 mask_l, mask_h;
+
+	msix_handler = &saa716x->saa716x_msix_handler[saa716x->handlers];
+	BUG_ON(msix_handler == NULL);
+	dprintk(SAA716x_DEBUG, 1, "Removing Vector %d <%s>", vector, vector_name[vector]);
+
+	/* loop through the registered handlers */
+	for (i = 0; i < saa716x->handlers; i++) {
+
+		/* we found our vector */
+		if (msix_handler->vector == vector) {
+			BUG_ON(msix_handler->handler == NULL); /* no handler yet */
+			dprintk(SAA716x_DEBUG, 1, "Vector %d <%s> removed",
+				msix_handler->vector,
+				msix_handler->desc);
+
+			/* check whether it is already released */
+			if (msix_handler->handler) {
+				msix_handler->vector = 0;
+				msix_handler->handler = NULL;
+				saa716x->handlers--;
+			}
+		}
+	}
+
+	saa716x_map_vector(saa716x, vector, &mask_l, &mask_h);
+
+	/* disable vector */
+	SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_L, mask_l);
+	SAA716x_EPWR(MSI, MSI_INT_ENA_CLR_H, mask_h);
+
+	return 0;
+}
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_msi.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_msi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,87 @@
+#ifndef __SAA716x_MSI_H
+#define __SAA716x_MSI_H
+
+#define	TAGACK_VI0_0		0x000
+#define	TAGACK_VI0_1		0x001
+#define	TAGACK_VI0_2		0x002
+#define	TAGACK_VI1_0		0x003
+#define	TAGACK_VI1_1		0x004
+#define	TAGACK_VI1_2		0x005
+#define	TAGACK_FGPI_0		0x006
+#define	TAGACK_FGPI_1		0x007
+#define	TAGACK_FGPI_2		0x008
+#define	TAGACK_FGPI_3		0x009
+#define	TAGACK_AI_0		0x00a
+#define	TAGACK_AI_1		0x00b
+#define	OVRFLW_VI0_0		0x00c
+#define	OVRFLW_VI0_1		0x00d
+#define	OVRFLW_VI0_2		0x00e
+#define	OVRFLW_VI1_0		0x00f
+#define	OVRFLW_VI1_1		0x010
+#define	OVRFLW_VI1_2		0x011
+#define	OVRFLW_FGPI_O		0x012
+#define	OVRFLW_FGPI_1		0x013
+#define	OVRFLW_FGPI_2		0x014
+#define	OVRFLW_FGPI_3		0x015
+#define	OVRFLW_AI_0		0x016
+#define	OVRFLW_AI_1		0x017
+#define	AVINT_VI0		0x018
+#define	AVINT_VI1		0x019
+#define	AVINT_FGPI_0		0x01a
+#define	AVINT_FGPI_1		0x01b
+#define	AVINT_FGPI_2		0x01c
+#define	AVINT_FGPI_3		0x01d
+#define	AVINT_AI_0		0x01e
+#define	AVINT_AI_1		0x01f
+#define	UNMAPD_TC_INT		0x020
+#define	EXTINT_0		0x021
+#define	EXTINT_1		0x022
+#define	EXTINT_2		0x023
+#define	EXTINT_3		0x024
+#define	EXTINT_4		0x025
+#define	EXTINT_5		0x026
+#define EXTINT_6		0x027
+#define	EXTINT_7		0x028
+#define	EXTINT_8		0x029
+#define	EXTINT_9		0x02a
+#define	EXTINT_10		0x02b
+#define	EXTINT_11		0x02c
+#define	EXTINT_12		0x02d
+#define	EXTINT_13		0x02e
+#define	EXTINT_14		0x02f
+#define	EXTINT_15		0x030
+#define	I2CINT_0		0x031
+#define	I2CINT_1		0x032
+
+#define SAA716x_TC0		0x000
+#define SAA716x_TC1		0x001
+#define SAA716x_TC2		0x002
+#define SAA716x_TC3		0x003
+#define SAA716x_TC4		0x004
+#define SAA716x_TC5		0x005
+#define SAA716x_TC6		0x006
+#define SAA716x_TC7		0x007
+
+
+enum saa716x_edge {
+	SAA716x_EDGE_RISING	= 1,
+	SAA716x_EDGE_FALLING	= 2,
+	SAA716x_EDGE_ANY	= 3
+};
+
+struct saa716x_dev;
+
+extern int saa716x_msi_event(struct saa716x_dev *saa716x, u32 stat_l, u32 stat_h);
+
+extern int saa716x_msi_init(struct saa716x_dev *saa716x);
+extern void saa716x_msiint_disable(struct saa716x_dev *saa716x);
+
+extern int saa716x_add_irqvector(struct saa716x_dev *saa716x,
+				 int vector,
+				 enum saa716x_edge edge,
+				 irqreturn_t (*handler)(int irq, void *dev_id),
+				 char *desc);
+
+extern int saa716x_remove_irqvector(struct saa716x_dev *saa716x, int vector);
+
+#endif /* __SAA716x_MSI_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_msi_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_msi_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_msi_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,143 @@
+#ifndef __SAA716x_MSI_REG_H
+#define __SAA716x_MSI_REG_H
+
+/* -------------- MSI Registers -------------- */
+
+#define MSI_DELAY_TIMER			0x000
+#define MSI_DELAY_1CLK			(0x00000001 <<  0)
+#define MSI_DELAY_2CLK			(0x00000002 <<  0)
+
+#define MSI_INTA_POLARITY		0x004
+#define MSI_INTA_POLARITY_HIGH		(0x00000001 <<  0)
+
+#define MSI_CONFIG0			0x008
+#define MSI_CONFIG1			0x00c
+#define MSI_CONFIG2			0x010
+#define MSI_CONFIG3			0x014
+#define MSI_CONFIG4			0x018
+#define MSI_CONFIG5			0x01c
+#define MSI_CONFIG6			0x020
+#define MSI_CONFIG7			0x024
+#define MSI_CONFIG8			0x028
+#define MSI_CONFIG9			0x02c
+#define MSI_CONFIG10			0x030
+#define MSI_CONFIG11			0x034
+#define MSI_CONFIG12			0x038
+#define MSI_CONFIG13			0x03c
+#define MSI_CONFIG14			0x040
+#define MSI_CONFIG15			0x044
+#define MSI_CONFIG16			0x048
+#define MSI_CONFIG17			0x04c
+#define MSI_CONFIG18			0x050
+#define MSI_CONFIG19			0x054
+#define MSI_CONFIG20			0x058
+#define MSI_CONFIG21			0x05c
+#define MSI_CONFIG22			0x060
+#define MSI_CONFIG23			0x064
+#define MSI_CONFIG24			0x068
+#define MSI_CONFIG25			0x06c
+#define MSI_CONFIG26			0x070
+#define MSI_CONFIG27			0x074
+#define MSI_CONFIG28			0x078
+#define MSI_CONFIG29			0x07c
+#define MSI_CONFIG30			0x080
+#define MSI_CONFIG31			0x084
+#define MSI_CONFIG32			0x088
+#define MSI_CONFIG33			0x08c
+#define MSI_CONFIG34			0x090
+#define MSI_CONFIG35			0x094
+#define MSI_CONFIG36			0x098
+#define MSI_CONFIG37			0x09c
+#define MSI_CONFIG38			0x0a0
+#define MSI_CONFIG39			0x0a4
+#define MSI_CONFIG40			0x0a8
+#define MSI_CONFIG41			0x0ac
+#define MSI_CONFIG42			0x0b0
+#define MSI_CONFIG43			0x0b4
+#define MSI_CONFIG44			0x0b8
+#define MSI_CONFIG45			0x0bc
+#define MSI_CONFIG46			0x0c0
+#define MSI_CONFIG47			0x0c4
+#define MSI_CONFIG48			0x0c8
+#define MSI_CONFIG49			0x0cc
+#define MSI_CONFIG50			0x0d0
+
+#define MSI_INT_POL_EDGE_RISE		(0x00000001 << 24)
+#define MSI_INT_POL_EDGE_FALL		(0x00000002 << 24)
+#define MSI_INT_POL_EDGE_ANY		(0x00000003 << 24)
+#define MSI_TC				(0x00000007 << 16)
+#define MSI_ID				(0x0000000f <<  0)
+
+#define MSI_INT_STATUS_L		0xfc0
+#define MSI_INT_TAGACK_VI0_0		(0x00000001 <<  0)
+#define MSI_INT_TAGACK_VI0_1		(0x00000001 <<  1)
+#define MSI_INT_TAGACK_VI0_2		(0x00000001 <<  2)
+#define MSI_INT_TAGACK_VI1_0		(0x00000001 <<  3)
+#define MSI_INT_TAGACK_VI1_1		(0x00000001 <<  4)
+#define MSI_INT_TAGACK_VI1_2		(0x00000001 <<  5)
+#define MSI_INT_TAGACK_FGPI_0		(0x00000001 <<  6)
+#define MSI_INT_TAGACK_FGPI_1		(0x00000001 <<  7)
+#define MSI_INT_TAGACK_FGPI_2		(0x00000001 <<  8)
+#define MSI_INT_TAGACK_FGPI_3		(0x00000001 <<  9)
+#define MSI_INT_TAGACK_AI_0		(0x00000001 << 10)
+#define MSI_INT_TAGACK_AI_1		(0x00000001 << 11)
+#define MSI_INT_OVRFLW_VI0_0		(0x00000001 << 12)
+#define MSI_INT_OVRFLW_VI0_1		(0x00000001 << 13)
+#define MSI_INT_OVRFLW_VI0_2		(0x00000001 << 14)
+#define MSI_INT_OVRFLW_VI1_0		(0x00000001 << 15)
+#define MSI_INT_OVRFLW_VI1_1		(0x00000001 << 16)
+#define MSI_INT_OVRFLW_VI1_2		(0x00000001 << 17)
+#define MSI_INT_OVRFLW_FGPI_0		(0x00000001 << 18)
+#define MSI_INT_OVRFLW_FGPI_1		(0x00000001 << 19)
+#define MSI_INT_OVRFLW_FGPI_2		(0x00000001 << 20)
+#define MSI_INT_OVRFLW_FGPI_3		(0x00000001 << 21)
+#define MSI_INT_OVRFLW_AI_0		(0x00000001 << 22)
+#define MSI_INT_OVRFLW_AI_1		(0x00000001 << 23)
+#define MSI_INT_AVINT_VI0		(0x00000001 << 24)
+#define MSI_INT_AVINT_VI1		(0x00000001 << 25)
+#define MSI_INT_AVINT_FGPI_0		(0x00000001 << 26)
+#define MSI_INT_AVINT_FGPI_1		(0x00000001 << 27)
+#define MSI_INT_AVINT_FGPI_2		(0x00000001 << 28)
+#define MSI_INT_AVINT_FGPI_3		(0x00000001 << 29)
+#define MSI_INT_AVINT_AI_0		(0x00000001 << 30)
+#define MSI_INT_AVINT_AI_1		(0x00000001 << 31)
+
+#define MSI_INT_STATUS_H		0xfc4
+#define MSI_INT_UNMAPD_TC_INT		(0x00000001 <<  0)
+#define MSI_INT_EXTINT_0		(0x00000001 <<  1)
+#define MSI_INT_EXTINT_1		(0x00000001 <<  2)
+#define MSI_INT_EXTINT_2		(0x00000001 <<  3)
+#define MSI_INT_EXTINT_3		(0x00000001 <<  4)
+#define MSI_INT_EXTINT_4		(0x00000001 <<  5)
+#define MSI_INT_EXTINT_5		(0x00000001 <<  6)
+#define MSI_INT_EXTINT_6		(0x00000001 <<  7)
+#define MSI_INT_EXTINT_7		(0x00000001 <<  8)
+#define MSI_INT_EXTINT_8		(0x00000001 <<  9)
+#define MSI_INT_EXTINT_9		(0x00000001 << 10)
+#define MSI_INT_EXTINT_10		(0x00000001 << 11)
+#define MSI_INT_EXTINT_11		(0x00000001 << 12)
+#define MSI_INT_EXTINT_12		(0x00000001 << 13)
+#define MSI_INT_EXTINT_13		(0x00000001 << 14)
+#define MSI_INT_EXTINT_14		(0x00000001 << 15)
+#define MSI_INT_EXTINT_15		(0x00000001 << 16)
+#define MSI_INT_I2CINT_0		(0x00000001 << 17)
+#define MSI_INT_I2CINT_1		(0x00000001 << 18)
+
+#define MSI_INT_STATUS_CLR_L		0xfc8
+#define MSI_INT_STATUS_CLR_H		0xfcc
+#define MSI_INT_STATUS_SET_L		0xfd0
+#define MSI_INT_STATUS_SET_H		0xfd4
+#define MSI_INT_ENA_L			0xfd8
+#define MSI_INT_ENA_H			0xfdc
+#define MSI_INT_ENA_CLR_L		0xfe0
+#define MSI_INT_ENA_CLR_H		0xfe4
+#define MSI_INT_ENA_SET_L		0xfe8
+#define MSI_INT_ENA_SET_H		0xfec
+
+#define MSI_SW_RST			0xff0
+#define MSI_SW_RESET			(0x0001 <<  0)
+
+#define MSI_MODULE_ID			0xffc
+
+
+#endif /* __SAA716x_MSI_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_pci.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_pci.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_pci.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,275 @@
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+
+#include "saa716x_spi.h"
+#include "saa716x_msi.h"
+#include "saa716x_priv.h"
+
+#define DRIVER_NAME				"SAA716x Core"
+
+static irqreturn_t saa716x_msi_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int saa716x_enable_msi(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	int err;
+
+	err = pci_enable_msi(pdev);
+	if (err) {
+		dprintk(SAA716x_ERROR, 1, "MSI enable failed <%d>", err);
+		return err;
+	}
+
+	return err;
+}
+
+static int saa716x_enable_msix(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	int i, ret = 0;
+
+	for (i = 0; i < SAA716x_MSI_MAX_VECTORS; i++)
+		saa716x->msix_entries[i].entry = i;
+
+	ret = pci_enable_msix(pdev, saa716x->msix_entries, SAA716x_MSI_MAX_VECTORS);
+	if (ret < 0)
+		dprintk(SAA716x_ERROR, 1, "MSI-X request failed <%d>", ret);
+	if (ret > 0)
+		dprintk(SAA716x_ERROR, 1, "Request exceeds available IRQ's <%d>", ret);
+
+	return ret;
+}
+
+static int saa716x_request_irq(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	struct saa716x_config *config = saa716x->config;
+	int i, ret = 0;
+
+	if (saa716x->int_type == MODE_MSI) {
+		dprintk(SAA716x_DEBUG, 1, "Using MSI mode");
+		ret = saa716x_enable_msi(saa716x);
+	} else if (saa716x->int_type == MODE_MSI_X) {
+		dprintk(SAA716x_DEBUG, 1, "Using MSI-X mode");
+		ret = saa716x_enable_msix(saa716x);
+	}
+
+	if (ret) {
+		dprintk(SAA716x_ERROR, 1, "INT-A Mode");
+		saa716x->int_type = MODE_INTA;
+	}
+
+	if (saa716x->int_type == MODE_MSI) {
+		ret = request_irq(pdev->irq,
+				  config->irq_handler,
+				  0,
+				  DRIVER_NAME,
+				  saa716x);
+
+		if (ret) {
+			pci_disable_msi(pdev);
+			dprintk(SAA716x_ERROR, 1, "MSI registration failed");
+			ret = -EIO;
+		}
+	}
+
+	if (saa716x->int_type == MODE_MSI_X) {
+		for (i = 0; SAA716x_MSI_MAX_VECTORS; i++) {
+			ret = request_irq(saa716x->msix_entries[i].vector,
+					  saa716x->saa716x_msix_handler[i].handler,
+					  IRQF_SHARED,
+					  saa716x->saa716x_msix_handler[i].desc,
+					  saa716x);
+
+			dprintk(SAA716x_ERROR, 1, "%s @ 0x%p", saa716x->saa716x_msix_handler[i].desc, saa716x->saa716x_msix_handler[i].handler);
+			if (ret) {
+				dprintk(SAA716x_ERROR, 1, "%s MSI-X-%d registration failed <%d>", saa716x->saa716x_msix_handler[i].desc, i, ret);
+				return -1;
+			}
+		}
+	}
+
+	if (saa716x->int_type == MODE_INTA) {
+		ret = request_irq(pdev->irq,
+				  config->irq_handler,
+				  IRQF_SHARED,
+				  DRIVER_NAME,
+				  saa716x);
+		if (ret < 0) {
+			dprintk(SAA716x_ERROR, 1, "SAA716x IRQ registration failed <%d>", ret);
+			ret = -ENODEV;
+		}
+	}
+
+	return ret;
+}
+
+static void saa716x_free_irq(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	int i, vector;
+
+	if (saa716x->int_type == MODE_MSI_X) {
+
+		for (i = 0; i < SAA716x_MSI_MAX_VECTORS; i++) {
+			vector = saa716x->msix_entries[i].vector;
+			free_irq(vector, saa716x);
+		}
+
+		pci_disable_msix(pdev);
+
+	} else {
+		free_irq(pdev->irq, saa716x);
+		if (saa716x->int_type == MODE_MSI)
+			pci_disable_msi(pdev);
+	}
+}
+
+int __devinit saa716x_pci_init(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	int err = 0, ret = -ENODEV, i, use_dac, pm_cap;
+	u32 msi_cap;
+	u8 revision;
+
+	dprintk(SAA716x_ERROR, 1, "found a %s PCIe card", saa716x->config->model_name);
+
+	err = pci_enable_device(pdev);
+	if (err != 0) {
+		ret = -ENODEV;
+		dprintk(SAA716x_ERROR, 1, "ERROR: PCI enable failed (%i)", err);
+		goto fail0;
+	}
+
+	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
+		use_dac = 1;
+		err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
+		if (err) {
+			dprintk(SAA716x_ERROR, 1, "Unable to obtain 64bit DMA");
+			goto fail1;
+		}
+	} else if ((err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) != 0) {
+		dprintk(SAA716x_ERROR, 1, "Unable to obtain 32bit DMA");
+		goto fail1;
+	}
+
+	pci_set_master(pdev);
+
+	pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+	if (pm_cap == 0) {
+		dprintk(SAA716x_ERROR, 1, "Cannot find Power Management Capability");
+		err = -EIO;
+		goto fail1;
+	}
+
+	if (!request_mem_region(pci_resource_start(pdev, 0),
+				pci_resource_len(pdev, 0),
+				DRIVER_NAME)) {
+
+		dprintk(SAA716x_ERROR, 1, "BAR0 Request failed");
+		ret = -ENODEV;
+		goto fail1;
+	}
+	saa716x->mmio = ioremap(pci_resource_start(pdev, 0),
+				pci_resource_len(pdev, 0));
+
+	if (!saa716x->mmio) {
+		dprintk(SAA716x_ERROR, 1, "Mem 0 remap failed");
+		ret = -ENODEV;
+		goto fail2;
+	}
+
+	for (i = 0; i < SAA716x_MSI_MAX_VECTORS; i++)
+		saa716x->msix_entries[i].entry = i;
+
+	err = saa716x_request_irq(saa716x);
+	if (err < 0) {
+		dprintk(SAA716x_ERROR, 1, "SAA716x IRQ registration failed, err=%d", err);
+		ret = -ENODEV;
+		goto fail3;
+	}
+
+	pci_read_config_byte(pdev, PCI_CLASS_REVISION, &revision);
+	pci_read_config_dword(pdev, 0x40, &msi_cap);
+
+	saa716x->revision	= revision;
+
+	dprintk(SAA716x_ERROR, 0, "    SAA%02x Rev %d [%04x:%04x], ",
+		saa716x->pdev->device,
+		revision,
+		saa716x->pdev->subsystem_vendor,
+		saa716x->pdev->subsystem_device);
+
+	dprintk(SAA716x_ERROR, 0,
+		"irq: %d,\n    mmio: 0x%p\n",
+		saa716x->pdev->irq,
+		saa716x->mmio);
+
+	dprintk(SAA716x_ERROR, 0, "    SAA%02x %sBit, MSI %s, MSI-X=%d msgs",
+		saa716x->pdev->device,
+		(((msi_cap >> 23) & 0x01) == 1 ? "64":"32"),
+		(((msi_cap >> 16) & 0x01) == 1 ? "Enabled" : "Disabled"),
+		(1 << ((msi_cap >> 17) & 0x07)));
+
+	dprintk(SAA716x_ERROR, 0, "\n");
+
+	pci_set_drvdata(pdev, saa716x);
+
+	return 0;
+
+fail3:
+	dprintk(SAA716x_ERROR, 1, "Err: IO Unmap");
+	if (saa716x->mmio)
+		iounmap(saa716x->mmio);
+fail2:
+	dprintk(SAA716x_ERROR, 1, "Err: Release regions");
+	release_mem_region(pci_resource_start(pdev, 0),
+			   pci_resource_len(pdev, 0));
+
+fail1:
+	dprintk(SAA716x_ERROR, 1, "Err: Disabling device");
+	pci_disable_device(pdev);
+
+fail0:
+	pci_set_drvdata(pdev, NULL);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(saa716x_pci_init);
+
+void __devexit saa716x_pci_exit(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+
+	saa716x_free_irq(saa716x);
+
+	dprintk(SAA716x_NOTICE, 1, "SAA%02x mem0: 0x%p",
+		saa716x->pdev->device,
+		saa716x->mmio);
+
+	if (saa716x->mmio) {
+		iounmap(saa716x->mmio);
+		release_mem_region(pci_resource_start(pdev, 0),
+				   pci_resource_len(pdev, 0));
+	}
+
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+}
+EXPORT_SYMBOL_GPL(saa716x_pci_exit);
+
+MODULE_DESCRIPTION("SAA716x bridge driver");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_phi.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_phi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi.c	2012-06-18 22:34:17.054032272 +0200
@@ -0,0 +1,152 @@
+#include <linux/kernel.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_phi_reg.h"
+
+#include "saa716x_spi.h"
+#include "saa716x_phi.h"
+#include "saa716x_priv.h"
+
+u32 PHI_0_REGS[] = {
+	PHI_0_MODE,
+	PHI_0_0_CONFIG,
+	PHI_0_1_CONFIG,
+	PHI_0_2_CONFIG,
+	PHI_0_3_CONFIG
+};
+
+u32 PHI_1_REGS[] = {
+	PHI_1_MODE,
+	PHI_1_0_CONFIG,
+	PHI_1_1_CONFIG,
+	PHI_1_2_CONFIG,
+	PHI_1_3_CONFIG,
+	PHI_1_4_CONFIG,
+	PHI_1_5_CONFIG,
+	PHI_1_6_CONFIG,
+	PHI_1_7_CONFIG
+};
+
+#define PHI_BASE(__port)	((				\
+	(__port == PHI_1) ?					\
+		PHI_1_BASE :					\
+		PHI_0_BASE					\
+))
+
+#define PHI_APERTURE(_port)	((				\
+	(__port == PHI_1) ?					\
+		PHI_1_APERTURE:					\
+		PHI_0_APERTURE					\
+))
+
+#define PHI_REG(__port, __reg)	((				\
+	(__port == PHI_1) ?					\
+		PHI_1_REGS[__reg] :				\
+		PHI_0_REGS[__reg]				\
+))
+
+#define PHI_SLAVE(__port, __slave)	((			\
+	PHI_BASE(__port) + (__slave * (PHI_APERTURE(__port)))	\
+))
+
+/* // Read SAA716x registers
+ * SAA716x_EPRD(PHI_0, PHI_REG(__port, __reg))
+ * SAA716x_EPWR(PHI_1, PHI_REG(__port, __reg), __data)
+ *
+ * // Read slave registers
+ * SAA716x_EPRD(PHI_0, PHI_SLAVE(__port, __slave, __offset))
+ * SAA716x_EPWR(PHI_1, PHI_SLAVE(__port, __slave, _offset), __data)
+ */
+
+int saa716x_init_phi(struct saa716x_dev *saa716x, u32 port, u8 slave)
+{
+	int i;
+
+	/* Reset */
+	SAA716x_EPWR(PHI_0, PHI_SW_RST, 0x1);
+
+	for (i = 0; i < 20; i++) {
+		msleep(1);
+		if (!(SAA716x_EPRD(PHI_0, PHI_SW_RST)))
+			break;
+	}
+
+	return 0;
+}
+
+int saa716x_phi_init(struct saa716x_dev *saa716x)
+{
+	uint32_t value;
+
+	/* init PHI 0 to FIFO mode */
+	value = 0;
+	value |= PHI_FIFO_MODE;
+	SAA716x_EPWR(PHI_0, PHI_0_MODE, value);
+
+	value = 0;
+	value |= 0x02; /* chip select 1 */
+	value |= 0x00 << 8; /* ready mask */
+	value |= 0x03 << 12; /* strobe time */
+	value |= 0x06 << 20; /* cycle time */
+	SAA716x_EPWR(PHI_0, PHI_0_0_CONFIG, value);
+
+	/* init PHI 1 to SRAM mode, auto increment on */
+	value = 0;
+	value |= PHI_AUTO_INCREMENT;
+	SAA716x_EPWR(PHI_0, PHI_1_MODE, value);
+
+	value = 0;
+	value |= 0x01; /* chip select 0 */
+	value |= 0x00 << 8; /* ready mask */
+	value |= 0x03 << 12; /* strobe time */
+	value |= 0x05 << 20; /* cycle time */
+	SAA716x_EPWR(PHI_0, PHI_1_0_CONFIG, value);
+
+	value = 0;
+	value |= PHI_ALE_POL; /* ALE is active high */
+	SAA716x_EPWR(PHI_0, PHI_POLARITY, value);
+
+	SAA716x_EPWR(PHI_0, PHI_TIMEOUT, 0x2a);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_phi_init);
+
+int saa716x_phi_write(struct saa716x_dev *saa716x, u32 address, const u8 * data, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i += 4) {
+		SAA716x_EPWR(PHI_1, address, *((u32 *) &data[i]));
+		address += 4;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_phi_write);
+
+int saa716x_phi_read(struct saa716x_dev *saa716x, u32 address, u8 * data, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i += 4) {
+		*((u32 *) &data[i]) = SAA716x_EPRD(PHI_1, address);
+		address += 4;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_phi_read);
+
+int saa716x_phi_write_fifo(struct saa716x_dev *saa716x, const u8 * data, int length)
+{
+	int i;
+
+	for (i = 0; i < length; i += 4) {
+		SAA716x_EPWR(PHI_0, PHI_0_0_RW_0, *((u32 *) &data[i]));
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_phi_write_fifo);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_phi.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_phi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,39 @@
+#ifndef __SAA716x_PHI_H
+#define __SAA716x_PHI_H
+
+/* PHI SLAVE */
+#define PHI_SLAVE_0		0
+#define PHI_SLAVE_1		1
+#define PHI_SLAVE_2		2
+#define PHI_SLAVE_3		3
+#define PHI_SLAVE_4		4
+#define PHI_SLAVE_5		5
+#define PHI_SLAVE_6		6
+#define PHI_SLAVE_7		7
+
+/* PHI_REG */
+#define PHI_MODE		0
+#define PHI_CONFIG_0		1
+#define PHI_CONFIG_1		2
+#define PHI_CONFIG_2		3
+#define PHI_CONFIG_3		4
+#define PHI_CONFIG_4		5
+#define PHI_CONFIG_5		6
+#define PHI_CONFIG_6		7
+#define PHI_CONFIG_7		8
+
+#define PHI_0_BASE		0x1000
+#define PHI_0_APERTURE		0x0800
+
+#define PHI_1_BASE		0x0000
+#define PHI_1_APERTURE		0xfffc
+
+struct saa716x_dev;
+
+extern int saa716x_init_phi(struct saa716x_dev *saa716x, u32 port, u8 slave);
+extern int saa716x_phi_init(struct saa716x_dev *saa716x);
+extern int saa716x_phi_write(struct saa716x_dev *saa716x, u32 address, const u8 *data, int length);
+extern int saa716x_phi_read(struct saa716x_dev *saa716x, u32 address, u8 *data, int length);
+extern int saa716x_phi_write_fifo(struct saa716x_dev *saa716x, const u8 * data, int length);
+
+#endif /* __SAA716x_PHI_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_phi_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_phi_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_phi_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,100 @@
+#ifndef __SAA716x_PHI_REG_H
+#define __SAA716x_PHI_REG_H
+
+/* -------------- PHI_0 Registers -------------- */
+
+#define PHI_0_MODE			0x0000
+#define PHI_0_0_CONFIG			0x0008
+#define PHI_0_1_CONFIG			0x000c
+#define PHI_0_2_CONFIG			0x0010
+#define PHI_0_3_CONFIG			0x0014
+
+#define PHI_POLARITY			0x0038
+#define PHI_TIMEOUT			0x003c
+#define PHI_SW_RST			0x0ff0
+
+#define PHI_0_0_RW_0			0x1000
+#define PHI_0_0_RW_511			0x17fc
+
+#define PHI_0_1_RW_0			0x1800
+#define PHI_0_1_RW_511			0x1ffc
+
+#define PHI_0_2_RW_0			0x2000
+#define PHI_0_2_RW_511			0x27fc
+
+#define PHI_0_3_RW_0			0x2800
+#define PHI_0_3_RW_511			0x2ffc
+
+#define PHI_CSN_DEASSERT		(0x00000001 <<  2)
+#define PHI_AUTO_INCREMENT		(0x00000001 <<  1)
+#define PHI_FIFO_MODE			(0x00000001 <<  0)
+
+#define PHI_DELAY_RD_WR			(0x0000001f << 27)
+#define PHI_EXTEND_RDY3			(0x00000003 << 25)
+#define PHI_EXTEND_RDY2			(0x00000003 << 23)
+#define PHI_EXTEND_RDY1			(0x00000003 << 21)
+#define PHI_EXTEND_RDY0			(0x00000003 << 19)
+#define PHI_RDY3_OD			(0x00000001 << 18)
+#define PHI_RDY2_OD			(0x00000001 << 17)
+#define PHI_RDY1_OD			(0x00000001 << 16)
+#define PHI_RDY0_OD			(0x00000001 << 15)
+#define PHI_ALE_POL			(0x00000001 << 14)
+#define PHI_WRN_POL			(0x00000001 << 13)
+#define PHI_RDN_POL			(0x00000001 << 12)
+#define PHI_RDY3_POL			(0x00000001 << 11)
+#define PHI_RDY2_POL			(0x00000001 << 10)
+#define PHI_RDY1_POL			(0x00000001 <<  9)
+#define PHI_RDY0_POL			(0x00000001 <<  8)
+#define PHI_CSN7_POL			(0x00000001 <<  7)
+#define PHI_CSN6_POL			(0x00000001 <<  6)
+#define PHI_CSN5_POL			(0x00000001 <<  5)
+#define PHI_CSN4_POL			(0x00000001 <<  4)
+#define PHI_CSN3_POL			(0x00000001 <<  3)
+#define PHI_CSN2_POL			(0x00000001 <<  2)
+#define PHI_CSN1_POL			(0x00000001 <<  1)
+#define PHI_CSN0_POL			(0x00000001 <<  0)
+
+/* -------------- PHI_1 Registers -------------- */
+
+#define	PHI_1				0x00020000
+
+#define PHI_1_MODE			0x00004
+#define PHI_1_0_CONFIG			0x00018
+#define PHI_1_1_CONFIG			0x0001c
+#define PHI_1_2_CONFIG			0x00020
+#define PHI_1_3_CONFIG			0x00024
+#define PHI_1_4_CONFIG			0x00028
+#define PHI_1_5_CONFIG			0x0002c
+#define PHI_1_6_CONFIG			0x00030
+#define PHI_1_7_CONFIG			0x00034
+
+#define PHI_1_0_RW_0			0x00000
+#define PHI_1_0_RW_16383		0x0fffc
+
+#define PHI_1_1_RW_0			0x1000
+#define PHI_1_1_RW_16383		0x1ffc
+
+#define PHI_1_2_RW_0			0x2000
+#define PHI_1_2_RW_16383		0x2ffc
+
+#define PHI_1_3_RW_0			0x3000
+#define PHI_1_3_RW_16383		0x3ffc
+
+#define PHI_1_4_RW_0			0x4000
+#define PHI_1_4_RW_16383		0x4ffc
+
+#define PHI_1_5_RW_0			0x5000
+#define PHI_1_5_RW_16383		0x5ffc
+
+#define PHI_1_6_RW_0			0x6000
+#define PHI_1_6_RW_16383		0x6ffc
+
+#define PHI_1_7_RW_0			0x7000
+#define PHI_1_7_RW_16383		0x7ffc
+
+
+/* BAR = 20 bits */
+/* -------------- PHI1 Registers -------------- */
+
+
+#endif /* __SAA716x_PHI_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_priv.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_priv.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_priv.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,194 @@
+#ifndef __SAA716x_PRIV_H
+#define __SAA716x_PRIV_H
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/mutex.h>
+
+#include <linux/pci.h>
+#include <linux/ioport.h>
+#include <linux/i2c.h>
+#include "saa716x_i2c.h"
+#include "saa716x_boot.h"
+#include "saa716x_cgu.h"
+#include "saa716x_dma.h"
+#include "saa716x_fgpi.h"
+
+#include "dvbdev.h"
+#include "dvb_demux.h"
+#include "dmxdev.h"
+#include "dvb_frontend.h"
+#include "dvb_net.h"
+
+#define SAA716x_ERROR		0
+#define SAA716x_NOTICE		1
+#define SAA716x_INFO		2
+#define SAA716x_DEBUG		3
+
+#define SAA716x_DEV		(saa716x)->num
+#define SAA716x_VERBOSE		(saa716x)->verbose
+#define SAA716x_MAX_ADAPTERS	4
+
+#define dprintk(__x, __y, __fmt, __arg...) do {								\
+	if (__y) {											\
+		if	((SAA716x_VERBOSE > SAA716x_ERROR) && (SAA716x_VERBOSE > __x))			\
+			printk(KERN_ERR "%s (%d): " __fmt "\n" , __func__ , SAA716x_DEV , ##__arg);	\
+		else if	((SAA716x_VERBOSE > SAA716x_NOTICE) && (SAA716x_VERBOSE > __x))			\
+			printk(KERN_NOTICE "%s (%d): " __fmt "\n" , __func__ , SAA716x_DEV , ##__arg);	\
+		else if ((SAA716x_VERBOSE > SAA716x_INFO) && (SAA716x_VERBOSE > __x))			\
+			printk(KERN_INFO "%s (%d): " __fmt "\n" , __func__ , SAA716x_DEV , ##__arg);	\
+		else if ((SAA716x_VERBOSE > SAA716x_DEBUG) && (SAA716x_VERBOSE > __x))			\
+			printk(KERN_DEBUG "%s (%d): " __fmt "\n" , __func__ , SAA716x_DEV , ##__arg);	\
+	} else {											\
+		if (SAA716x_VERBOSE > __x)								\
+			printk(__fmt , ##__arg);							\
+	}												\
+} while(0)
+
+
+#define NXP_SEMICONDUCTOR	0x1131
+#define SAA7160			0x7160
+#define SAA7161			0x7161
+#define SAA7162			0x7162
+
+#define NXP_REFERENCE_BOARD	0x1131
+
+#define MAKE_ENTRY(__subven, __subdev, __chip, __configptr) {		\
+		.vendor		= NXP_SEMICONDUCTOR,			\
+		.device		= (__chip),				\
+		.subvendor	= (__subven),				\
+		.subdevice	= (__subdev),				\
+		.driver_data	= (unsigned long) (__configptr)		\
+}
+
+#define SAA716x_EPWR(__offst, __addr, __data)	writel((__data), (saa716x->mmio + (__offst + __addr)))
+#define SAA716x_EPRD(__offst, __addr)		readl((saa716x->mmio + (__offst + __addr)))
+
+#define SAA716x_RCWR(__offst, __addr, __data)	writel((__data), (saa716x->mmio + (__offst + __addr)))
+#define SAA716x_RCRD(__offst, __addr)		readl((saa716x->mmio + (__offst + __addr)))
+
+
+#define SAA716x_MSI_MAX_VECTORS			16
+
+struct saa716x_msix_entry {
+	int vector;
+	u8 desc[32];
+	irqreturn_t (*handler)(int irq, void *dev_id);
+};
+
+struct saa716x_dev;
+struct saa716x_adapter;
+struct saa716x_spi_config;
+
+struct saa716x_adap_config {
+	u32				ts_port;
+	void				(*worker)(unsigned long);
+};
+
+struct saa716x_config {
+	char				*model_name;
+	char				*dev_type;
+
+	enum saa716x_boot_mode		boot_mode;
+
+	int				adapters;
+	int				frontends;
+
+	int (*frontend_attach)(struct saa716x_adapter *adapter, int count);
+	irqreturn_t (*irq_handler)(int irq, void *dev_id);
+
+	struct saa716x_adap_config	adap_config[SAA716x_MAX_ADAPTERS];
+	enum saa716x_i2c_rate		i2c_rate;
+	enum saa716x_i2c_mode		i2c_mode;
+};
+
+struct saa716x_adapter {
+	struct dvb_adapter		dvb_adapter;
+	struct dvb_frontend		*fe;
+	struct dvb_demux		demux;
+	struct dmxdev			dmxdev;
+	struct dmx_frontend		fe_hw;
+	struct dmx_frontend		fe_mem;
+	struct dvb_net			dvb_net;
+
+	struct saa716x_dev		*saa716x;
+
+	u8				feeds;
+	u8				count;
+};
+
+struct saa716x_dev {
+	struct saa716x_config		*config;
+	struct pci_dev			*pdev;
+
+	int				num; /* device count */
+	int				verbose;
+
+	u8 				revision;
+
+	/* PCI */
+	void __iomem			*mmio;
+
+#define MODE_INTA	0
+#define MODE_MSI	1
+#define MODE_MSI_X	2
+	u8				int_type;
+
+	struct msix_entry		msix_entries[SAA716x_MSI_MAX_VECTORS];
+	struct saa716x_msix_entry	saa716x_msix_handler[56];
+	u8				handlers; /* no. of active handlers */
+
+	/* I2C */
+	struct saa716x_i2c		i2c[2];
+	u32				i2c_rate; /* init time */
+	u32				I2C_DEV[2];
+
+	struct saa716x_spi_state	*saa716x_spi;
+	struct saa716x_spi_config	spi_config;
+
+	struct saa716x_adapter		saa716x_adap[SAA716x_MAX_ADAPTERS];
+	struct mutex			adap_lock;
+	struct saa716x_cgu		cgu;
+
+	spinlock_t			gpio_lock;
+	/* DMA */
+
+	struct saa716x_fgpi_stream_port	fgpi[4];
+
+	u32				id_offst;
+	u32				id_len;
+	void				*priv;
+
+	/* remote control */
+	void				*ir_priv;
+};
+
+/* PCI */
+extern int saa716x_pci_init(struct saa716x_dev *saa716x);
+extern void saa716x_pci_exit(struct saa716x_dev *saa716x);
+
+/* MSI */
+extern int saa716x_msi_init(struct saa716x_dev *saa716x);
+extern void saa716x_msi_exit(struct saa716x_dev *saa716x);
+extern void saa716x_msiint_disable(struct saa716x_dev *saa716x);
+
+/* DMA */
+extern int saa716x_dma_init(struct saa716x_dev *saa716x);
+extern void saa716x_dma_exit(struct saa716x_dev *saa716x);
+
+/* AUDIO */
+extern int saa716x_audio_init(struct saa716x_dev *saa716x);
+extern void saa716x_audio_exit(struct saa716x_dev *saa716x);
+
+/* Boot */
+extern int saa716x_core_boot(struct saa716x_dev *saa716x);
+extern int saa716x_jetpack_init(struct saa716x_dev *saa716x);
+
+/* Remote control */
+extern int saa716x_ir_init(struct saa716x_dev *saa716x);
+extern void saa716x_ir_exit(struct saa716x_dev *saa716x);
+extern void saa716x_ir_handler(struct saa716x_dev *saa716x, u32 ir_cmd);
+
+#endif /* __SAA716x_PRIV_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,1279 @@
+#ifndef __SAA716x_REG_H
+#define __SAA716x_REG_H
+
+/* BAR = 17 bits */
+/*
+	VI0	0x00000000
+	VI1	0x00001000
+	FGPI0	0x00002000
+	FGPI1	0x00003000
+	FGPI2	0x00004000
+	FGPI3	0x00005000
+	AI0	0x00006000
+	AI1	0x00007000
+	BAM	0x00008000
+	MMU	0x00009000
+	MSI	0x0000a000
+	I2C_B	0x0000b000
+	I2C_A	0x0000c000
+	SPI	0x0000d000
+	GPIO	0x0000e000
+	PHI_0	0x0000f000
+	CGU	0x00013000
+	DCS	0x00014000
+	GREG	0x00012000
+
+	PHI_1	0x00020000
+*/
+
+/* -------------- VIP Registers -------------- */
+
+#define VI0				0x00000000
+#define VI1				0x00001000
+
+#define VI_MODE				0x000
+#define VID_CFEN			(0x00000003 << 30)
+#define VID_OSM				(0x00000001 << 29)
+#define VID_FSEQ			(0x00000001 << 28)
+#define AUX_CFEN			(0x00000003 << 26)
+#define AUX_OSM				(0x00000001 << 25)
+#define AUX_FSEQ			(0x00000001 << 24)
+#define AUX_ANC_DATA			(0x00000003 << 22)
+#define AUX_ANC_RAW			(0x00000001 << 21)
+#define RST_ON_ERR			(0x00000001 << 17)
+#define SOFT_RESET			(0x00000001 << 16)
+#define IFF_CLAMP			(0x00000001 << 14)
+#define IFF_MODE			(0x00000003 << 12)
+#define DFF_CLAMP			(0x00000001 << 10)
+#define DFF_MODE			(0x00000003 <<  8)
+#define HSP_CLAMP			(0x00000001 <<  3)
+#define HSP_RGB				(0x00000001 <<  2)
+#define HSP_MODE			(0x00000003 <<  0)
+
+#define RCRB_CTRL			0x004
+#define RCRB_CFG_ADDR			0x008
+#define RCRB_CFG_EXT_ADDR		0x00c
+#define RCRB_IO_ADDR			0x010
+#define RCRB_MEM_LADDR			0x014
+#define RCRB_MEM_UADDR			0x018
+#define RCRB_DATA			0x01c
+#define RCRB_MASK			0x020
+#define RCRB_MSG_HDR			0x040
+#define RCRB_MSG_PL0			0x044
+#define RCRB_MSG_PL1			0x048
+
+#define ID_MASK0			0x020
+#define VI_ID_MASK_0			(0x000000ff <<  8)
+#define VI_DATA_ID_0			(0x000000ff <<  0)
+
+#define ID_MASK1			0x024
+#define VI_ID_MASK_1			(0x000000ff <<  8)
+#define VI_DATA_ID_1			(0x000000ff <<  0)
+
+#define VIP_LINE_THRESH			0x040
+#define VI_LCTHR			(0x000007ff <<  0)
+
+#define VIN_FORMAT			0x100
+#define VI_VSRA				(0x00000003 << 30)
+#define VI_SYNCHD			(0x00000001 << 25)
+#define VI_DUAL_STREAM			(0x00000001 << 24)
+#define VI_NHDAUX			(0x00000001 << 20)
+#define VI_NPAR				(0x00000001 << 19)
+#define VI_VSEL				(0x00000003 << 14)
+#define VI_TWOS				(0x00000001 << 13)
+#define VI_TPG				(0x00000001 << 12)
+#define VI_FREF				(0x00000001 << 10)
+#define VI_FTGL				(0x00000001 <<  9)
+#define VI_SF				(0x00000001 <<  3)
+#define VI_FZERO			(0x00000001 <<  2)
+#define VI_REVS				(0x00000001 <<  1)
+#define VI_REHS				(0x00000001 <<  0)
+
+#define TC76543210			0x800
+#define TCFEDCBA98			0x804
+#define PHYCFG				0x900
+#define CONFIG				0xfd4
+#define INT_ENABLE_CLR			0xfd8
+#define INT_ENABLE_SET			0xfdc
+
+
+#define INT_STATUS			0xfe0
+#define VI_STAT_FID_AUX			(0x00000001 << 31)
+#define VI_STAT_FID_VID			(0x00000001 << 30)
+#define VI_STAT_FID_VPI			(0x00000001 << 29)
+#define VI_STAT_LINE_COUNT		(0x00000fff << 16)
+#define VI_STAT_AUX_OVRFLW		(0x00000001 <<  9)
+#define VI_STAT_VID_OVRFLW		(0x00000001 <<  8)
+#define VI_STAT_WIN_SEQBRK		(0x00000001 <<  7)
+#define VI_STAT_FID_SEQBRK		(0x00000001 <<  6)
+#define VI_STAT_LINE_THRESH		(0x00000001 <<  5)
+#define VI_STAT_AUX_WRAP		(0x00000001 <<  4)
+#define VI_STAT_AUX_START_IN		(0x00000001 <<  3)
+#define VI_STAT_AUX_END_OUT		(0x00000001 <<  2)
+#define VI_STAT_VID_START_IN		(0x00000001 <<  1)
+#define VI_STAT_VID_END_OUT		(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define VI_ENABLE_AUX_OVRFLW		(0x00000001 <<  9)
+#define VI_ENABLE_VID_OVRFLW		(0x00000001 <<  8)
+#define VI_ENABLE_WIN_SEQBRK		(0x00000001 <<  7)
+#define VI_ENABLE_FID_SEQBRK		(0x00000001 <<  6)
+#define VI_ENABLE_LINE_THRESH		(0x00000001 <<  5)
+#define VI_ENABLE_AUX_WRAP		(0x00000001 <<  4)
+#define VI_ENABLE_AUX_START_IN		(0x00000001 <<  3)
+#define VI_ENABLE_AUX_END_OUT		(0x00000001 <<  2)
+#define VI_ENABLE_VID_START_IN		(0x00000001 <<  1)
+#define VI_ENABLE_VID_END_OUT		(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define VI_CLR_STATUS_AUX_OVRFLW	(0x00000001 <<  9)
+#define VI_CLR_STATUS_VID_OVRFLW	(0x00000001 <<  8)
+#define VI_CLR_STATUS_WIN_SEQBRK	(0x00000001 <<  7)
+#define VI_CLR_STATUS_FID_SEQBRK	(0x00000001 <<  6)
+#define VI_CLR_STATUS_LINE_THRESH	(0x00000001 <<  5)
+#define VI_CLR_STATUS_AUX_WRAP		(0x00000001 <<  4)
+#define VI_CLR_STATUS_AUX_START_IN	(0x00000001 <<  3)
+#define VI_CLR_STATUS_AUX_END_OUT	(0x00000001 <<  2)
+#define VI_CLR_STATUS_VID_START_IN	(0x00000001 <<  1)
+#define VI_CLR_STATUS_VID_END_OUT	(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define VI_SET_STATUS_AUX_OVRFLW	(0x00000001 <<  9)
+#define VI_SET_STATUS_VID_OVRFLW	(0x00000001 <<  8)
+#define VI_SET_STATUS_WIN_SEQBRK	(0x00000001 <<  7)
+#define VI_SET_STATUS_FID_SEQBRK	(0x00000001 <<  6)
+#define VI_SET_STATUS_LINE_THRESH	(0x00000001 <<  5)
+#define VI_SET_STATUS_AUX_WRAP		(0x00000001 <<  4)
+#define VI_SET_STATUS_AUX_START_IN	(0x00000001 <<  3)
+#define VI_SET_STATUS_AUX_END_OUT	(0x00000001 <<  2)
+#define VI_SET_STATUS_VID_START_IN	(0x00000001 <<  1)
+#define VI_SET_STATUS_VID_END_OUT	(0x00000001 <<  0)
+
+#define VIP_POWER_DOWN			0xff4
+#define VI_PWR_DWN			(0x00000001 << 31)
+
+
+
+
+/* -------------- FGPI Registers -------------- */
+
+#define FGPI0				0x00002000
+#define FGPI1				0x00003000
+#define FGPI2				0x00004000
+#define FGPI3				0x00005000
+
+#define FGPI_CONTROL			0x000
+#define FGPI_CAPTURE_ENABLE_2		(0x00000001 << 13)
+#define FGPI_CAPTURE_ENABLE_1		(0x00000001 << 12)
+#define FGPI_MODE			(0x00000001 << 11)
+#define FGPI_SAMPLE_SIZE		(0x00000003 <<  8)
+#define FGPI_BUF_SYNC_MSG_STOP		(0x00000003 <<  5)
+#define FGPI_REC_START_MSG_START	(0x00000003 <<  2)
+#define FGPI_TSTAMP_SELECT		(0x00000001 <<  1)
+#define FGPI_VAR_LENGTH			(0x00000001 <<  0)
+
+#define FGPI_BASE_1			0x004
+#define FGPI_BASE_2			0x008
+#define FGPI_SIZE			0x00c
+#define FGPI_REC_SIZE			0x010
+#define FGPI_STRIDE			0x014
+#define FGPI_NUM_RECORD_1		0x018
+#define FGPI_NUM_RECORD_2		0x01c
+#define FGPI_THRESHOLD_1		0x020
+#define FGPI_THRESHOLD_2		0x024
+#define FGPI_D1_XY_START		0x028
+#define FGPI_D1_XY_END			0x02c
+
+#define INT_STATUS			0xfe0
+#define FGPI_BUF1_ACTIVE		(0x00000001 <<  7)
+#define FGPI_OVERFLOW			(0x00000001 <<  6)
+#define FGPI_MBE			(0x00000001 <<  5)
+#define FGPI_UNDERRUN			(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED		(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED		(0x00000001 <<  2)
+#define FGPI_BUF2_FULL			(0x00000001 <<  1)
+#define FGPI_BUF1_FULL			(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define FGPI_OVERFLOW_ENA		(0x00000001 <<  6)
+#define FGPI_MBE_ENA			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_ENA		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_ENA	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_ENA	(0x00000001 <<  2)
+#define FGPI_BUF2_FULL_ENA		(0x00000001 <<  1)
+#define FGPI_BUF1_FULL_ENA		(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define FGPI_OVERFLOW_ACK		(0x00000001 <<  6)
+#define FGPI_MBE_ACK			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_ACK		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_ACK	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_ACK	(0x00000001 <<  2)
+#define FGPI_BUF2_DONE_ACK		(0x00000001 <<  1)
+#define FGPI_BUF1_DONE_ACK		(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define FGPI_OVERFLOW_SET		(0x00000001 <<  6)
+#define FGPI_MBE_SET			(0x00000001 <<  5)
+#define FGPI_UNDERRUN_SET		(0x00000001 <<  4)
+#define FGPI_THRESH2_REACHED_SET	(0x00000001 <<  3)
+#define FGPI_THRESH1_REACHED_SET	(0x00000001 <<  2)
+#define FGPI_BUF2_DONE_SET		(0x00000001 <<  1)
+#define FGPI_BUF1_DONE_SET		(0x00000001 <<  0)
+
+#define FGPI_SOFT_RESET			0xff0
+#define FGPI_SOFTWARE_RESET		(0x00000001 <<  0)
+
+#define FGPI_INTERFACE			0xff4
+#define FGPI_DISABLE_BUS_IF		(0x00000001 <<  0)
+
+#define FGPI_MOD_ID_EXT			0xff8
+#define FGPI_MODULE_ID			0xffc
+
+
+/* -------------- AI Registers ---------------- */
+
+#define AI0				0x00006000
+#define AI1				0x00007000
+
+#define AI_STATUS			0x000
+#define AI_BUF1_ACTIVE			(0x00000001 <<  4)
+#define AI_OVERRUN			(0x00000001 <<  3)
+#define AI_HBE				(0x00000001 <<  2)
+#define AI_BUF2_FULL			(0x00000001 <<  1)
+#define AI_BUF1_FULL			(0x00000001 <<  0)
+
+#define AI_CTL				0x004
+#define AI_RESET			(0x00000001 <<  31)
+#define AI_CAP_ENABLE			(0x00000001 <<  30)
+#define AI_CAP_MODE			(0x00000003 <<  28)
+#define AI_SIGN_CONVERT			(0x00000001 <<  27)
+#define AI_EARLYMODE			(0x00000001 <<  26)
+#define AI_DIAGMODE			(0x00000001 <<  25)
+#define AI_RAWMODE			(0x00000001 <<  24)
+#define AI_OVR_INTEN			(0x00000001 <<   7)
+#define AI_HBE_INTEN			(0x00000001 <<   6)
+#define AI_BUF2_INTEN			(0x00000001 <<   5)
+#define AI_BUF1_INTEN			(0x00000001 <<   4)
+#define AI_ACK_OVR			(0x00000001 <<   3)
+#define AI_ACK_HBE			(0x00000001 <<   2)
+#define AI_ACK2				(0x00000001 <<   1)
+#define AI_ACK1				(0x00000001 <<   0)
+
+#define AI_SERIAL			0x008
+#define AI_SER_MASTER			(0x00000001 <<  31)
+#define AI_DATAMODE			(0x00000001 <<  30)
+#define AI_FRAMEMODE			(0x00000003 <<  28)
+#define AI_CLOCK_EDGE			(0x00000001 <<  27)
+#define AI_SSPOS4			(0x00000001 <<  19)
+#define AI_NR_CHAN			(0x00000003 <<  17)
+#define AI_WSDIV			(0x000001ff <<   8)
+#define AI_SCKDIV			(0x000000ff <<   0)
+
+#define AI_FRAMING			0x00c
+#define AI_VALIDPOS			(0x000001ff << 22)
+#define AI_LEFTPOS			(0x000001ff << 13)
+#define AI_RIGHTPOS			(0x000001ff <<  4)
+#define AI_SSPOS_3_0			(0x0000000f <<  0)
+
+#define AI_BASE1			0x014
+#define AI_BASE2			0x018
+#define AI_BASE				(0x03ffffff <<  6)
+
+#define AI_SIZE				0x01c
+#define AI_SAMPLE_SIZE			(0x03ffffff <<  6)
+
+#define AI_INT_ACK			0x020
+#define AI_ACK_OVR			(0x00000001 <<  3)
+#define AI_ACK_HBE			(0x00000001 <<  2)
+#define AI_ACK2				(0x00000001 <<  1)
+#define AI_ACK1				(0x00000001 <<  0)
+
+#define AI_PWR_DOWN			0xff4
+#define AI_PWR_DWN			(0x00000001 <<  0)
+
+/* -------------- BAM Registers -------------- */
+
+#define BAM				0x00008000
+
+#define BAM_VI0_0_DMA_BUF_MODE		0x000
+
+#define BAM_VI0_0_ADDR_OFFST_0		0x004
+#define BAM_VI0_0_ADDR_OFFST_1		0x008
+#define BAM_VI0_0_ADDR_OFFST_2		0x00c
+#define BAM_VI0_0_ADDR_OFFST_3		0x010
+#define BAM_VI0_0_ADDR_OFFST_4		0x014
+#define BAM_VI0_0_ADDR_OFFST_5		0x018
+#define BAM_VI0_0_ADDR_OFFST_6		0x01c
+#define BAM_VI0_0_ADDR_OFFST_7		0x020
+
+#define BAM_VI0_1_DMA_BUF_MODE		0x024
+#define BAM_VI0_1_ADDR_OFFST_0		0x028
+#define BAM_VI0_1_ADDR_OFFST_1		0x02c
+#define BAM_VI0_1_ADDR_OFFST_2		0x030
+#define BAM_VI0_1_ADDR_OFFST_3		0x034
+#define BAM_VI0_1_ADDR_OFFST_4		0x038
+#define BAM_VI0_1_ADDR_OFFST_5		0x03c
+#define BAM_VI0_1_ADDR_OFFST_6		0x040
+#define BAM_VI0_1_ADDR_OFFST_7		0x044
+
+#define BAM_VI0_2_DMA_BUF_MODE		0x048
+#define BAM_VI0_2_ADDR_OFFST_0		0x04c
+#define BAM_VI0_2_ADDR_OFFST_1		0x050
+#define BAM_VI0_2_ADDR_OFFST_2		0x054
+#define BAM_VI0_2_ADDR_OFFST_3		0x058
+#define BAM_VI0_2_ADDR_OFFST_4		0x05c
+#define BAM_VI0_2_ADDR_OFFST_5		0x060
+#define BAM_VI0_2_ADDR_OFFST_6		0x064
+#define BAM_VI0_2_ADDR_OFFST_7		0x068
+
+
+#define BAM_VI1_0_DMA_BUF_MODE		0x06c
+#define BAM_VI1_0_ADDR_OFFST_0		0x070
+#define BAM_VI1_0_ADDR_OFFST_1		0x074
+#define BAM_VI1_0_ADDR_OFFST_2		0x078
+#define BAM_VI1_0_ADDR_OFFST_3		0x07c
+#define BAM_VI1_0_ADDR_OFFST_4		0x080
+#define BAM_VI1_0_ADDR_OFFST_5		0x084
+#define BAM_VI1_0_ADDR_OFFST_6		0x088
+#define BAM_VI1_0_ADDR_OFFST_7		0x08c
+
+#define BAM_VI1_1_DMA_BUF_MODE		0x090
+#define BAM_VI1_1_ADDR_OFFST_0		0x094
+#define BAM_VI1_1_ADDR_OFFST_1		0x098
+#define BAM_VI1_1_ADDR_OFFST_2		0x09c
+#define BAM_VI1_1_ADDR_OFFST_3		0x0a0
+#define BAM_VI1_1_ADDR_OFFST_4		0x0a4
+#define BAM_VI1_1_ADDR_OFFST_5		0x0a8
+#define BAM_VI1_1_ADDR_OFFST_6		0x0ac
+#define BAM_VI1_1_ADDR_OFFST_7		0x0b0
+
+#define BAM_VI1_2_DMA_BUF_MODE		0x0b4
+#define BAM_VI1_2_ADDR_OFFST_0		0x0b8
+#define BAM_VI1_2_ADDR_OFFST_1		0x0bc
+#define BAM_VI1_2_ADDR_OFFST_2		0x0c0
+#define BAM_VI1_2_ADDR_OFFST_3		0x0c4
+#define BAM_VI1_2_ADDR_OFFST_4		0x0c8
+#define BAM_VI1_2_ADDR_OFFST_5		0x0cc
+#define BAM_VI1_2_ADDR_OFFST_6		0x0d0
+#define BAM_VI1_2_ADDR_OFFST_7		0x0d4
+
+
+#define BAM_FGPI0_DMA_BUF_MODE		0x0d8
+#define BAM_FGPI0_ADDR_OFFST_0		0x0dc
+#define BAM_FGPI0_ADDR_OFFST_1		0x0e0
+#define BAM_FGPI0_ADDR_OFFST_2		0x0e4
+#define BAM_FGPI0_ADDR_OFFST_3		0x0e8
+#define BAM_FGPI0_ADDR_OFFST_4		0x0ec
+#define BAM_FGPI0_ADDR_OFFST_5		0x0f0
+#define BAM_FGPI0_ADDR_OFFST_6		0x0f4
+#define BAM_FGPI0_ADDR_OFFST_7		0x0f8
+
+#define BAM_FGPI1_DMA_BUF_MODE		0x0fc
+#define BAM_FGPI1_ADDR_OFFST_0		0x100
+#define BAM_FGPI1_ADDR_OFFST_1		0x104
+#define BAM_FGPI1_ADDR_OFFST_2		0x108
+#define BAM_FGPI1_ADDR_OFFST_3		0x10c
+#define BAM_FGPI1_ADDR_OFFST_4		0x110
+#define BAM_FGPI1_ADDR_OFFST_5		0x114
+#define BAM_FGPI1_ADDR_OFFST_6		0x118
+#define BAM_FGPI1_ADDR_OFFST_7		0x11c
+
+#define BAM_FGPI2_DMA_BUF_MODE		0x120
+#define BAM_FGPI2_ADDR_OFFST_0		0x124
+#define BAM_FGPI2_ADDR_OFFST_1		0x128
+#define BAM_FGPI2_ADDR_OFFST_2		0x12c
+#define BAM_FGPI2_ADDR_OFFST_3		0x130
+#define BAM_FGPI2_ADDR_OFFST_4		0x134
+#define BAM_FGPI2_ADDR_OFFST_5		0x138
+#define BAM_FGPI2_ADDR_OFFST_6		0x13c
+#define BAM_FGPI2_ADDR_OFFST_7		0x140
+
+#define BAM_FGPI3_DMA_BUF_MODE		0x144
+#define BAM_FGPI3_ADDR_OFFST_0		0x148
+#define BAM_FGPI3_ADDR_OFFST_1		0x14c
+#define BAM_FGPI3_ADDR_OFFST_2		0x150
+#define BAM_FGPI3_ADDR_OFFST_3		0x154
+#define BAM_FGPI3_ADDR_OFFST_4		0x158
+#define BAM_FGPI3_ADDR_OFFST_5		0x15c
+#define BAM_FGPI3_ADDR_OFFST_6		0x160
+#define BAM_FGPI3_ADDR_OFFST_7		0x164
+
+
+#define BAM_AI0_DMA_BUF_MODE		0x168
+#define BAM_AI0_ADDR_OFFST_0		0x16c
+#define BAM_AI0_ADDR_OFFST_1		0x170
+#define BAM_AI0_ADDR_OFFST_2		0x174
+#define BAM_AI0_ADDR_OFFST_3		0x178
+#define BAM_AI0_ADDR_OFFST_4		0x17c
+#define BAM_AIO_ADDR_OFFST_5		0x180
+#define BAM_AI0_ADDR_OFFST_6		0x184
+#define BAM_AIO_ADDR_OFFST_7		0x188
+
+#define BAM_AI1_DMA_BUF_MODE		0x18c
+#define BAM_AI1_ADDR_OFFST_0		0x190
+#define BAM_AI1_ADDR_OFFST_1		0x194
+#define BAM_AI1_ADDR_OFFST_2		0x198
+#define BAM_AI1_ADDR_OFFST_3		0x19c
+#define BAM_AI1_ADDR_OFFST_4		0x1a0
+#define BAM_AI1_ADDR_OFFST_5		0x1a4
+#define BAM_AI1_ADDR_OFFST_6		0x1a8
+#define BAM_AI1_ADDR_OFFST_7		0x1ac
+
+#define BAM_SW_RST			0xff0
+#define BAM_SW_RESET			(0x00000001 <<  0)
+
+
+
+
+
+/* -------------- MMU Registers -------------- */
+
+#define MMU				0x00009000
+
+#define MMU_MODE			0x000
+
+#define MMU_DMA_CONFIG0			0x004
+#define MMU_DMA_CONFIG1			0x008
+#define MMU_DMA_CONFIG2			0x00c
+#define MMU_DMA_CONFIG3			0x010
+#define MMU_DMA_CONFIG4			0x014
+#define MMU_DMA_CONFIG5			0x018
+#define MMU_DMA_CONFIG6			0x01c
+#define MMU_DMA_CONFIG7			0x020
+#define MMU_DMA_CONFIG8			0x024
+#define MMU_DMA_CONFIG9			0x028
+#define MMU_DMA_CONFIG10		0x02c
+#define MMU_DMA_CONFIG11		0x030
+#define MMU_DMA_CONFIG12		0x034
+#define MMU_DMA_CONFIG13		0x038
+#define MMU_DMA_CONFIG14		0x03c
+#define MMU_DMA_CONFIG15		0x040
+
+#define MMU_SW_RST			0xff0
+#define MMU_SW_RESET			(0x0001 <<  0)
+
+#define MMU_PTA_BASE0			0x044 /* DMA 0 */
+#define MMU_PTA_BASE1			0x084 /* DMA 1 */
+#define MMU_PTA_BASE2			0x0c4 /* DMA 2 */
+#define MMU_PTA_BASE3			0x104 /* DMA 3 */
+#define MMU_PTA_BASE4			0x144 /* DMA 4 */
+#define MMU_PTA_BASE5			0x184 /* DMA 5 */
+#define MMU_PTA_BASE6			0x1c4 /* DMA 6 */
+#define MMU_PTA_BASE7			0x204 /* DMA 7 */
+#define MMU_PTA_BASE8			0x244 /* DMA 8 */
+#define MMU_PTA_BASE9			0x284 /* DMA 9 */
+#define MMU_PTA_BASE10			0x2c4 /* DMA 10 */
+#define MMU_PTA_BASE11			0x304 /* DMA 11 */
+#define MMU_PTA_BASE12			0x344 /* DMA 12 */
+#define MMU_PTA_BASE13			0x384 /* DMA 13 */
+#define MMU_PTA_BASE14			0x3c4 /* DMA 14 */
+#define MMU_PTA_BASE15			0x404 /* DMA 15 */
+
+#define MMU_PTA_BASE			0x044 /* DMA 0 */
+#define MMU_PTA_OFFSET			0x40
+
+#define PTA_BASE(__ch)			(MMU_PTA_BASE + (MMU_PTA_OFFSET * __ch))
+
+#define MMU_PTA0_LSB(__ch)		PTA_BASE(__ch) + 0x00
+#define MMU_PTA0_MSB(__ch)		PTA_BASE(__ch) + 0x04
+#define MMU_PTA1_LSB(__ch)		PTA_BASE(__ch) + 0x08
+#define MMU_PTA1_MSB(__ch)		PTA_BASE(__ch) + 0x0c
+#define MMU_PTA2_LSB(__ch)		PTA_BASE(__ch) + 0x10
+#define MMU_PTA2_MSB(__ch)		PTA_BASE(__ch) + 0x14
+#define MMU_PTA3_LSB(__ch)		PTA_BASE(__ch) + 0x18
+#define MMU_PTA3_MSB(__ch)		PTA_BASE(__ch) + 0x1c
+#define MMU_PTA4_LSB(__ch)		PTA_BASE(__ch) + 0x20
+#define MMU_PTA4_MSB(__ch)		PTA_BASE(__ch) + 0x24
+#define MMU_PTA5_LSB(__ch)		PTA_BASE(__ch) + 0x28
+#define MMU_PTA5_MSB(__ch)		PTA_BASE(__ch) + 0x2c
+#define MMU_PTA6_LSB(__ch)		PTA_BASE(__ch) + 0x30
+#define MMU_PTA6_MSB(__ch)		PTA_BASE(__ch) + 0x34
+#define MMU_PTA7_LSB(__ch)		PTA_BASE(__ch) + 0x38
+#define MMU_PTA7_MSB(__ch)		PTA_BASE(__ch) + 0x3c
+
+
+/* -------------- MSI Registers -------------- */
+
+#define MSI				0x0000a000
+
+#define MSI_DELAY_TIMER			0x000
+#define MSI_DELAY_1CLK			(0x00000001 <<  0)
+#define MSI_DELAY_2CLK			(0x00000002 <<  0)
+
+#define MSI_INTA_POLARITY		0x004
+#define MSI_INTA_POLARITY_HIGH		(0x00000001 <<  0)
+
+#define MSI_CONFIG0			0x008
+#define MSI_CONFIG1			0x00c
+#define MSI_CONFIG2			0x010
+#define MSI_CONFIG3			0x014
+#define MSI_CONFIG4			0x018
+#define MSI_CONFIG5			0x01c
+#define MSI_CONFIG6			0x020
+#define MSI_CONFIG7			0x024
+#define MSI_CONFIG8			0x028
+#define MSI_CONFIG9			0x02c
+#define MSI_CONFIG10			0x030
+#define MSI_CONFIG11			0x034
+#define MSI_CONFIG12			0x038
+#define MSI_CONFIG13			0x03c
+#define MSI_CONFIG14			0x040
+#define MSI_CONFIG15			0x044
+#define MSI_CONFIG16			0x048
+#define MSI_CONFIG17			0x04c
+#define MSI_CONFIG18			0x050
+#define MSI_CONFIG19			0x054
+#define MSI_CONFIG20			0x058
+#define MSI_CONFIG21			0x05c
+#define MSI_CONFIG22			0x060
+#define MSI_CONFIG23			0x064
+#define MSI_CONFIG24			0x068
+#define MSI_CONFIG25			0x06c
+#define MSI_CONFIG26			0x070
+#define MSI_CONFIG27			0x074
+#define MSI_CONFIG28			0x078
+#define MSI_CONFIG29			0x07c
+#define MSI_CONFIG30			0x080
+#define MSI_CONFIG31			0x084
+#define MSI_CONFIG32			0x088
+#define MSI_CONFIG33			0x08c
+#define MSI_CONFIG34			0x090
+#define MSI_CONFIG35			0x094
+#define MSI_CONFIG36			0x098
+#define MSI_CONFIG37			0x09c
+#define MSI_CONFIG38			0x0a0
+#define MSI_CONFIG39			0x0a4
+#define MSI_CONFIG40			0x0a8
+#define MSI_CONFIG41			0x0ac
+#define MSI_CONFIG42			0x0b0
+#define MSI_CONFIG43			0x0b4
+#define MSI_CONFIG44			0x0b8
+#define MSI_CONFIG45			0x0bc
+#define MSI_CONFIG46			0x0c0
+#define MSI_CONFIG47			0x0c4
+#define MSI_CONFIG48			0x0c8
+#define MSI_CONFIG49			0x0cc
+#define MSI_CONFIG50			0x0d0
+
+#define MSI_INT_POL_EDGE_RISE		(0x00000001 << 24)
+#define MSI_INT_POL_EDGE_FALL		(0x00000002 << 24)
+#define MSI_INT_POL_EDGE_ANY		(0x00000003 << 24)
+#define MSI_TC				(0x00000007 << 16)
+#define MSI_ID				(0x0000000f <<  0)
+
+#define MSI_INT_STATUS_L		0xfc0
+#define MSI_INT_TAGACK_VI0_0		(0x00000001 <<  0)
+#define MSI_INT_TAGACK_VI0_1		(0x00000001 <<  1)
+#define MSI_INT_TAGACK_VI0_2		(0x00000001 <<  2)
+#define MSI_INT_TAGACK_VI1_0		(0x00000001 <<  3)
+#define MSI_INT_TAGACK_VI1_1		(0x00000001 <<  4)
+#define MSI_INT_TAGACK_VI1_2		(0x00000001 <<  5)
+#define MSI_INT_TAGACK_FGPI_0		(0x00000001 <<  6)
+#define MSI_INT_TAGACK_FGPI_1		(0x00000001 <<  7)
+#define MSI_INT_TAGACK_FGPI_2		(0x00000001 <<  8)
+#define MSI_INT_TAGACK_FGPI_3		(0x00000001 <<  9)
+#define MSI_INT_TAGACK_AI_0		(0x00000001 << 10)
+#define MSI_INT_TAGACK_AI_1		(0x00000001 << 11)
+#define MSI_INT_OVRFLW_VI0_0		(0x00000001 << 12)
+#define MSI_INT_OVRFLW_VI0_1		(0x00000001 << 13)
+#define MSI_INT_OVRFLW_VI0_2		(0x00000001 << 14)
+#define MSI_INT_OVRFLW_VI1_0		(0x00000001 << 15)
+#define MSI_INT_OVRFLW_VI1_1		(0x00000001 << 16)
+#define MSI_INT_OVRFLW_VI1_2		(0x00000001 << 17)
+#define MSI_INT_OVRFLW_FGPI_O		(0x00000001 << 18)
+#define MSI_INT_OVRFLW_FGPI_1		(0x00000001 << 19)
+#define MSI_INT_OVRFLW_FGPI_2		(0x00000001 << 20)
+#define MSI_INT_OVRFLW_FGPI_3		(0x00000001 << 21)
+#define MSI_INT_OVRFLW_AI_0		(0x00000001 << 22)
+#define MSI_INT_OVRFLW_AI_1		(0x00000001 << 23)
+#define MSI_INT_AVINT_VI0		(0x00000001 << 24)
+#define MSI_INT_AVINT_VI1		(0x00000001 << 25)
+#define MSI_INT_AVINT_FGPI_0		(0x00000001 << 26)
+#define MSI_INT_AVINT_FGPI_1		(0x00000001 << 27)
+#define MSI_INT_AVINT_FGPI_2		(0x00000001 << 28)
+#define MSI_INT_AVINT_FGPI_3		(0x00000001 << 29)
+#define MSI_INT_AVINT_AI_0		(0x00000001 << 30)
+#define MSI_INT_AVINT_AI_1		(0x00000001 << 31)
+
+#define MSI_INT_STATUS_H		0xfc4
+#define MSI_INT_UNMAPD_TC_INT		(0x00000001 <<  0)
+#define MSI_INT_EXTINT_0		(0x00000001 <<  1)
+#define MSI_INT_EXTINT_1		(0x00000001 <<  2)
+#define MSI_INT_EXTINT_2		(0x00000001 <<  3)
+#define MSI_INT_EXTINT_3		(0x00000001 <<  4)
+#define MSI_INT_EXTINT_4		(0x00000001 <<  5)
+#define MSI_INT_EXTINT_5		(0x00000001 <<  6)
+#define MSI_INT_EXTINT_6		(0x00000001 <<  7)
+#define MSI_INT_EXTINT_7		(0x00000001 <<  8)
+#define MSI_INT_EXTINT_8		(0x00000001 <<  9)
+#define MSI_INT_EXTINT_9		(0x00000001 << 10)
+#define MSI_INT_EXTINT_10		(0x00000001 << 11)
+#define MSI_INT_EXTINT_11		(0x00000001 << 12)
+#define MSI_INT_EXTINT_12		(0x00000001 << 13)
+#define MSI_INT_EXTINT_13		(0x00000001 << 14)
+#define MSI_INT_EXTINT_14		(0x00000001 << 15)
+#define MSI_INT_EXTINT_15		(0x00000001 << 16)
+#define MSI_INT_I2CINT_0		(0x00000001 << 17)
+#define MSI_INT_I2CINT_1		(0x00000001 << 18)
+
+#define MSI_INT_STATUS_CLR_L		0xfc8
+#define MSI_INT_STATUS_CLR_H		0xfcc
+#define MSI_INT_STATUS_SET_L		0xfd0
+#define MSI_INT_STATUS_SET_H		0xfd4
+#define MSI_INT_ENA_L			0xfd8
+#define MSI_INT_ENA_H			0xfdc
+#define MSI_INT_ENA_CLR_L		0xfe0
+#define MSI_INT_ENA_CLR_H		0xfe4
+#define MSI_INT_ENA_SET_L		0xfe8
+#define MSI_INT_ENA_SET_H		0xfec
+
+#define MSI_SW_RST			0xff0
+#define MSI_SW_RESET			(0x0001 <<  0)
+
+#define MSI_MODULE_ID			0xffc
+
+
+/* -------------- I2C Registers -------------- */
+
+#define I2C_B				0x0000b000
+#define I2C_A				0x0000c000
+
+#define RX_FIFO				0x000
+#define I2C_RX_BYTE			(0x000000ff <<  0)
+
+#define TX_FIFO				0x000
+#define I2C_STOP_BIT			(0x00000001 <<  9)
+#define I2C_START_BIT			(0x00000001 <<  8)
+#define I2C_TX_BYTE			(0x000000ff <<  0)
+
+#define I2C_STATUS			0x008
+#define I2C_TRANSMIT			(0x00000001 << 11)
+#define I2C_RECEIVE			(0x00000001 << 10)
+#define I2C_TRANSMIT_S_PROG		(0x00000001 <<  9)
+#define I2C_TRANSMIT_S_CLEAR		(0x00000001 <<  8)
+#define I2C_TRANSMIT_PROG		(0x00000001 <<  7)
+#define I2C_TRANSMIT_CLEAR		(0x00000001 <<  6)
+#define I2C_RECEIVE_PROG		(0x00000001 <<  5)
+#define I2C_RECEIVE_CLEAR		(0x00000001 <<  4)
+#define I2C_SDA_LINE			(0x00000001 <<  3)
+#define I2C_SCL_LINE			(0x00000001 <<  2)
+#define I2C_START_STOP_FLAG		(0x00000001 <<  1)
+#define I2C_MODE_STATUS			(0x00000001 <<  0)
+
+#define I2C_CONTROL			0x00c
+#define I2C_SCL_CONTROL			(0x00000001 <<  7)
+#define I2C_SDA_CONTROL			(0x00000001 <<  6)
+#define I2C_RECEIVE_PROTECT		(0x00000001 <<  5)
+#define I2C_RECEIVE_PRO_READ		(0x00000001 <<  4)
+#define I2C_TRANS_SELF_CLEAR		(0x00000001 <<  3)
+#define I2C_TRANS_S_SELF_CLEAR		(0x00000001 <<  2)
+#define I2C_SLAVE_ADDR_10BIT		(0x00000001 <<  1)
+#define I2C_RESET			(0x00000001 <<  0)
+
+#define I2C_CLOCK_DIVISOR_HIGH		0x010
+#define I2C_CLOCK_HIGH			(0x0000ffff <<  0)
+
+#define I2C_CLOCK_DIVISOR_LOW		0x014
+#define I2C_CLOCK_LOW			(0x0000ffff <<  0)
+
+#define I2C_RX_LEVEL			0x01c
+#define I2C_RECEIVE_RANGE		(0x0000007f <<  0)
+
+#define I2C_TX_LEVEL			0x020
+#define I2C_TRANSMIT_RANGE		(0x0000007f <<  0)
+
+#define I2C_SDA_HOLD			0x028
+#define I2C_HOLD_TIME			(0x0000007f <<  0)
+
+#define MODULE_CONF			0xfd4
+#define INT_CLR_ENABLE			0xfd8
+#define I2C_CLR_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_CLR_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_CLR_ENABLE_RFDA		(0x00000001 << 10)
+#define I2C_CLR_ENABLE_RFF		(0x00000001 <<  9)
+#define I2C_CLR_ENABLE_STDR		(0x00000001 <<  8)
+#define I2C_CLR_ENABLE_MTDR		(0x00000001 <<  7)
+#define I2C_CLR_ENABLE_IBE		(0x00000001 <<  6)
+#define I2C_CLR_ENABLE_MSMC		(0x00000001 <<  5)
+#define I2C_CLR_ENABLE_SRSD		(0x00000001 <<  4)
+#define I2C_CLR_ENABLE_STSD		(0x00000001 <<  3)
+#define I2C_CLR_ENABLE_MTNA		(0x00000001 <<  2)
+#define I2C_CLR_ENABLE_MAF		(0x00000001 <<  1)
+#define I2C_CLR_ENABLE_MTD		(0x00000001 <<  0)
+
+#define INT_SET_ENABLE			0xfdc
+#define I2C_SET_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_SET_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_SET_ENABLE_RFDA		(0x00000001 << 10)
+#define I2C_SET_ENABLE_RFF		(0x00000001 <<  9)
+#define I2C_SET_ENABLE_STDR		(0x00000001 <<  8)
+#define I2C_SET_ENABLE_MTDR		(0x00000001 <<  7)
+#define I2C_SET_ENABLE_IBE		(0x00000001 <<  6)
+#define I2C_SET_ENABLE_MSMC		(0x00000001 <<  5)
+#define I2C_SET_ENABLE_SRSD		(0x00000001 <<  4)
+#define I2C_SET_ENABLE_STSD		(0x00000001 <<  3)
+#define I2C_SET_ENABLE_MTNA		(0x00000001 <<  2)
+#define I2C_SET_ENABLE_MAF		(0x00000001 <<  1)
+#define I2C_SET_ENABLE_MTD		(0x00000001 <<  0)
+
+#define INT_STATUS			0xfe0
+#define I2C_INTERRUPT_STFNF		(0x00000001 << 12)
+#define I2C_INTERRUPT_MTFNF		(0x00000001 << 11)
+#define I2C_INTERRUPT_RFDA		(0x00000001 << 10)
+#define I2C_INTERRUPTE_RFF		(0x00000001 <<  9)
+#define I2C_SLAVE_INTERRUPT_STDR	(0x00000001 <<  8)
+#define I2C_MASTER_INTERRUPT_MTDR	(0x00000001 <<  7)
+#define I2C_ERROR_IBE			(0x00000001 <<  6)
+#define I2C_MODE_CHANGE_INTER_MSMC	(0x00000001 <<  5)
+#define I2C_SLAVE_RECEIVE_INTER_SRSD	(0x00000001 <<  4)
+#define I2C_SLAVE_TRANSMIT_INTER_STSD	(0x00000001 <<  3)
+#define I2C_ACK_INTER_MTNA		(0x00000001 <<  2)
+#define I2C_FAILURE_INTER_MAF		(0x00000001 <<  1)
+#define I2C_INTERRUPT_MTD		(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define I2C_ENABLE_STFNF		(0x00000001 << 12)
+#define I2C_ENABLE_MTFNF		(0x00000001 << 11)
+#define I2C_ENABLE_RFDA			(0x00000001 << 10)
+#define I2C_ENABLE_RFF			(0x00000001 <<  9)
+#define I2C_ENABLE_STDR			(0x00000001 <<  8)
+#define I2C_ENABLE_MTDR			(0x00000001 <<  7)
+#define I2C_ENABLE_IBE			(0x00000001 <<  6)
+#define I2C_ENABLE_MSMC			(0x00000001 <<  5)
+#define I2C_ENABLE_SRSD			(0x00000001 <<  4)
+#define I2C_ENABLE_STSD			(0x00000001 <<  3)
+#define I2C_ENABLE_MTNA			(0x00000001 <<  2)
+#define I2C_ENABLE_MAF			(0x00000001 <<  1)
+#define I2C_ENABLE_MTD			(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define I2C_CLR_STATUS_STFNF		(0x00000001 << 12)
+#define I2C_CLR_STATUS_MTFNF		(0x00000001 << 11)
+#define I2C_CLR_STATUS_RFDA		(0x00000001 << 10)
+#define I2C_CLR_STATUS_RFF		(0x00000001 <<  9)
+#define I2C_CLR_STATUS_STDR		(0x00000001 <<  8)
+#define I2C_CLR_STATUS_MTDR		(0x00000001 <<  7)
+#define I2C_CLR_STATUS_IBE		(0x00000001 <<  6)
+#define I2C_CLR_STATUS_MSMC		(0x00000001 <<  5)
+#define I2C_CLR_STATUS_SRSD		(0x00000001 <<  4)
+#define I2C_CLR_STATUS_STSD		(0x00000001 <<  3)
+#define I2C_CLR_STATUS_MTNA		(0x00000001 <<  2)
+#define I2C_CLR_STATUS_MAF		(0x00000001 <<  1)
+#define I2C_CLR_STATIS_MTD		(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define I2C_SET_STATUS_STFNF		(0x00000001 << 12)
+#define I2C_SET_STATUS_MTFNF		(0x00000001 << 11)
+#define I2C_SET_STATUS_RFDA		(0x00000001 << 10)
+#define I2C_SET_STATUS_RFF		(0x00000001 <<  9)
+#define I2C_SET_STATUS_STDR		(0x00000001 <<  8)
+#define I2C_SET_STATUS_MTDR		(0x00000001 <<  7)
+#define I2C_SET_STATUS_IBE		(0x00000001 <<  6)
+#define I2C_SET_STATUS_MSMC		(0x00000001 <<  5)
+#define I2C_SET_STATUS_SRSD		(0x00000001 <<  4)
+#define I2C_SET_STATUS_STSD		(0x00000001 <<  3)
+#define I2C_SET_STATUS_MTNA		(0x00000001 <<  2)
+#define I2C_SET_STATUS_MAF		(0x00000001 <<  1)
+#define I2C_SET_STATIS_MTD		(0x00000001 <<  0)
+
+
+
+
+/* -------------- SPI Registers -------------- */
+
+#define SPI				0x0000d000
+
+#define SPI_CONTROL_REG			0x000
+#define SPI_SERIAL_INTER_ENABLE		(0x00000001 <<  7)
+#define SPI_LSB_FIRST_ENABLE		(0x00000001 <<  6)
+#define SPI_MODE_SELECT			(0x00000001 <<  5)
+#define SPI_CLOCK_POLARITY		(0x00000001 <<  4)
+#define SPI_CLOCK_PHASE			(0x00000001 <<  3)
+
+#define SPI_STATUS			0x004
+#define SPI_TRANSFER_FLAG		(0x00000001 <<  7)
+#define SPI_WRITE_COLLISSION		(0x00000001 <<  6)
+#define SPI_READ_OVERRUN		(0x00000001 <<  5)
+#define SPI_MODE_FAULT			(0x00000001 <<  4)
+#define SPI_SLAVE_ABORT			(0x00000001 <<  3)
+
+#define SPI_DATA			0x008
+#define SPI_BIDI_DATA			(0x000000ff <<  0)
+
+#define SPI_CLOCK_COUNTER		0x00c
+#define SPI_CLOCK			(0x00000001 <<  0)
+
+
+
+
+/* -------------- GPIO Registers -------------- */
+
+#define GPIO				0x0000e000
+
+#define GPIO_RD				0x000
+#define GPIO_WR				0x004
+#define GPIO_WR_MODE			0x008
+#define GPIO_OEN			0x00c
+
+#define GPIO_SW_RST			0xff0
+#define GPIO_SW_RESET			(0x00000001 <<  0)
+
+#define GPIO_31				(1 << 31)
+#define GPIO_30				(1 << 30)
+#define GPIO_29				(1 << 29)
+#define GPIO_28				(1 << 28)
+#define GPIO_27				(1 << 27)
+#define GPIO_26				(1 << 26)
+#define GPIO_25				(1 << 25)
+#define GPIO_24				(1 << 24)
+#define GPIO_23				(1 << 23)
+#define GPIO_22				(1 << 22)
+#define GPIO_21				(1 << 21)
+#define GPIO_20				(1 << 20)
+#define GPIO_19				(1 << 19)
+#define GPIO_18				(1 << 18)
+#define GPIO_17				(1 << 17)
+#define GPIO_16				(1 << 16)
+#define GPIO_15				(1 << 15)
+#define GPIO_14				(1 << 14)
+#define GPIO_13				(1 << 13)
+#define GPIO_12				(1 << 12)
+#define GPIO_11				(1 << 11)
+#define GPIO_10				(1 << 10)
+#define GPIO_09				(1 <<  9)
+#define GPIO_08				(1 <<  8)
+#define GPIO_07				(1 <<  7)
+#define GPIO_06				(1 <<  6)
+#define GPIO_05				(1 <<  5)
+#define GPIO_04				(1 <<  4)
+#define GPIO_03				(1 <<  3)
+#define GPIO_02				(1 <<  2)
+#define GPIO_01				(1 <<  1)
+#define GPIO_00				(1 <<  0)
+
+/* -------------- PHI_0 Registers -------------- */
+
+#define	PHI_0				0x0000f000
+
+#define PHI_0_MODE			0x0000
+#define PHI_0_0_CONFIG			0x0008
+#define PHI_0_1_CONFIG			0x000c
+#define PHI_0_2_CONFIG			0x0010
+#define PHI_0_3_CONFIG			0x0014
+
+#define PHI_POLARITY			0x0038
+#define PHI_TIMEOUT			0x003c
+#define PHI_SW_RST			0x0ff0
+
+#define PHI_0_0_RW_0			0x1000
+#define PHI_0_0_RW_511			0x17fc
+
+#define PHI_0_1_RW_0			0x1800
+#define PHI_0_1_RW_511			0x1ffc
+
+#define PHI_0_2_RW_0			0x2000
+#define PHI_0_2_RW_511			0x27fc
+
+#define PHI_0_3_RW_0			0x2800
+#define PHI_0_3_RW_511			0x2ffc
+
+#define PHI_CSN_DEASSERT		(0x00000001 <<  2)
+#define PHI_AUTO_INCREMENT		(0x00000001 <<  1)
+#define PHI_FIFO_MODE			(0x00000001 <<  0)
+
+#define PHI_DELAY_RD_WR			(0x0000001f << 27)
+#define PHI_EXTEND_RDY3			(0x00000003 << 25)
+#define PHI_EXTEND_RDY2			(0x00000003 << 23)
+#define PHI_EXTEND_RDY1			(0x00000003 << 21)
+#define PHI_EXTEND_RDY0			(0x00000003 << 19)
+#define PHI_RDY3_OD			(0x00000001 << 18)
+#define PHI_RDY2_OD			(0x00000001 << 17)
+#define PHI_RDY1_OD			(0x00000001 << 16)
+#define PHI_RDY0_OD			(0x00000001 << 15)
+#define PHI_ALE_POL			(0x00000001 << 14)
+#define PHI_WRN_POL			(0x00000001 << 13)
+#define PHI_RDN_POL			(0x00000001 << 12)
+#define PHI_RDY3_POL			(0x00000001 << 11)
+#define PHI_RDY2_POL			(0x00000001 << 10)
+#define PHI_RDY1_POL			(0x00000001 <<  9)
+#define PHI_RDY0_POL			(0x00000001 <<  8)
+#define PHI_CSN7_POL			(0x00000001 <<  7)
+#define PHI_CSN6_POL			(0x00000001 <<  6)
+#define PHI_CSN5_POL			(0x00000001 <<  5)
+#define PHI_CSN4_POL			(0x00000001 <<  4)
+#define PHI_CSN3_POL			(0x00000001 <<  3)
+#define PHI_CSN2_POL			(0x00000001 <<  2)
+#define PHI_CSN1_POL			(0x00000001 <<  1)
+#define PHI_CSN0_POL			(0x00000001 <<  0)
+
+/* -------------- PHI_1 Registers -------------- */
+
+#define	PHI_1				0x00020000
+
+#define PHI_1_MODE			0x00004
+#define PHI_1_0_CONFIG			0x00018
+#define PHI_1_1_CONFIG			0x0001c
+#define PHI_1_2_CONFIG			0x00020
+#define PHI_1_3_CONFIG			0x00024
+#define PHI_1_4_CONFIG			0x00028
+#define PHI_1_5_CONFIG			0x0002c
+#define PHI_1_6_CONFIG			0x00030
+#define PHI_1_7_CONFIG			0x00034
+
+#define PHI_1_0_RW_0			0x00000
+#define PHI_1_0_RW_16383		0x0fffc
+
+#define PHI_1_1_RW_0			0x1000
+#define PHI_1_1_RW_16383		0x1ffc
+
+#define PHI_1_2_RW_0			0x2000
+#define PHI_1_2_RW_16383		0x2ffc
+
+#define PHI_1_3_RW_0			0x3000
+#define PHI_1_3_RW_16383		0x3ffc
+
+#define PHI_1_4_RW_0			0x4000
+#define PHI_1_4_RW_16383		0x4ffc
+
+#define PHI_1_5_RW_0			0x5000
+#define PHI_1_5_RW_16383		0x5ffc
+
+#define PHI_1_6_RW_0			0x6000
+#define PHI_1_6_RW_16383		0x6ffc
+
+#define PHI_1_7_RW_0			0x7000
+#define PHI_1_7_RW_16383		0x7ffc
+
+/* -------------- CGU Registers -------------- */
+
+#define CGU				0x00013000
+
+#define CGU_SCR_0			0x000
+#define CGU_SCR_1			0x004
+#define CGU_SCR_2			0x008
+#define CGU_SCR_3			0x00c
+#define CGU_SCR_4			0x010
+#define CGU_SCR_5			0x014
+#define CGU_SCR_6			0x018
+#define CGU_SCR_7			0x01c
+#define CGU_SCR_8			0x020
+#define CGU_SCR_9			0x024
+#define CGU_SCR_10			0x028
+#define CGU_SCR_11			0x02c
+#define CGU_SCR_12			0x030
+#define CGU_SCR_13			0x034
+#define CGU_SCR_STOP			(0x00000001 <<  3)
+#define CGU_SCR_RESET			(0x00000001 <<  2)
+#define CGU_SCR_ENF2			(0x00000001 <<  1)
+#define CGU_SCR_ENF1			(0x00000001 <<  0)
+
+#define CGU_FS1_0			0x038
+#define CGU_FS1_1			0x03c
+#define CGU_FS1_2			0x040
+#define CGU_FS1_3			0x044
+#define CGU_FS1_4			0x048
+#define CGU_FS1_5			0x04c
+#define CGU_FS1_6			0x050
+#define CGU_FS1_7			0x054
+#define CGU_FS1_8			0x058
+#define CGU_FS1_9			0x05c
+#define CGU_FS1_10			0x060
+#define CGU_FS1_11			0x064
+#define CGU_FS1_12			0x068
+#define CGU_FS1_13			0x06c
+#define CGU_FS1_PLL			(0x00000000 <<  0)
+
+
+#define CGU_FS2_0			0x070
+#define CGU_FS2_1			0x074
+#define CGU_FS2_2			0x078
+#define CGU_FS2_3			0x07c
+#define CGU_FS2_4			0x080
+#define CGU_FS2_5			0x084
+#define CGU_FS2_6			0x088
+#define CGU_FS2_7			0x08c
+#define CGU_FS2_8			0x090
+#define CGU_FS2_9			0x094
+#define CGU_FS2_10			0x098
+#define CGU_FS2_11			0x09c
+#define CGU_FS2_12			0x0a0
+#define CGU_FS2_13			0x0a4
+
+#define CGU_SSR_0			0x0a8
+#define CGU_SSR_1			0x0ac
+#define CGU_SSR_2			0x0b0
+#define CGU_SSR_3			0x0b4
+#define CGU_SSR_4			0x0b8
+#define CGU_SSR_5			0x0bc
+#define CGU_SSR_6			0x0c0
+#define CGU_SSR_7			0x0c4
+#define CGU_SSR_8			0x0c8
+#define CGU_SSR_9			0x0cc
+#define CGU_SSR_10			0x0d0
+#define CGU_SSR_11			0x0d4
+#define CGU_SSR_12			0x0d8
+#define CGU_SSR_13			0x0dc
+
+#define CGU_PCR_0_0			0x0e0
+#define CGU_PCR_0_1			0x0e4
+#define CGU_PCR_0_2			0x0e8
+#define CGU_PCR_0_3			0x0ec
+#define CGU_PCR_0_4			0x0f0
+#define CGU_PCR_0_5			0x0f4
+#define CGU_PCR_0_6			0x0f8
+#define CGU_PCR_0_7			0x0fc
+#define CGU_PCR_1_0			0x100
+#define CGU_PCR_1_1			0x104
+#define CGU_PCR_2_0			0x108
+#define CGU_PCR_2_1			0x10c
+#define CGU_PCR_3_0			0x110
+#define CGU_PCR_3_1			0x114
+#define CGU_PCR_3_2			0x118
+#define CGU_PCR_4_0			0x11c
+#define CGU_PCR_4_1			0x120
+#define CGU_PCR_5			0x124
+#define CGU_PCR_6			0x128
+#define CGU_PCR_7			0x12c
+#define CGU_PCR_8			0x130
+#define CGU_PCR_9			0x134
+#define CGU_PCR_10			0x138
+#define CGU_PCR_11			0x13c
+#define CGU_PCR_12			0x140
+#define CGU_PCR_13			0x144
+#define CGU_PCR_WAKE_EN			(0x00000001 <<  2)
+#define CGU_PCR_AUTO			(0x00000001 <<  1)
+#define CGU_PCR_RUN			(0x00000001 <<  0)
+
+
+#define CGU_PSR_0_0			0x148
+#define CGU_PSR_0_1			0x14c
+#define CGU_PSR_0_2			0x150
+#define CGU_PSR_0_3			0x154
+#define CGU_PSR_0_4			0x158
+#define CGU_PSR_0_5			0x15c
+#define CGU_PSR_0_6			0x160
+#define CGU_PSR_0_7			0x164
+#define CGU_PSR_1_0			0x168
+#define CGU_PSR_1_1			0x16c
+#define CGU_PSR_2_0			0x170
+#define CGU_PSR_2_1			0x174
+#define CGU_PSR_3_0			0x178
+#define CGU_PSR_3_1			0x17c
+#define CGU_PSR_3_2			0x180
+#define CGU_PSR_4_0			0x184
+#define CGU_PSR_4_1			0x188
+#define CGU_PSR_5			0x18c
+#define CGU_PSR_6			0x190
+#define CGU_PSR_7			0x194
+#define CGU_PSR_8			0x198
+#define CGU_PSR_9			0x19c
+#define CGU_PSR_10			0x1a0
+#define CGU_PSR_11			0x1a4
+#define CGU_PSR_12			0x1a8
+#define CGU_PSR_13			0x1ac
+
+#define CGU_ESR_0_0			0x1b0
+#define CGU_ESR_0_1			0x1b4
+#define CGU_ESR_0_2			0x1b8
+#define CGU_ESR_0_3			0x1bc
+#define CGU_ESR_0_4			0x1c0
+#define CGU_ESR_0_5			0x1c4
+#define CGU_ESR_0_6			0x1c8
+#define CGU_ESR_0_7			0x1cc
+#define CGU_ESR_1_0			0x1d0
+#define CGU_ESR_1_1			0x1d4
+#define CGU_ESR_2_0			0x1d8
+#define CGU_ESR_2_1			0x1dc
+#define CGU_ESR_3_0			0x1e0
+#define CGU_ESR_3_1			0x1e4
+#define CGU_ESR_3_2			0x1e8
+#define CGU_ESR_4_0			0x1ec
+#define CGU_ESR_4_1			0x1f0
+#define CGU_ESR_5			0x1f4
+#define CGU_ESR_6			0x1f8
+#define CGU_ESR_7			0x1fc
+#define CGU_ESR_8			0x200
+#define CGU_ESR_9			0x204
+#define CGU_ESR_10			0x208
+#define CGU_ESR_11			0x20c
+#define CGU_ESR_12			0x210
+#define CGU_ESR_13			0x214
+#define CGU_ESR_FD_EN			(0x00000001 <<  0)
+
+#define CGU_FDC_0			0x218
+#define CGU_FDC_1			0x21c
+#define CGU_FDC_2			0x220
+#define CGU_FDC_3			0x224
+#define CGU_FDC_4			0x228
+#define CGU_FDC_5			0x22c
+#define CGU_FDC_6			0x230
+#define CGU_FDC_7			0x234
+#define CGU_FDC_8			0x238
+#define CGU_FDC_9			0x23c
+#define CGU_FDC_10			0x240
+#define CGU_FDC_11			0x244
+#define CGU_FDC_12			0x248
+#define CGU_FDC_13			0x24c
+#define CGU_FDC_STRETCH			(0x00000001 <<  0)
+#define CGU_FDC_RESET			(0x00000001 <<  1)
+#define CGU_FDC_RUN1			(0x00000001 <<  2)
+#define CGU_FDC_MADD			(0x000000ff <<  3)
+#define CGU_FDC_MSUB			(0x000000ff << 11)
+
+/* -------------- DCS Registers -------------- */
+
+#define DCS				0x00014000
+
+#define DCSC_CTRL			0x000
+#define DCSC_SEL_PLLDI			(0x03ffffff <<  5)
+#define DCSC_TOUT_SEL			(0x0000000f <<  1)
+#define DCSC_TOUT_OFF			(0x00000001 <<  0)
+
+#define DCSC_ADDR			0x00c
+#define DCSC_ERR_TOUT_ADDR		(0x3fffffff <<  2)
+
+#define DCSC_STAT			0x010
+#define DCSC_ERR_TOUT_GNT		(0x0000001f << 24)
+#define DCSC_ERR_TOUT_SEL		(0x0000007f << 10)
+#define DCSC_ERR_TOUT_READ		(0x00000001 <<  8)
+#define DCSC_ERR_TOUT_MASK		(0x0000000f <<  4)
+#define DCSC_ERR_ACK			(0x00000001 <<  1)
+
+#define DCSC_FEATURES			0x040
+#define DCSC_UNIQUE_ID			(0x00000007 << 16)
+#define DCSC_SECURITY			(0x00000001 << 14)
+#define DCSC_NUM_BASE_REGS		(0x00000003 << 11)
+#define DCSC_NUM_TARGETS		(0x0000001f <<  5)
+#define DCSC_NUM_INITIATORS		(0x0000001f <<  0)
+
+#define DCSC_BASE_REG0			0x100
+#define DCSC_BASE_N_REG			(0x00000fff << 20)
+
+#define DCSC_INT_CLR_ENABLE		0xfd8
+#define DCSC_INT_CLR_ENABLE_TOUT	(0x00000001 <<  1)
+#define DCSC_INT_CLR_ENABLE_ERROR	(0x00000001 <<  0)
+
+#define DCSC_INT_SET_ENABLE		0xfdc
+#define DCSC_INT_SET_ENABLE_TOUT	(0x00000001 <<  1)
+#define DCSC_INT_SET_ENABLE_ERROR	(0x00000001 <<  0)
+
+#define DCSC_INT_STATUS			0xfe0
+#define DCSC_INT_STATUS_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_STATUS_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_ENABLE			0xfe4
+#define DCSC_INT_ENABLE_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_ENABLE_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_CLR_STATUS		0xfe8
+#define DCSC_INT_CLEAR_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_CLEAR_ERROR		(0x00000001 <<  0)
+
+#define DCSC_INT_SET_STATUS		0xfec
+#define DCSC_INT_SET_TOUT		(0x00000001 <<  1)
+#define DCSC_INT_SET_ERROR		(0x00000001 <<  0)
+
+
+
+
+/* -------------- GREG Registers -------------- */
+
+#define GREG				0x00012000
+
+#define GREG_SUBSYS_CONFIG		0x000
+#define GREG_SUBSYS_ID			(0x0000ffff << 16)
+#define GREG_SUBSYS_VID			(0x0000ffff <<  0)
+
+#define GREG_MSI_BAR_PMCSR		0x004
+#define GREG_PMCSR_SCALE_7		(0x00000003 << 30)
+#define GREG_PMCSR_SCALE_6		(0x00000003 << 28)
+#define GREG_PMCSR_SCALE_5		(0x00000003 << 26)
+#define GREG_PMCSR_SCALE_4		(0x00000003 << 24)
+#define GREG_PMCSR_SCALE_3		(0x00000003 << 22)
+#define GREG_PMCSR_SCALE_2		(0x00000003 << 20)
+#define GREG_PMCSR_SCALE_1		(0x00000003 << 18)
+#define GREG_PMCSR_SCALE_0		(0x00000003 << 16)
+
+#define GREG_BAR_WIDTH_17		(0x0000001e <<  8)
+#define GREG_BAR_WIDTH_18		(0x0000001c <<  8)
+#define GREG_BAR_WIDTH_19		(0x00000018 <<  8)
+#define GREG_BAR_WIDTH_20		(0x00000010 <<  8)
+
+#define GREG_BAR_PREFETCH		(0x00000001 <<  3)
+#define GREG_MSI_MM_CAP1		(0x00000000 <<  0) // FIXME !
+#define GREG_MSI_MM_CAP2		(0x00000001 <<  0)
+#define GREG_MSI_MM_CAP4		(0x00000002 <<  0)
+#define GREG_MSI_MM_CAP8		(0x00000003 <<  0)
+#define GREG_MSI_MM_CAP16		(0x00000004 <<  0)
+#define GREG_MSI_MM_CAP32		(0x00000005 <<  0)
+
+#define GREG_PMCSR_DATA_1		0x008
+#define GREG_PMCSR_DATA_2		0x00c
+#define GREG_VI_CTRL			0x010
+#define GREG_FGPI_CTRL			0x014
+
+#define GREG_RSTU_CTRL			0x018
+#define GREG_BOOT_READY			(0x00000001 << 13)
+#define GREG_RESET_REQ			(0x00000001 << 12)
+#define GREG_IP_RST_RELEASE		(0x00000001 << 11)
+#define GREG_ADAPTER_RST_RELEASE	(0x00000001 << 10)
+#define GREG_PCIE_CORE_RST_RELEASE	(0x00000001 <<  9)
+#define GREG_BOOT_IP_RST_RELEASE	(0x00000001 <<  8)
+#define GREG_BOOT_RST_RELEASE		(0x00000001 <<  7)
+#define GREG_CGU_RST_RELEASE		(0x00000001 <<  6)
+#define GREG_IP_RST_ASSERT		(0x00000001 <<  5)
+#define GREG_ADAPTER_RST_ASSERT		(0x00000001 <<  4)
+#define GREG_RST_ASSERT			(0x00000001 <<  3)
+#define GREG_BOOT_IP_RST_ASSERT		(0x00000001 <<  2)
+#define GREG_BOOT_RST_ASSERT		(0x00000001 <<  1)
+#define GREG_CGU_RST_ASSERT		(0x00000001 <<  0)
+
+#define GREG_I2C_CTRL			0x01c
+#define GREG_I2C_SLAVE_ADDR		(0x0000007f <<  0)
+
+#define GREG_OVFLW_CTRL			0x020
+#define GREG_OVERFLOW_ENABLE		(0x00001fff <<  0)
+
+#define GREG_TAG_ACK_FLEN		0x024
+#define GREG_TAG_ACK_FLEN_1B		(0x00000000 <<  0)
+#define GREG_TAG_ACK_FLEN_2B		(0x00000001 <<  0)
+#define GREG_TAG_ACK_FLEN_4B		(0x00000002 <<  0)
+#define GREG_TAG_ACK_FLEN_8B		(0x00000003 <<  0)
+
+#define GREG_VIDEO_IN_CTRL		0x028
+
+#define GREG_SPARE_1			0x02c
+#define GREG_SPARE_2			0x030
+#define GREG_SPARE_3			0x034
+#define GREG_SPARE_4			0x038
+#define GREG_SPARE_5			0x03c
+#define GREG_SPARE_6			0x040
+#define GREG_SPARE_7			0x044
+#define GREG_SPARE_8			0x048
+#define GREG_SPARE_9			0x04c
+#define GREG_SPARE_10			0x050
+#define GREG_SPARE_11			0x054
+#define GREG_SPARE_12			0x058
+#define GREG_SPARE_13			0x05c
+#define GREG_SPARE_14			0x060
+#define GREG_SPARE_15			0x064
+
+#define GREG_FAIL_DISABLE		0x068
+#define GREG_BOOT_FAIL_DISABLE		(0x00000001 <<  0)
+
+#define GREG_SW_RST			0xff0
+#define GREG_SW_RESET			(0x00000001 <<  0)
+
+
+
+
+/* BAR = 20 bits */
+
+/* -------------- PHI1 Registers -------------- */
+
+#define PHI_1				0x00020000
+
+
+
+#endif /* __SAA716x_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_rom.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_rom.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_rom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_rom.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,1071 @@
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+#include "saa716x_rom.h"
+#include "saa716x_adap.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+int i;
+
+static int eeprom_read_bytes(struct saa716x_dev *saa716x, u16 reg, u16 len, u8 *val)
+{
+	struct saa716x_i2c *i2c		= saa716x->i2c;
+	struct i2c_adapter *adapter	= &i2c[SAA716x_I2C_BUS_B].i2c_adapter;
+
+	u8 b0[] = { MSB(reg), LSB(reg) };
+	int ret;
+
+	struct i2c_msg msg[] = {
+		{ .addr = 0x50, .flags = 0,	   .buf = b0,  .len = sizeof (b0) },
+		{ .addr = 0x50,	.flags = I2C_M_RD, .buf = val, .len = len }
+	};
+
+	ret = i2c_transfer(adapter, msg, 2);
+	if (ret != 2) {
+		dprintk(SAA716x_ERROR, 1, "read error <reg=0x%02x, ret=%i>", reg, ret);
+		return -EREMOTEIO;
+	}
+
+	return ret;
+}
+
+static int saa716x_read_rombytes(struct saa716x_dev *saa716x, u16 reg, u16 len, u8 *val)
+{
+	struct saa716x_i2c *i2c		= saa716x->i2c;
+	struct i2c_adapter *adapter	= &i2c[SAA716x_I2C_BUS_B].i2c_adapter;
+	struct i2c_msg msg[2];
+
+	u8 b0[2];
+	int ret, count;
+
+	count = len / DUMP_BYTES;
+	if (len % DUMP_BYTES)
+		count++;
+
+	count *= 2;
+
+	for (i = 0; i < count; i += 2) {
+		dprintk(SAA716x_DEBUG, 1, "Length=%d, Count=%d, Reg=0x%02x",
+			len,
+			count,
+			reg);
+
+		b0[0] = MSB(reg);
+		b0[1] = LSB(reg);
+
+		/* Write */
+		msg[0].addr  = 0x50;
+		msg[0].flags = 0;
+		msg[0].buf   = b0;
+		msg[0].len   = 2;
+
+		/* Read */
+		msg[1].addr  = 0x50;
+		msg[1].flags = I2C_M_RD;
+		msg[1].buf   = val;
+
+		if (i == (count - 2)) {
+			/* last message */
+			if (len % DUMP_BYTES) {
+				msg[1].len = len % DUMP_BYTES;
+				dprintk(SAA716x_DEBUG, 1, "Last Message length=%d", len % DUMP_BYTES);
+			} else {
+				msg[1].len = DUMP_BYTES;
+			}
+		} else {
+			msg[1].len = DUMP_BYTES;
+		}
+
+		ret = i2c_transfer(adapter, msg, 2);
+		if (ret != 2) {
+			dprintk(SAA716x_ERROR, 1, "read error <reg=0x%02x, ret=%i>", reg, ret);
+			return -EREMOTEIO;
+		}
+
+		reg += DUMP_BYTES;
+		val += DUMP_BYTES;
+	}
+
+	return 0;
+}
+
+static int saa716x_get_offset(struct saa716x_dev *saa716x, u8 *buf, u32 *offset)
+{
+	int i;
+
+	*offset = 0;
+	for (i = 0; i < 256; i++) {
+		if (!(strncmp("START", buf + i, 5)))
+			break;
+	}
+	dprintk(SAA716x_INFO, 1, "Offset @ %d", i);
+	*offset = i;
+
+	return 0;
+}
+
+static int saa716x_eeprom_header(struct saa716x_dev *saa716x,
+				 struct saa716x_romhdr *rom_header,
+				 u8 *buf,
+				 u32 *offset)
+{
+	memcpy(rom_header, &buf[*offset], sizeof (struct saa716x_romhdr));
+	if (rom_header->header_size != sizeof (struct saa716x_romhdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			sizeof (struct saa716x_romhdr),
+			rom_header->header_size);
+
+		return -1;
+	}
+	*offset += sizeof (struct saa716x_romhdr);
+
+	dprintk(SAA716x_NOTICE, 0, "SAA%02x ROM: Data=%d bytes\n",
+		saa716x->pdev->device,
+		rom_header->data_size);
+
+	dprintk(SAA716x_NOTICE, 0, "SAA%02x ROM: Version=%d\n",
+		saa716x->pdev->device,
+		rom_header->version);
+
+	dprintk(SAA716x_NOTICE, 0, "SAA%02x ROM: Devices=%d\n",
+		saa716x->pdev->device,
+		rom_header->devices);
+
+	dprintk(SAA716x_NOTICE, 0, "SAA%02x ROM: Compressed=%d\n\n",
+		saa716x->pdev->device,
+		rom_header->compression);
+
+	return 0;
+}
+
+int saa716x_dump_eeprom(struct saa716x_dev *saa716x)
+{
+	struct saa716x_romhdr rom_header;
+	u8 buf[DUMP_BYTES];
+	int i, err = 0;
+	u32 offset = 0;
+
+	err = eeprom_read_bytes(saa716x, DUMP_OFFST, DUMP_BYTES, buf);
+	if (err < 0) {
+		dprintk(SAA716x_ERROR, 1, "EEPROM Read error");
+		return err;
+	}
+
+	dprintk(SAA716x_NOTICE, 0, "    Card: %s\n",
+		saa716x->config->model_name);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"    ---------------- SAA%02x ROM @ Offset 0x%02x ----------------",
+		saa716x->pdev->device,
+		DUMP_OFFST);
+
+	for (i = 0; i < DUMP_BYTES; i++) {
+		if ((i % 16) == 0) {
+			dprintk(SAA716x_NOTICE, 0, "\n    ");
+			dprintk(SAA716x_NOTICE, 0, "%04x: ", i);
+		}
+
+		if ((i %  8) == 0)
+			dprintk(SAA716x_NOTICE, 0, " ");
+		if ((i %  4) == 0)
+			dprintk(SAA716x_NOTICE, 0, " ");
+		dprintk(SAA716x_NOTICE, 0, "%02x ", buf[i]);
+	}
+	dprintk(SAA716x_NOTICE, 0, "\n");
+	dprintk(SAA716x_NOTICE, 0,
+		"    ---------------- SAA%02x ROM Dump end ---------------------\n\n",
+		saa716x->pdev->device);
+
+	err = saa716x_get_offset(saa716x, buf, &offset);
+	if (err != 0) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Descriptor not found <%d>", err);
+		return err;
+	}
+	offset += 5;
+	saa716x->id_offst = offset;
+	/* Get header */
+	err = saa716x_eeprom_header(saa716x, &rom_header, buf, &offset);
+	if (err != 0) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Header Read failed <%d>", err);
+		return -1;
+	}
+	saa716x->id_len = rom_header.data_size;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(saa716x_dump_eeprom);
+
+static void saa716x_descriptor_dbg(struct saa716x_dev *saa716x,
+				   u8 *buf,
+				   u32 *offset,
+				   u8 size,
+				   u8 ext_size)
+{
+	int i;
+
+	dprintk(SAA716x_INFO, 0, "       ");
+	for (i = 0; i < 49; i++)
+		dprintk(SAA716x_INFO, 0, "-");
+
+	for (i = 0; i < size + ext_size; i++) {
+		if ((i % 16) == 0)
+			dprintk(SAA716x_INFO, 0, "\n      ");
+		if ((i %  8) == 0)
+			dprintk(SAA716x_INFO, 0, " ");
+		if ((i %  4) == 0)
+			dprintk(SAA716x_INFO, 0, " ");
+
+		dprintk(SAA716x_INFO, 0, "%02x ", buf[*offset + i]);
+	}
+
+	dprintk(SAA716x_INFO, 0, "\n       ");
+	for (i = 0; i < 49; i++)
+		dprintk(SAA716x_INFO, 0, "-");
+	dprintk(SAA716x_INFO, 0, "\n");
+
+}
+
+static int saa716x_decoder_info(struct saa716x_dev *saa716x,
+				u8 *buf,
+				u32 *offset)
+{
+	struct saa716x_decoder_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_decoder_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_decoder_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_decoder_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext Data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_gpio_info(struct saa716x_dev *saa716x,
+			     u8 *buf,
+			     u32 *offset)
+{
+	struct saa716x_gpio_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_gpio_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_gpio_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_gpio_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Pins=%d\n",
+		saa716x->pdev->device,
+		header.pins);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+
+	return 0;
+}
+
+static int saa716x_video_decoder_info(struct saa716x_dev *saa716x,
+				      u8 *buf,
+				      u32 *offset)
+{
+	struct saa716x_video_decoder_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_video_decoder_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_video_decoder_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_video_decoder_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: PORT 0=0x%02x\n",
+		saa716x->pdev->device,
+		header.video_port0);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: PORT 1=0x%02x\n",
+		saa716x->pdev->device,
+		header.video_port1);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: PORT 2=0x%02x\n",
+		saa716x->pdev->device,
+		header.video_port2);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: VBI PORT ID=0x%02x\n",
+		saa716x->pdev->device,
+		header.vbi_port_id);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Video PORT Type=0x%02x\n",
+		saa716x->pdev->device,
+		header.video_port_type);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: VBI PORT Type=0x%02x\n",
+		saa716x->pdev->device,
+		header.vbi_port_type);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Encoder PORT Type=0x%02x\n",
+		saa716x->pdev->device,
+		header.encoder_port_type);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Video Output=0x%02x\n",
+		saa716x->pdev->device,
+		header.video_output);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: VBI Output=0x%02x\n",
+		saa716x->pdev->device,
+		header.vbi_output);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Encoder Output=0x%02x\n",
+		saa716x->pdev->device,
+		header.encoder_output);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_audio_decoder_info(struct saa716x_dev *saa716x,
+				      u8 *buf,
+				      u32 *offset)
+{
+	struct saa716x_audio_decoder_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_audio_decoder_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_audio_decoder_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_audio_decoder_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_event_source_info(struct saa716x_dev *saa716x,
+				     u8 *buf,
+				     u32 *offset)
+{
+	struct saa716x_evsrc_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_evsrc_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_evsrc_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_evsrc_hdr));
+
+		return -1;
+	}
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_crossbar_info(struct saa716x_dev *saa716x,
+				 u8 *buf,
+				 u32 *offset)
+{
+	struct saa716x_xbar_hdr header;
+	struct saa716x_xbar_pair_info pair_info;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_xbar_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_xbar_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_xbar_hdr));
+
+		return -1;
+	}
+
+	memcpy(&pair_info, &buf[*offset], sizeof (struct saa716x_xbar_pair_info));
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Pairs=%d\n",
+		saa716x->pdev->device,
+		header.pair_inputs);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data + (sizeof (struct saa716x_xbar_pair_info) * header.pair_inputs);
+	return 0;
+}
+
+static int saa716x_tuner_info(struct saa716x_dev *saa716x,
+			      u8 *buf,
+			      u32 *offset)
+{
+	struct saa716x_tuner_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_tuner_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_tuner_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_tuner_hdr));
+
+		return -1;
+	}
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_pll_info(struct saa716x_dev *saa716x,
+			    u8 *buf,
+			    u32 *offset)
+{
+	struct saa716x_pll_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_pll_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_pll_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_pll_hdr));
+
+		return -1;
+	}
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_channel_decoder_info(struct saa716x_dev *saa716x,
+					u8 *buf,
+					u32 *offset)
+{
+	struct saa716x_channel_decoder_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_channel_decoder_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_channel_decoder_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_channel_decoder_hdr));
+
+		return -1;
+	}
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_encoder_info(struct saa716x_dev *saa716x,
+				u8 *buf,
+				u32 *offset)
+{
+	struct saa716x_encoder_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_encoder_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_encoder_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_encoder_hdr));
+
+		return -1;
+	}
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_ir_info(struct saa716x_dev *saa716x,
+			   u8 *buf,
+			   u32 *offset)
+{
+	struct saa716x_ir_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_ir_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_ir_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_ir_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_eeprom_info(struct saa716x_dev *saa716x,
+			       u8 *buf,
+			       u32 *offset)
+{
+	struct saa716x_eeprom_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_eeprom_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_eeprom_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_eeprom_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_filter_info(struct saa716x_dev *saa716x,
+			       u8 *buf,
+			       u32 *offset)
+{
+	struct saa716x_filter_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_filter_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_filter_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_filter_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_streamdev_info(struct saa716x_dev *saa716x,
+				  u8 *buf,
+				  u32 *offset)
+{
+	struct saa716x_streamdev_hdr header;
+
+	memcpy(&header, &buf[*offset], sizeof (struct saa716x_streamdev_hdr));
+	saa716x_descriptor_dbg(saa716x, buf, offset, header.size, header.ext_data);
+	if (header.size != sizeof (struct saa716x_streamdev_hdr)) {
+		dprintk(SAA716x_ERROR, 1,
+			"ERROR: Header size mismatch! Read size=%d bytes, Expected=%d",
+			header.size,
+			sizeof (struct saa716x_streamdev_hdr));
+
+		return -1;
+	}
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		header.size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n",
+		saa716x->pdev->device,
+		header.ext_data);
+
+	*offset += header.size + header.ext_data;
+	return 0;
+}
+
+static int saa716x_unknown_device_info(struct saa716x_dev *saa716x,
+				       u8 *buf,
+				       u32 *offset)
+{
+	u8 size;
+	u8 ext_size = 0;
+
+	size = buf[*offset];
+	if (size > 1)
+		ext_size = buf[*offset + size -1];
+
+	saa716x_descriptor_dbg(saa716x, buf, offset, size, ext_size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		size);
+
+	dprintk(SAA716x_NOTICE, 0,
+		"        SAA%02x ROM: Ext data=%d bytes\n\n",
+		saa716x->pdev->device,
+		ext_size);
+
+	*offset += size + ext_size;
+	return 0;
+}
+
+
+static void saa716x_device_dbg(struct saa716x_dev *saa716x,
+			       u8 *buf,
+			       u32 *offset,
+			       u8 size,
+			       u8 ext_size,
+			       u8 addr_size)
+{
+	int i;
+
+	dprintk(SAA716x_INFO, 0, "   ");
+	for (i = 0; i < 53; i++)
+		dprintk(SAA716x_INFO, 0, "-");
+
+	for (i = 0; i < size + ext_size + addr_size; i++) {
+		if ((i % 16) == 0)
+			dprintk(SAA716x_INFO, 0, "\n  ");
+		if ((i %  8) == 0)
+			dprintk(SAA716x_INFO, 0, " ");
+		if ((i %  4) == 0)
+			dprintk(SAA716x_INFO, 0, " ");
+
+		dprintk(SAA716x_INFO, 0, "%02x ", buf[*offset + i]);
+	}
+
+	dprintk(SAA716x_INFO, 0, "\n   ");
+	for (i = 0; i < 53; i++)
+		dprintk(SAA716x_INFO, 0, "-");
+	dprintk(SAA716x_INFO, 0, "\n");
+
+}
+
+
+static int saa716x_device_info(struct saa716x_dev *saa716x,
+			       struct saa716x_devinfo *device,
+			       u8 *buf,
+			       u32 *offset)
+{
+	u8 address = 0;
+
+	memcpy(device, &buf[*offset], sizeof (struct saa716x_devinfo));
+	if (device->struct_size != sizeof (struct saa716x_devinfo)) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Device size mismatch! Read=%d bytes, expected=%d bytes",
+		device->struct_size,
+		sizeof (struct saa716x_devinfo));
+
+		return -1;
+	}
+
+	saa716x_device_dbg(saa716x,
+			   buf,
+			   offset,
+			   device->struct_size,
+			   device->extd_data_size,
+			   device->addr_size);
+
+	*offset += device->struct_size;
+
+	if (device->addr_size) {
+		address = buf[*offset];
+		address >>= 1;
+		*offset += device->addr_size;
+	}
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Device @ 0x%02x\n",
+		saa716x->pdev->device,
+		address);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Size=%d bytes\n",
+		saa716x->pdev->device,
+		device->struct_size);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Device ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->device_id);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Master ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->master_devid);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Bus ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->master_busid);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Device type=0x%02x\n",
+		saa716x->pdev->device,
+		device->device_type);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Implementation ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->implem_id);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Path ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->path_id);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: GPIO ID=0x%02x\n",
+		saa716x->pdev->device,
+		device->gpio_id);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Address=%d bytes\n",
+		saa716x->pdev->device,
+		device->addr_size);
+
+	dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: Extended data=%d bytes\n\n",
+		saa716x->pdev->device,
+		device->extd_data_size);
+
+	if (device->extd_data_size) {
+		u32 mask;
+
+		mask = 0x00000001;
+		while (mask) {
+			if (device->device_type & mask) {
+				switch (mask) {
+				case DECODER_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found decoder device\n",
+						saa716x->pdev->device);
+
+					saa716x_decoder_info(saa716x, buf, offset);
+					break;
+
+				case GPIO_SOURCE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found GPIO device\n",
+						saa716x->pdev->device);
+
+					saa716x_gpio_info(saa716x, buf, offset);
+					break;
+
+				case VIDEO_DECODER:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Video Decoder device\n",
+						saa716x->pdev->device);
+
+					saa716x_video_decoder_info(saa716x, buf, offset);
+					break;
+
+				case AUDIO_DECODER:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Audio Decoder device\n",
+						saa716x->pdev->device);
+
+					saa716x_audio_decoder_info(saa716x, buf, offset);
+					break;
+
+				case EVENT_SOURCE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Event source\n",
+						saa716x->pdev->device);
+
+					saa716x_event_source_info(saa716x, buf, offset);
+					break;
+
+				case CROSSBAR:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Crossbar device\n",
+						saa716x->pdev->device);
+
+					saa716x_crossbar_info(saa716x, buf, offset);
+					break;
+
+				case TUNER_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Tuner device\n",
+						saa716x->pdev->device);
+
+					saa716x_tuner_info(saa716x, buf, offset);
+					break;
+
+				case PLL_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found PLL device\n",
+						saa716x->pdev->device);
+
+					saa716x_pll_info(saa716x, buf, offset);
+					break;
+
+				case CHANNEL_DECODER:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Channel Demodulator device\n",
+						saa716x->pdev->device);
+
+					saa716x_channel_decoder_info(saa716x, buf, offset);
+					break;
+
+				case RDS_DECODER:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found RDS Decoder device\n",
+						saa716x->pdev->device);
+
+					saa716x_unknown_device_info(saa716x, buf, offset);
+					break;
+
+				case ENCODER_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Encoder device\n",
+						saa716x->pdev->device);
+
+					saa716x_encoder_info(saa716x, buf, offset);
+					break;
+
+				case IR_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found IR device\n",
+						saa716x->pdev->device);
+
+					saa716x_ir_info(saa716x, buf, offset);
+					break;
+
+				case EEPROM_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found EEPROM device\n",
+						saa716x->pdev->device);
+
+					saa716x_eeprom_info(saa716x, buf, offset);
+					break;
+
+				case NOISE_FILTER:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Noise filter device\n",
+						saa716x->pdev->device);
+
+					saa716x_filter_info(saa716x, buf, offset);
+					break;
+
+				case LNx_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found LNx device\n",
+						saa716x->pdev->device);
+
+					saa716x_unknown_device_info(saa716x, buf, offset);
+					break;
+
+				case STREAM_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found streaming device\n",
+						saa716x->pdev->device);
+
+					saa716x_streamdev_info(saa716x, buf, offset);
+					break;
+
+				case CONFIGSPACE_DEVICE:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found Configspace device\n",
+						saa716x->pdev->device);
+
+					saa716x_unknown_device_info(saa716x, buf, offset);
+					break;
+
+				default:
+					dprintk(SAA716x_NOTICE, 0,
+						"        SAA%02x ROM: Found unknown device\n",
+						saa716x->pdev->device);
+
+					saa716x_unknown_device_info(saa716x, buf, offset);
+					break;
+				}
+			}
+			mask <<= 1;
+		}
+	}
+
+	dprintk(SAA716x_NOTICE, 0, "\n");
+
+	return 0;
+}
+
+int saa716x_eeprom_data(struct saa716x_dev *saa716x)
+{
+	struct saa716x_romhdr rom_header;
+	struct saa716x_devinfo *device;
+
+	u8 buf[1024];
+	int i, ret = 0;
+	u32 offset = 0;
+
+	/* dump */
+	ret = saa716x_read_rombytes(saa716x, saa716x->id_offst, saa716x->id_len + 8, buf);
+	if (ret < 0) {
+		dprintk(SAA716x_ERROR, 1, "EEPROM Read error <%d>", ret);
+		goto err0;
+	}
+
+	/* Get header */
+	ret = saa716x_eeprom_header(saa716x, &rom_header, buf, &offset);
+	if (ret != 0) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Header Read failed <%d>", ret);
+		goto err0;
+	}
+
+	/* allocate for device info */
+	device = kzalloc(sizeof (struct saa716x_devinfo) * rom_header.devices, GFP_KERNEL);
+	if (device == NULL) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: out of memory");
+		goto err0;
+	}
+
+	for (i = 0; i < rom_header.devices; i++) {
+		dprintk(SAA716x_NOTICE, 0, "    SAA%02x ROM: ===== Device %d =====\n",
+			saa716x->pdev->device,
+			i);
+
+		ret = saa716x_device_info(saa716x, &device[i], buf, &offset);
+		if (ret != 0) {
+			dprintk(SAA716x_ERROR, 1, "ERROR: Device info read failed <%d>", ret);
+			goto err1;
+		}
+	}
+
+	kfree(device);
+
+	return 0;
+
+err1:
+	kfree(device);
+
+err0:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(saa716x_eeprom_data);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_rom.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_rom.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_rom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_rom.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,253 @@
+#ifndef __SAA716x_ROM_H
+#define __SAA716x_ROM_H
+
+
+#define MSB(__x)	((__x >> 8) & 0xff)
+#define LSB(__x)	(__x & 0xff)
+
+#define DUMP_BYTES	0xf0
+#define DUMP_OFFST	0x000
+
+struct saa716x_dev;
+
+struct saa716x_romhdr {
+	u16	header_size;
+	u8	compression;
+	u8	version;
+	u16	data_size;
+	u8	devices;
+	u8	checksum;
+} __attribute__((packed));
+
+struct saa716x_devinfo {
+	u8	struct_size;
+	u8	device_id;
+	u8	master_devid;
+	u8	master_busid;
+	u32	device_type;
+	u16	implem_id;
+	u8	path_id;
+	u8	gpio_id;
+	u16	addr_size;
+	u16	extd_data_size;
+} __attribute__((packed));
+
+enum saa716x_device_types {
+	DECODER_DEVICE		= 0x00000001,
+	GPIO_SOURCE		= 0x00000002,
+	VIDEO_DECODER		= 0x00000004,
+	AUDIO_DECODER		= 0x00000008,
+	EVENT_SOURCE		= 0x00000010,
+	CROSSBAR		= 0x00000020,
+	TUNER_DEVICE		= 0x00000040,
+	PLL_DEVICE		= 0x00000080,
+	CHANNEL_DECODER		= 0x00000100,
+	RDS_DECODER		= 0x00000200,
+	ENCODER_DEVICE		= 0x00000400,
+	IR_DEVICE		= 0x00000800,
+	EEPROM_DEVICE		= 0x00001000,
+	NOISE_FILTER		= 0x00002000,
+	LNx_DEVICE		= 0x00004000,
+	STREAM_DEVICE		= 0x00010000,
+	CONFIGSPACE_DEVICE	= 0x80000000
+};
+
+struct saa716x_decoder_hdr {
+	u8 size;
+	u8 ext_data;
+};
+
+struct saa716x_decoder_info {
+	struct saa716x_decoder_hdr decoder_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_gpio_hdr {
+	u8 size;
+	u8 pins;
+	u8 rsvd;
+	u8 ext_data;
+};
+
+struct saa716x_gpio_info {
+	struct saa716x_gpio_hdr gpio_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_video_decoder_hdr {
+	u8 size;
+	u8 video_port0;
+	u8 video_port1;
+	u8 video_port2;
+	u8 vbi_port_id;
+	u8 video_port_type;
+	u8 vbi_port_type;
+	u8 encoder_port_type;
+	u8 video_output;
+	u8 vbi_output;
+	u8 encoder_output;
+	u8 ext_data;
+};
+
+struct saa716x_video_decoder_info {
+	struct saa716x_video_decoder_hdr decoder_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_audio_decoder_hdr {
+	u8 size;
+	u8 port;
+	u8 output;
+	u8 ext_data;
+};
+
+struct saa716x_audio_decoder_info {
+	struct saa716x_audio_decoder_hdr decoder_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_evsrc_hdr {
+	u8 size;
+	u8 master_devid;
+	u16 condition_id;
+	u8 rsvd;
+	u8 ext_data;
+};
+
+struct saa716x_evsrc_info {
+	struct saa716x_evsrc_hdr evsrc_hdr;
+	u8 *ext_data;
+};
+
+enum saa716x_input_pair_type {
+	TUNER_SIF	= 0x00,
+	TUNER_LINE	= 0x01,
+	TUNER_SPDIF	= 0x02,
+	TUNER_NONE	= 0x03,
+	CVBS_LINE	= 0x04,
+	CVBS_SPDIF	= 0x05,
+	CVBS_NONE	= 0x06,
+	YC_LINE		= 0x07,
+	YC_SPDIF	= 0x08,
+	YC_NONE		= 0x09,
+	YPbPr_LINE	= 0x0a,
+	YPbPr_SPDIF	= 0x0b,
+	YPbPr_NONE	= 0x0c,
+	NO_LINE		= 0x0d,
+	NO_SPDIF	= 0x0e,
+	RGB_LINE	= 0x0f,
+	RGB_SPDIF	= 0x10,
+	RGB_NONE	= 0x11
+};
+
+struct saa716x_xbar_pair_info {
+	u8 pair_input_type;
+	u8 video_input_id;
+	u8 audio_input_id;
+};
+
+struct saa716x_xbar_hdr {
+	u8 size;
+	u8 pair_inputs;
+	u8 pair_route_default;
+	u8 ext_data;
+};
+
+struct saa716x_xbar_info {
+	struct saa716x_xbar_hdr xbar_hdr;
+	struct saa716x_xbar_pair_info *pair_info;
+	u8 *ext_data;
+};
+
+struct saa716x_tuner_hdr {
+	u8 size;
+	u8 ext_data;
+};
+
+struct saa716x_tuner_info {
+	struct saa716x_tuner_hdr tuner_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_pll_hdr {
+	u8 size;
+	u8 ext_data;
+};
+
+struct saa716x_pll_info {
+	struct saa716x_pll_hdr pll_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_channel_decoder_hdr {
+	u8 size;
+	u8 port;
+	u8 ext_data;
+};
+
+struct saa716x_channel_decoder_info {
+	struct saa716x_channel_decoder_hdr channel_dec_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_encoder_hdr {
+	u8 size;
+	u8 stream_port0;
+	u8 stream_port1;
+	u8 ext_data;
+};
+
+struct saa716x_encoder_info {
+	struct saa716x_encoder_hdr encoder_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_ir_hdr {
+	u8 size;
+	u8 ir_caps;
+	u8 ext_data;
+};
+
+struct saa716x_ir_info {
+	struct saa716x_ir_hdr ir_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_eeprom_hdr {
+	u8 size;
+	u8 rel_device;
+	u8 ext_data;
+};
+
+struct saa716x_eeprom_info {
+	struct saa716x_eeprom_hdr eeprom_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_filter_hdr {
+	u8 size;
+	u8 video_decoder;
+	u8 audio_decoder;
+	u8 event_source;
+	u8 ext_data;
+};
+
+struct saa716x_filter_info {
+	struct saa716x_filter_hdr filter_hdr;
+	u8 *ext_data;
+};
+
+struct saa716x_streamdev_hdr {
+	u8 size;
+	u8 ext_data;
+};
+
+struct saa716x_streamdev_info {
+	struct saa716x_streamdev_hdr streamdev_hdr;
+	u8 *ext_data;
+};
+
+extern int saa716x_dump_eeprom(struct saa716x_dev *saa716x);
+extern int saa716x_eeprom_data(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_ROM_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_spi.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,313 @@
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <linux/spi/spi.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_spi_reg.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+#if 0 // not needed atm
+int saa716x_spi_irqevent(struct saa716x_dev *saa716x)
+{
+	u32 stat, mask;
+
+	BUG_ON(saa716x == NULL);
+
+	stat = SAA716x_EPRD(SPI, SPI_STATUS);
+	mask = SAA716x_EPRD(SPI, SPI_CONTROL_REG) & SPI_SERIAL_INTER_ENABLE;
+	if ((!stat && !mask))
+		return -1;
+
+	dprintk(SAA716x_DEBUG, 0, "SPI event: Stat=<%02x>", stat);
+
+	if (stat & SPI_TRANSFER_FLAG)
+		dprintk(SAA716x_DEBUG, 0, "<TXFER> ");
+	if (stat & SPI_WRITE_COLLISSION)
+		dprintk(SAA716x_DEBUG, 0, "<WCOLL> ");
+	if (stat & SPI_READ_OVERRUN)
+		dprintk(SAA716x_DEBUG, 0, "<ROFLW> ");
+	if (stat & SPI_MODE_FAULT)
+		dprintk(SAA716x_DEBUG, 0, "<FAULT> ");
+	if (stat & SPI_SLAVE_ABORT)
+		dprintk(SAA716x_DEBUG, 0, "<ABORT> ");
+
+	return 0;
+}
+#endif
+
+void saa716x_spi_write(struct saa716x_dev *saa716x, const u8 *data, int length)
+{
+	int i;
+	u32 value;
+	int rounds;
+
+	for (i = 0; i < length; i++) {
+		SAA716x_EPWR(SPI, SPI_DATA, data[i]);
+		rounds = 0;
+		value = SAA716x_EPRD(SPI, SPI_STATUS);
+
+		while ((value & SPI_TRANSFER_FLAG) == 0 && rounds < 5000) {
+			value = SAA716x_EPRD(SPI, SPI_STATUS);
+			rounds++;
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(saa716x_spi_write);
+
+#if 0 // not needed atm
+static int saa716x_spi_status(struct saa716x_dev *saa716x, u32 *status)
+{
+	u32 stat;
+
+	stat = SAA716x_EPRD(SPI, SPI_STATUS);
+
+	if (stat & SPI_TRANSFER_FLAG)
+		dprintk(SAA716x_DEBUG, 1, "Transfer complete <%02x>", stat);
+
+	if (stat & SPI_WRITE_COLLISSION)
+		dprintk(SAA716x_DEBUG, 1, "Write collission <%02x>", stat);
+
+	if (stat & SPI_READ_OVERRUN)
+		dprintk(SAA716x_DEBUG, 1, "Read Overrun <%02x>", stat);
+
+	if (stat & SPI_MODE_FAULT)
+		dprintk(SAA716x_DEBUG, 1, "MODE fault <%02x>", stat);
+
+	if (stat & SPI_SLAVE_ABORT)
+		dprintk(SAA716x_DEBUG, 1, "SLAVE abort <%02x>", stat);
+
+	*status = stat;
+
+	return 0;
+}
+
+#define SPI_CYCLE_TIMEOUT	100
+
+static int saa716x_spi_xfer(struct saa716x_dev *saa716x, u32 *data)
+{
+	u32 i, status = 0;
+
+	/* write data and wait for completion */
+	SAA716x_EPWR(SPI, SPI_DATA, data[i]);
+	for (i = 0; i < SPI_CYCLE_TIMEOUT; i++) {
+		msleep(10);
+		saa716x_spi_status(saa716x, &status);
+#if 0
+		if (status & SPI_TRANSFER_FLAG) {
+			data = SAA716x_EPRD(SPI, SPI_DATA);
+			return 0;
+		}
+#endif
+		if (status & (SPI_WRITE_COLLISSION	|
+			      SPI_READ_OVERRUN		|
+			      SPI_MODE_FAULT		|
+			      SPI_SLAVE_ABORT))
+
+			return -EIO;
+	}
+
+	return -EIO;
+}
+
+#if 0
+static int saa716x_spi_wr(struct saa716x_dev *saa716x, const u8 *data, int length)
+{
+	struct saa716x_spi_config *config = saa716x->spi_config;
+	u32 gpio_mask;
+	int ret = 0;
+
+	// protect against multiple access
+	spin_lock(&saa716x->gpio_lock);
+
+	// configure the module
+	saa716x_spi_config(saa716x);
+
+    // check input
+
+	// change polarity of GPIO if active high
+	if (config->active_hi) {
+		select  = 1;
+		release = 0;
+	}
+
+	// configure GPIO, first set output register to low selected level
+	saa716x_gpio_write(saa716x, gpio, select);
+
+	// set mode register to register controlled (0)
+	gpio_mask = (1 << gpio);
+	saa716x_set_gpio_mode(saa716x, gpio_mask, 0);
+
+	// configure bit as output (0)
+	saa716x_gpio_ctl(saa716x, gpio_mask, 0);
+
+	// wait at least 500ns before sending a byte
+	msleep(1);
+
+	// send command
+	for (i = 0; i < dwCommandSize; i++) {
+		ucData   = 0;
+//		dwStatus = TransferData(pucCommand[i], &ucData);
+		ret = saa716x_spi_xfer(saa716x);
+		//tmDBGPRINTEx(4,("Info: Command 0x%x ", pucCommand[i]  ));
+
+		/* If command length > 1, disable CS at the end of each command.
+		 * But after the last command byte CS must be left active!
+		 */
+		if ((dwCommandSize > 1) && (i < dwCommandSize - 1)) {
+
+			saa716x_gpio_write(saa716x, gpio, release);
+			msleep(1); /* 500 nS minimum */
+			saa716x_gpio_write(saa716x, gpio, select);
+		}
+
+		if (ret != 0) {
+			dprintk(SAA716x_ERROR, 1, "ERROR: Command transfer failed");
+			msleep(1); /* 500 nS minimum */
+			saa716x_gpio_write(saa716x, gpio, release); /* release GPIO */
+			spin_unlock(&saa716x->spi_lock);
+			return ret;
+		}
+
+		if (config->LSB_first)
+			dwTransferByte++;
+		else
+			dwTransferByte--;
+	}
+
+// assume that the byte order is the same as the bit order
+
+// send read address
+
+// send data
+
+// wait at least 500ns before releasing slave
+
+// release GPIO pin
+
+	// release spinlock
+	spin_unlock(&saa716x->gpio_lock);
+}
+#endif
+
+#define MODEBITS (SPI_CPOL | SPI_CPHA)
+
+static int saa716x_spi_setup(struct spi_device *spi)
+{
+	struct spi_master *master		= spi->master;
+	struct saa716x_spi_state *saa716x_spi	= spi_master_get_devdata(master);
+	struct saa716x_dev *saa716x		= saa716x_spi->saa716x;
+	struct saa716x_spi_config *config	= &saa716x->spi_config;
+
+	u8 control = 0;
+
+	if (spi->mode & ~MODEBITS) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Unsupported MODE bits <%x>",
+			spi->mode & ~MODEBITS);
+
+		return -EINVAL;
+	}
+
+	SAA716x_EPWR(SPI, SPI_CLOCK_COUNTER, config->clk_count);
+
+	control |= SPI_MODE_SELECT; /* SPI Master */
+
+	if (config->LSB_first)
+		control |= SPI_LSB_FIRST_ENABLE;
+
+	if (config->clk_pol)
+		control |= SPI_CLOCK_POLARITY;
+
+	if (config->clk_pha)
+		control |= SPI_CLOCK_PHASE;
+
+	SAA716x_EPWR(SPI, SPI_CONTROL_REG, control);
+
+	return 0;
+}
+
+static void saa716x_spi_cleanup(struct spi_device *spi)
+{
+
+}
+
+static int saa716x_spi_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct spi_master *master		= spi->master;
+	struct saa716x_spi_state *saa716x_spi	= spi_master_get_devdata(master);
+	struct saa716x_dev *saa716x		= saa716x_spi->saa716x;
+	unsigned long flags;
+
+	spin_lock_irqsave(&saa716x->gpio_lock, flags);
+#if 0
+	if (saa716x_spi->run == QUEUE_STOPPED) {
+		spin_unlock_irqrestore(&saa716x_spi->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+	msg->actual_length = 0;
+	msg->status = -EINPROGRESS;
+	msg->state = START_STATE;
+
+	list_add_tail(&msg->queue, &saa716x_spi->queue);
+
+	if (saa716x_spi->run == QUEUE_RUNNING && !saa716x_spi->busy)
+		queue_work(saa716x_spi->workqueue, &saa716x_spi->pump_messages);
+#endif
+	spin_unlock_irqrestore(&saa716x->gpio_lock, flags);
+
+	return 0;
+}
+
+int __devinit saa716x_spi_init(struct saa716x_dev *saa716x)
+{
+	struct pci_dev *pdev = saa716x->pdev;
+	struct spi_master *master;
+	struct saa716x_spi_state *saa716x_spi;
+	int ret;
+
+	dprintk(SAA716x_DEBUG, 1, "Initializing SAA%02x I2C Core",
+		saa716x->pdev->device);
+
+	master = spi_alloc_master(&pdev->dev, sizeof (struct saa716x_spi_state));
+	if (master == NULL) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: Cannot allocate SPI Master!");
+		return -ENOMEM;
+	}
+
+	saa716x_spi		= spi_master_get_devdata(master);
+	saa716x_spi->master	= master;
+	saa716x_spi->saa716x	= saa716x;
+	saa716x->saa716x_spi	= saa716x_spi;
+
+	master->bus_num		= pdev->bus->number;
+	master->num_chipselect	= 1; /* TODO! use config */
+	master->cleanup		= saa716x_spi_cleanup;
+	master->setup		= saa716x_spi_setup;
+	master->transfer	= saa716x_spi_transfer;
+
+	ret = spi_register_master(master);
+	if (ret != 0) {
+		dprintk(SAA716x_ERROR, 1, "ERROR: registering SPI Master!");
+		goto err;
+	}
+err:
+	spi_master_put(master);
+	return ret;
+}
+EXPORT_SYMBOL(saa716x_spi_init);
+
+void __devexit saa716x_spi_exit(struct saa716x_dev *saa716x)
+{
+	struct saa716x_spi_state *saa716x_spi = saa716x->saa716x_spi;
+
+	spi_unregister_master(saa716x_spi->master);
+	dprintk(SAA716x_DEBUG, 1, "SAA%02x SPI succesfully removed", saa716x->pdev->device);
+}
+EXPORT_SYMBOL(saa716x_spi_exit);
+#endif
+
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_spi.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,23 @@
+#ifndef __SAA716x_SPI_H
+#define __SAA716x_SPI_H
+
+struct saa716x_dev;
+
+struct saa716x_spi_config {
+	u8 clk_count;
+	u8 clk_pol:1;
+	u8 clk_pha:1;
+	u8 LSB_first:1;
+};
+
+struct saa716x_spi_state {
+	struct spi_master *master;
+	struct saa716x_dev *saa716x;
+};
+
+extern void saa716x_spi_write(struct saa716x_dev *saa716x, const u8 *data, int length);
+
+extern int saa716x_spi_init(struct saa716x_dev *saa716x);
+extern void saa716x_spi_exit(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_SPI_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_spi_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_spi_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_spi_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,27 @@
+#ifndef __SAA716x_SPI_REG_H
+#define __SAA716x_SPI_REG_H
+
+/* -------------- SPI Registers -------------- */
+
+#define SPI_CONTROL_REG			0x000
+#define SPI_SERIAL_INTER_ENABLE		(0x00000001 <<  7)
+#define SPI_LSB_FIRST_ENABLE		(0x00000001 <<  6)
+#define SPI_MODE_SELECT			(0x00000001 <<  5)
+#define SPI_CLOCK_POLARITY		(0x00000001 <<  4)
+#define SPI_CLOCK_PHASE			(0x00000001 <<  3)
+
+#define SPI_STATUS			0x004
+#define SPI_TRANSFER_FLAG		(0x00000001 <<  7)
+#define SPI_WRITE_COLLISSION		(0x00000001 <<  6)
+#define SPI_READ_OVERRUN		(0x00000001 <<  5)
+#define SPI_MODE_FAULT			(0x00000001 <<  4)
+#define SPI_SLAVE_ABORT			(0x00000001 <<  3)
+
+#define SPI_DATA			0x008
+#define SPI_BIDI_DATA			(0x000000ff <<  0)
+
+#define SPI_CLOCK_COUNTER		0x00c
+#define SPI_CLOCK			(0x00000001 <<  0)
+
+
+#endif /* __SAA716x_SPI_REG_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_vip.c linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip.c
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_vip.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip.c	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,23 @@
+#include <linux/kernel.h>
+
+#include "saa716x_mod.h"
+
+#include "saa716x_vip_reg.h"
+#include "saa716x_spi.h"
+#include "saa716x_priv.h"
+
+void saa716x_vipint_disable(struct saa716x_dev *saa716x)
+{
+	SAA716x_EPWR(VI0, INT_ENABLE, 0); /* disable VI 0 IRQ */
+	SAA716x_EPWR(VI1, INT_ENABLE, 0); /* disable VI 1 IRQ */
+	SAA716x_EPWR(VI0, INT_CLR_STATUS, 0x3ff); /* clear IRQ */
+	SAA716x_EPWR(VI1, INT_CLR_STATUS, 0x3ff); /* clear IRQ */
+}
+EXPORT_SYMBOL_GPL(saa716x_vipint_disable);
+
+void saa716x_vip_disable(struct saa716x_dev *saa716x)
+{
+       SAA716x_EPWR(VI0, VIP_POWER_DOWN, VI_PWR_DWN);
+       SAA716x_EPWR(VI1, VIP_POWER_DOWN, VI_PWR_DWN);
+}
+EXPORT_SYMBOL_GPL(saa716x_vip_disable);
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_vip.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_vip.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,9 @@
+#ifndef __SAA716x_VIP_H
+#define __SAA716x_VIP_H
+
+struct saa716x_dev;
+
+extern void saa716x_vipint_disable(struct saa716x_dev *saa716x);
+extern void saa716x_vip_disable(struct saa716x_dev *saa716x);
+
+#endif /* __SAA716x_VIP_H */
diff -urN linux-3.4.3/drivers/media/common/saa716x/saa716x_vip_reg.h linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip_reg.h
--- linux-3.4.3/drivers/media/common/saa716x/saa716x_vip_reg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/common/saa716x/saa716x_vip_reg.h	2012-06-18 22:34:17.064032272 +0200
@@ -0,0 +1,127 @@
+#ifndef __SAA716x_VIP_REG_H
+#define __SAA716x_VIP_REG_H
+
+/* -------------- VIP Registers -------------- */
+
+#define VI_MODE				0x000
+#define VID_CFEN			(0x00000003 << 30)
+#define VID_OSM				(0x00000001 << 29)
+#define VID_FSEQ			(0x00000001 << 28)
+#define AUX_CFEN			(0x00000003 << 26)
+#define AUX_OSM				(0x00000001 << 25)
+#define AUX_FSEQ			(0x00000001 << 24)
+#define AUX_ANC_DATA			(0x00000003 << 22)
+#define AUX_ANC_RAW			(0x00000001 << 21)
+#define RST_ON_ERR			(0x00000001 << 17)
+#define SOFT_RESET			(0x00000001 << 16)
+#define IFF_CLAMP			(0x00000001 << 14)
+#define IFF_MODE			(0x00000003 << 12)
+#define DFF_CLAMP			(0x00000001 << 10)
+#define DFF_MODE			(0x00000003 <<  8)
+#define HSP_CLAMP			(0x00000001 <<  3)
+#define HSP_RGB				(0x00000001 <<  2)
+#define HSP_MODE			(0x00000003 <<  0)
+
+#define RCRB_CTRL			0x004
+#define RCRB_CFG_ADDR			0x008
+#define RCRB_CFG_EXT_ADDR		0x00c
+#define RCRB_IO_ADDR			0x010
+#define RCRB_MEM_LADDR			0x014
+#define RCRB_MEM_UADDR			0x018
+#define RCRB_DATA			0x01c
+#define RCRB_MASK			0x020
+#define RCRB_MSG_HDR			0x040
+#define RCRB_MSG_PL0			0x044
+#define RCRB_MSG_PL1			0x048
+
+#define ID_MASK0			0x020
+#define VI_ID_MASK_0			(0x000000ff <<  8)
+#define VI_DATA_ID_0			(0x000000ff <<  0)
+
+#define ID_MASK1			0x024
+#define VI_ID_MASK_1			(0x000000ff <<  8)
+#define VI_DATA_ID_1			(0x000000ff <<  0)
+
+#define VIP_LINE_THRESH			0x040
+#define VI_LCTHR			(0x000007ff <<  0)
+
+#define VIN_FORMAT			0x100
+#define VI_VSRA				(0x00000003 << 30)
+#define VI_SYNCHD			(0x00000001 << 25)
+#define VI_DUAL_STREAM			(0x00000001 << 24)
+#define VI_NHDAUX			(0x00000001 << 20)
+#define VI_NPAR				(0x00000001 << 19)
+#define VI_VSEL				(0x00000003 << 14)
+#define VI_TWOS				(0x00000001 << 13)
+#define VI_TPG				(0x00000001 << 12)
+#define VI_FREF				(0x00000001 << 10)
+#define VI_FTGL				(0x00000001 <<  9)
+#define VI_SF				(0x00000001 <<  3)
+#define VI_FZERO			(0x00000001 <<  2)
+#define VI_REVS				(0x00000001 <<  1)
+#define VI_REHS				(0x00000001 <<  0)
+
+#define TC76543210			0x800
+#define TCFEDCBA98			0x804
+#define PHYCFG				0x900
+#define CONFIG				0xfd4
+#define INT_ENABLE_CLR			0xfd8
+#define INT_ENABLE_SET			0xfdc
+
+
+#define INT_STATUS			0xfe0
+#define VI_STAT_FID_AUX			(0x00000001 << 31)
+#define VI_STAT_FID_VID			(0x00000001 << 30)
+#define VI_STAT_FID_VPI			(0x00000001 << 29)
+#define VI_STAT_LINE_COUNT		(0x00000fff << 16)
+#define VI_STAT_AUX_OVRFLW		(0x00000001 <<  9)
+#define VI_STAT_VID_OVRFLW		(0x00000001 <<  8)
+#define VI_STAT_WIN_SEQBRK		(0x00000001 <<  7)
+#define VI_STAT_FID_SEQBRK		(0x00000001 <<  6)
+#define VI_STAT_LINE_THRESH		(0x00000001 <<  5)
+#define VI_STAT_AUX_WRAP		(0x00000001 <<  4)
+#define VI_STAT_AUX_START_IN		(0x00000001 <<  3)
+#define VI_STAT_AUX_END_OUT		(0x00000001 <<  2)
+#define VI_STAT_VID_START_IN		(0x00000001 <<  1)
+#define VI_STAT_VID_END_OUT		(0x00000001 <<  0)
+
+#define INT_ENABLE			0xfe4
+#define VI_ENABLE_AUX_OVRFLW		(0x00000001 <<  9)
+#define VI_ENABLE_VID_OVRFLW		(0x00000001 <<  8)
+#define VI_ENABLE_WIN_SEQBRK		(0x00000001 <<  7)
+#define VI_ENABLE_FID_SEQBRK		(0x00000001 <<  6)
+#define VI_ENABLE_LINE_THRESH		(0x00000001 <<  5)
+#define VI_ENABLE_AUX_WRAP		(0x00000001 <<  4)
+#define VI_ENABLE_AUX_START_IN		(0x00000001 <<  3)
+#define VI_ENABLE_AUX_END_OUT		(0x00000001 <<  2)
+#define VI_ENABLE_VID_START_IN		(0x00000001 <<  1)
+#define VI_ENABLE_VID_END_OUT		(0x00000001 <<  0)
+
+#define INT_CLR_STATUS			0xfe8
+#define VI_CLR_STATUS_AUX_OVRFLW	(0x00000001 <<  9)
+#define VI_CLR_STATUS_VID_OVRFLW	(0x00000001 <<  8)
+#define VI_CLR_STATUS_WIN_SEQBRK	(0x00000001 <<  7)
+#define VI_CLR_STATUS_FID_SEQBRK	(0x00000001 <<  6)
+#define VI_CLR_STATUS_LINE_THRESH	(0x00000001 <<  5)
+#define VI_CLR_STATUS_AUX_WRAP		(0x00000001 <<  4)
+#define VI_CLR_STATUS_AUX_START_IN	(0x00000001 <<  3)
+#define VI_CLR_STATUS_AUX_END_OUT	(0x00000001 <<  2)
+#define VI_CLR_STATUS_VID_START_IN	(0x00000001 <<  1)
+#define VI_CLR_STATUS_VID_END_OUT	(0x00000001 <<  0)
+
+#define INT_SET_STATUS			0xfec
+#define VI_SET_STATUS_AUX_OVRFLW	(0x00000001 <<  9)
+#define VI_SET_STATUS_VID_OVRFLW	(0x00000001 <<  8)
+#define VI_SET_STATUS_WIN_SEQBRK	(0x00000001 <<  7)
+#define VI_SET_STATUS_FID_SEQBRK	(0x00000001 <<  6)
+#define VI_SET_STATUS_LINE_THRESH	(0x00000001 <<  5)
+#define VI_SET_STATUS_AUX_WRAP		(0x00000001 <<  4)
+#define VI_SET_STATUS_AUX_START_IN	(0x00000001 <<  3)
+#define VI_SET_STATUS_AUX_END_OUT	(0x00000001 <<  2)
+#define VI_SET_STATUS_VID_START_IN	(0x00000001 <<  1)
+#define VI_SET_STATUS_VID_END_OUT	(0x00000001 <<  0)
+
+#define VIP_POWER_DOWN			0xff4
+#define VI_PWR_DWN			(0x00000001 << 31)
+
+#endif /* __SAA716x_VIP_REG_H */
diff -urN linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge-core.c linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge-core.c
--- linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge-core.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge-core.c	2012-06-18 22:31:48.134032196 +0200
@@ -36,7 +36,6 @@
 #include <linux/swab.h>
 #include <linux/vmalloc.h>
 #include "ddbridge.h"
-
 #include "ddbridge-regs.h"
 
 #include "tda18271c2dd.h"
@@ -44,14 +43,60 @@
 #include "stv090x.h"
 #include "lnbh24.h"
 #include "drxk.h"
+#if 0
+#include "stv0367.h"
+#else
+#include "stv0367dd.h"
+#endif
+#if 0
+#include "tda18212.h"
+#else
+#include "tda18212dd.h"
+#endif
+
+static int adapter_alloc;
+module_param(adapter_alloc, int, 0444);
+MODULE_PARM_DESC(adapter_alloc, "0-one adapter per io, 1-one per tab with io, 2-one per tab, 3-one for all");
+
+static int ts_loop = -1;
+module_param(ts_loop, int, 0444);
+MODULE_PARM_DESC(ts_loop, "TS in/out on port ts_loop");
 
 DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);
 
+static struct ddb *ddbs[32];
+
 /* MSI had problems with lost interrupts, fixed but needs testing */
-#undef CONFIG_PCI_MSI
+/* #undef CONFIG_PCI_MSI */
+
+/******************************************************************************/
+
+static inline void ddbwritel(struct ddb *dev, u32 val, u32 adr)
+{
+	writel(val, (char *) (dev->regs+(adr)));
+}
+
+static inline u32 ddbreadl(struct ddb *dev, u32 adr)
+{
+	return readl((char *) (dev->regs+(adr)));
+}
+
+#define ddbcpyto(_dev, _adr, _src, _count)   memcpy_toio((char *) \
+					(_dev->regs + (_adr)), (_src), (_count))
+
+#define ddbcpyfrom(_dev, _dst, _adr, _count) memcpy_fromio((_dst), (char *) \
+					(_dev->regs + (_adr)), (_count))
+
 
 /******************************************************************************/
 
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};
+
+	return (i2c_transfer(adap, &msg, 1) == 1) ? 0 : -1;
+}
+
 static int i2c_read(struct i2c_adapter *adapter, u8 adr, u8 *val)
 {
 	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
@@ -59,10 +104,31 @@
 	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
 }
 
+static int i2c_read_regs(struct i2c_adapter *adapter,
+			 u8 adr, u8 reg, u8 *val, u8 len)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = &reg, .len   = 1},
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int i2c_read_regs16(struct i2c_adapter *adapter,
+			   u8 adr, u16 reg, u8 *val, u8 len)
+{
+	u8 reg16[2] = { reg >> 8, reg };
+	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
+				   .buf  = (u8 *)&reg16, .len   = 2},
+				  {.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = val,  .len   = len } };
+	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
+}
+
 static int i2c_read_reg(struct i2c_adapter *adapter, u8 adr, u8 reg, u8 *val)
 {
 	struct i2c_msg msgs[2] = {{.addr = adr,  .flags = 0,
-				   .buf  = &reg, .len   = 1 },
+				   .buf  = &reg, .len   = 1},
 				  {.addr = adr,  .flags = I2C_M_RD,
 				   .buf  = val,  .len   = 1 } };
 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
@@ -71,14 +137,22 @@
 static int i2c_read_reg16(struct i2c_adapter *adapter, u8 adr,
 			  u16 reg, u8 *val)
 {
-	u8 msg[2] = {reg>>8, reg&0xff};
+	u8 msg[2] = {reg >> 8, reg & 0xff};
 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
 				   .buf  = msg, .len   = 2},
 				  {.addr = adr, .flags = I2C_M_RD,
-				   .buf  = val, .len   = 1} };
+				   .buf  = val, .len   = 1 } };
 	return (i2c_transfer(adapter, msgs, 2) == 2) ? 0 : -1;
 }
 
+static int i2c_write_reg16(struct i2c_adapter *adap, u8 adr,
+			   u16 reg, u8 val)
+{
+	u8 msg[3] = {reg >> 8, reg & 0xff, val};
+
+	return i2c_write(adap, adr, msg, 3);
+}
+
 static int ddb_i2c_cmd(struct ddb_i2c *i2c, u32 adr, u32 cmd)
 {
 	struct ddb *dev = i2c->dev;
@@ -86,18 +160,18 @@
 	u32 val;
 
 	i2c->done = 0;
-	ddbwritel((adr << 9) | cmd, i2c->regs + I2C_COMMAND);
+	ddbwritel(dev, (adr << 9) | cmd, i2c->regs + I2C_COMMAND);
 	stat = wait_event_timeout(i2c->wq, i2c->done == 1, HZ);
 	if (stat <= 0) {
 		printk(KERN_ERR "I2C timeout\n");
 		{ /* MSI debugging*/
-			u32 istat = ddbreadl(INTERRUPT_STATUS);
+			u32 istat = ddbreadl(dev, INTERRUPT_STATUS);
 			printk(KERN_ERR "IRS %08x\n", istat);
-			ddbwritel(istat, INTERRUPT_ACK);
+			ddbwritel(dev, istat, INTERRUPT_ACK);
 		}
 		return -EIO;
 	}
-	val = ddbreadl(i2c->regs+I2C_COMMAND);
+	val = ddbreadl(dev, i2c->regs+I2C_COMMAND);
 	if (val & 0x70000)
 		return -EIO;
 	return 0;
@@ -106,7 +180,7 @@
 static int ddb_i2c_master_xfer(struct i2c_adapter *adapter,
 			       struct i2c_msg msg[], int num)
 {
-	struct ddb_i2c *i2c = (struct ddb_i2c *)i2c_get_adapdata(adapter);
+	struct ddb_i2c *i2c = (struct ddb_i2c *) i2c_get_adapdata(adapter);
 	struct ddb *dev = i2c->dev;
 	u8 addr = 0;
 
@@ -117,8 +191,8 @@
 	    !(msg[0].flags & I2C_M_RD)) {
 		memcpy_toio(dev->regs + I2C_TASKMEM_BASE + i2c->wbuf,
 			    msg[0].buf, msg[0].len);
-		ddbwritel(msg[0].len|(msg[1].len << 16),
-			  i2c->regs+I2C_TASKLENGTH);
+		ddbwritel(dev, msg[0].len|(msg[1].len << 16),
+			  i2c->regs + I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 1)) {
 			memcpy_fromio(msg[1].buf,
 				      dev->regs + I2C_TASKMEM_BASE + i2c->rbuf,
@@ -126,17 +200,16 @@
 			return num;
 		}
 	}
-
 	if (num == 1 && !(msg[0].flags & I2C_M_RD)) {
-		ddbcpyto(I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
-		ddbwritel(msg[0].len, i2c->regs + I2C_TASKLENGTH);
+		ddbcpyto(dev, I2C_TASKMEM_BASE + i2c->wbuf, msg[0].buf, msg[0].len);
+		ddbwritel(dev, msg[0].len, i2c->regs + I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 2))
 			return num;
 	}
 	if (num == 1 && (msg[0].flags & I2C_M_RD)) {
-		ddbwritel(msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
+		ddbwritel(dev, msg[0].len << 16, i2c->regs + I2C_TASKLENGTH);
 		if (!ddb_i2c_cmd(i2c, addr, 3)) {
-			ddbcpyfrom(msg[0].buf,
+			ddbcpyfrom(dev, msg[0].buf,
 				   I2C_TASKMEM_BASE + i2c->rbuf, msg[0].len);
 			return num;
 		}
@@ -161,7 +234,7 @@
 	struct ddb_i2c *i2c;
 	struct i2c_adapter *adap;
 
-	for (i = 0; i < dev->info->port_num; i++) {
+	for (i = 0; i < dev->info->i2c_num; i++) {
 		i2c = &dev->i2c[i];
 		adap = &i2c->adap;
 		i2c_del_adapter(adap);
@@ -174,15 +247,15 @@
 	struct ddb_i2c *i2c;
 	struct i2c_adapter *adap;
 
-	for (i = 0; i < dev->info->port_num; i++) {
+	for (i = 0; i < dev->info->i2c_num; i++) {
 		i2c = &dev->i2c[i];
 		i2c->dev = dev;
 		i2c->nr = i;
 		i2c->wbuf = i * (I2C_TASKMEM_SIZE / 4);
 		i2c->rbuf = i2c->wbuf + (I2C_TASKMEM_SIZE / 8);
 		i2c->regs = 0x80 + i * 0x20;
-		ddbwritel(I2C_SPEED_100, i2c->regs + I2C_TIMING);
-		ddbwritel((i2c->rbuf << 16) | i2c->wbuf,
+		ddbwritel(dev, I2C_SPEED_100, i2c->regs + I2C_TIMING);
+		ddbwritel(dev, (i2c->rbuf << 16) | i2c->wbuf,
 			  i2c->regs + I2C_TASKADDRESS);
 		init_waitqueue_head(&i2c->wq);
 
@@ -217,69 +290,94 @@
 /******************************************************************************/
 /******************************************************************************/
 
-#if 0
-static void set_table(struct ddb *dev, u32 off,
-		      dma_addr_t *pbuf, u32 num)
+static void ddb_set_dma_table(struct ddb *dev, struct ddb_dma *dma)
 {
 	u32 i, base;
 	u64 mem;
 
-	base = DMA_BASE_ADDRESS_TABLE + off;
-	for (i = 0; i < num; i++) {
-		mem = pbuf[i];
-		ddbwritel(mem & 0xffffffff, base + i * 8);
-		ddbwritel(mem >> 32, base + i * 8 + 4);
+	if (!dma)
+		return;
+	base = DMA_BASE_ADDRESS_TABLE + dma->nr * 0x100;
+	for (i = 0; i < dma->num; i++) {
+		mem = dma->pbuf[i];
+		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
+		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
 	}
+	dma->bufreg = (dma->div << 16) |
+		((dma->num & 0x1f) << 11) |
+		((dma->size >> 7) & 0x7ff);
 }
-#endif
 
-static void ddb_address_table(struct ddb *dev)
+static void ddb_set_dma_tables(struct ddb *dev)
 {
-	u32 i, j, base;
-	u64 mem;
-	dma_addr_t *pbuf;
+	u32 i;
 
-	for (i = 0; i < dev->info->port_num * 2; i++) {
-		base = DMA_BASE_ADDRESS_TABLE + i * 0x100;
-		pbuf = dev->input[i].pbuf;
-		for (j = 0; j < dev->input[i].dma_buf_num; j++) {
-			mem = pbuf[j];
-			ddbwritel(mem & 0xffffffff, base + j * 8);
-			ddbwritel(mem >> 32, base + j * 8 + 4);
-		}
-	}
-	for (i = 0; i < dev->info->port_num; i++) {
-		base = DMA_BASE_ADDRESS_TABLE + 0x800 + i * 0x100;
-		pbuf = dev->output[i].pbuf;
-		for (j = 0; j < dev->output[i].dma_buf_num; j++) {
-			mem = pbuf[j];
-			ddbwritel(mem & 0xffffffff, base + j * 8);
-			ddbwritel(mem >> 32, base + j * 8 + 4);
-		}
-	}
+	for (i = 0; i < dev->info->port_num * 2; i++)
+		ddb_set_dma_table(dev, dev->input[i].dma);
+	for (i = 0; i < dev->info->port_num; i++)
+		ddb_set_dma_table(dev, dev->output[i].dma);
 }
 
-static void io_free(struct pci_dev *pdev, u8 **vbuf,
-		    dma_addr_t *pbuf, u32 size, int num)
+static void dma_free(struct pci_dev *pdev, struct ddb_dma *dma)
 {
 	int i;
 
-	for (i = 0; i < num; i++) {
-		if (vbuf[i]) {
-			pci_free_consistent(pdev, size, vbuf[i], pbuf[i]);
-			vbuf[i] = 0;
+	if (!dma)
+		return;
+	for (i = 0; i < dma->num; i++) {
+		if (dma->vbuf[i]) {
+			pci_free_consistent(pdev, dma->size,
+					    dma->vbuf[i], dma->pbuf[i]);
+			dma->vbuf[i] = 0;
 		}
 	}
 }
 
-static int io_alloc(struct pci_dev *pdev, u8 **vbuf,
-		    dma_addr_t *pbuf, u32 size, int num)
+static void ddb_redirect_dma(struct ddb *dev,
+			     struct ddb_dma *sdma,
+			     struct ddb_dma *ddma)
+{
+	u32 i, base;
+	u64 mem;
+
+	sdma->bufreg = ddma->bufreg;
+	base = DMA_BASE_ADDRESS_TABLE + sdma->nr * 0x100;
+	for (i = 0; i < ddma->num; i++) {
+		mem = ddma->pbuf[i];
+		ddbwritel(dev, mem & 0xffffffff, base + i * 8);
+		ddbwritel(dev, mem >> 32, base + i * 8 + 4);
+	}
+}
+
+static void ddb_unredirect(struct ddb_port *port)
+{
+	struct ddb_input *ored, *ired;
+
+	ored = port->output->redirect;
+	ired = port->input[0]->redirect;
+
+	if (!ored || !ired)
+		return;
+	if (ired->port->output->redirect == port->input[0]) {
+		ired->port->output->redirect = ored;
+		ddb_set_dma_table(port->dev, port->input[0]->dma);
+		ddb_redirect_dma(ored->port->dev, ored->dma, ired->port->output->dma);
+	} else
+		ddb_set_dma_table(ored->port->dev, ored->dma);
+	ored->redirect = ired;
+	port->input[0]->redirect = 0;
+	port->output->redirect = 0;
+}
+
+static int dma_alloc(struct pci_dev *pdev, struct ddb_dma *dma)
 {
 	int i;
 
-	for (i = 0; i < num; i++) {
-		vbuf[i] = pci_alloc_consistent(pdev, size, &pbuf[i]);
-		if (!vbuf[i])
+	if (!dma)
+		return 0;
+	for (i = 0; i < dma->num; i++) {
+		dma->vbuf[i] = pci_alloc_consistent(pdev, dma->size, &dma->pbuf[i]);
+		if (!dma->vbuf[i])
 			return -ENOMEM;
 	}
 	return 0;
@@ -294,34 +392,23 @@
 		port = &dev->port[i];
 		switch (port->class) {
 		case DDB_PORT_TUNER:
-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
-				     port->input[0]->pbuf,
-				     port->input[0]->dma_buf_size,
-				     port->input[0]->dma_buf_num) < 0)
+			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
 				return -1;
-			if (io_alloc(dev->pdev, port->input[1]->vbuf,
-				     port->input[1]->pbuf,
-				     port->input[1]->dma_buf_size,
-				     port->input[1]->dma_buf_num) < 0)
+			if (dma_alloc(dev->pdev, port->input[1]->dma) < 0)
 				return -1;
 			break;
 		case DDB_PORT_CI:
-			if (io_alloc(dev->pdev, port->input[0]->vbuf,
-				     port->input[0]->pbuf,
-				     port->input[0]->dma_buf_size,
-				     port->input[0]->dma_buf_num) < 0)
+		case DDB_PORT_LOOP:
+			if (dma_alloc(dev->pdev, port->input[0]->dma) < 0)
 				return -1;
-			if (io_alloc(dev->pdev, port->output->vbuf,
-				     port->output->pbuf,
-				     port->output->dma_buf_size,
-				     port->output->dma_buf_num) < 0)
+			if (dma_alloc(dev->pdev, port->output->dma) < 0)
 				return -1;
 			break;
 		default:
 			break;
 		}
 	}
-	ddb_address_table(dev);
+	ddb_set_dma_tables(dev);
 	return 0;
 }
 
@@ -332,18 +419,11 @@
 
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
-		io_free(dev->pdev, port->input[0]->vbuf,
-			port->input[0]->pbuf,
-			port->input[0]->dma_buf_size,
-			port->input[0]->dma_buf_num);
-		io_free(dev->pdev, port->input[1]->vbuf,
-			port->input[1]->pbuf,
-			port->input[1]->dma_buf_size,
-			port->input[1]->dma_buf_num);
-		io_free(dev->pdev, port->output->vbuf,
-			port->output->pbuf,
-			port->output->dma_buf_size,
-			port->output->dma_buf_num);
+
+		ddb_unredirect(port);
+		dma_free(dev->pdev, port->input[0]->dma);
+		dma_free(dev->pdev, port->input[1]->dma);
+		dma_free(dev->pdev, port->output->dma);
 	}
 }
 
@@ -351,90 +431,116 @@
 {
 	struct ddb *dev = input->port->dev;
 
-	spin_lock_irq(&input->lock);
-	input->cbuf = 0;
-	input->coff = 0;
+	spin_lock_irq(&input->dma->lock);
+	input->dma->cbuf = 0;
+	input->dma->coff = 0;
 
 	/* reset */
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(2, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
-
-	ddbwritel((1 << 16) |
-		  (input->dma_buf_num << 11) |
-		  (input->dma_buf_size >> 7),
-		  DMA_BUFFER_SIZE(input->nr));
-	ddbwritel(0, DMA_BUFFER_ACK(input->nr));
-
-	ddbwritel(1, DMA_BASE_WRITE);
-	ddbwritel(3, DMA_BUFFER_CONTROL(input->nr));
-	ddbwritel(9, TS_INPUT_CONTROL(input->nr));
-	input->running = 1;
-	spin_unlock_irq(&input->lock);
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(dev, 2, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
+
+	ddbwritel(dev, input->dma->bufreg, DMA_BUFFER_SIZE(input->dma->nr));
+	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
+
+	ddbwritel(dev, 1, DMA_BASE_WRITE);
+	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(input->dma->nr));
+	ddbwritel(dev, 9, TS_INPUT_CONTROL(input->nr));
+	input->dma->running = 1;
+	spin_unlock_irq(&input->dma->lock);
+	/* printk(KERN_INFO "input_start %d\n", input->nr); */
 }
 
 static void ddb_input_stop(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
 
-	spin_lock_irq(&input->lock);
-	ddbwritel(0, TS_INPUT_CONTROL(input->nr));
-	ddbwritel(0, DMA_BUFFER_CONTROL(input->nr));
-	input->running = 0;
-	spin_unlock_irq(&input->lock);
+	spin_lock_irq(&input->dma->lock);
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(input->nr));
+	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(input->dma->nr));
+	input->dma->running = 0;
+	spin_unlock_irq(&input->dma->lock);
 }
 
 static void ddb_output_start(struct ddb_output *output)
 {
 	struct ddb *dev = output->port->dev;
 
-	spin_lock_irq(&output->lock);
-	output->cbuf = 0;
-	output->coff = 0;
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(2, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0x3c, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel((1 << 16) |
-		  (output->dma_buf_num << 11) |
-		  (output->dma_buf_size >> 7),
-		  DMA_BUFFER_SIZE(output->nr + 8));
-	ddbwritel(0, DMA_BUFFER_ACK(output->nr + 8));
-
-	ddbwritel(1, DMA_BASE_READ);
-	ddbwritel(3, DMA_BUFFER_CONTROL(output->nr + 8));
-	/* ddbwritel(0xbd, TS_OUTPUT_CONTROL(output->nr)); */
-	ddbwritel(0x1d, TS_OUTPUT_CONTROL(output->nr));
-	output->running = 1;
-	spin_unlock_irq(&output->lock);
+	spin_lock_irq(&output->dma->lock);
+	output->dma->cbuf = 0;
+	output->dma->coff = 0;
+	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(dev, 0x3c, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(dev, output->dma->bufreg, DMA_BUFFER_SIZE(output->dma->nr));
+	ddbwritel(dev, 0, DMA_BUFFER_ACK(output->dma->nr));
+
+	ddbwritel(dev, 1, DMA_BASE_READ);
+	ddbwritel(dev, 3, DMA_BUFFER_CONTROL(output->dma->nr));
+	if (output->port->input[0]->port->class == DDB_PORT_LOOP)
+		ddbwritel(dev, 0x05, TS_OUTPUT_CONTROL(output->nr));
+	else
+		ddbwritel(dev, 0x1d, TS_OUTPUT_CONTROL(output->nr));
+	output->dma->running = 1;
+	spin_unlock_irq(&output->dma->lock);
+	/* printk(KERN_INFO "output_start %d\n", output->nr); */
+}
+
+#if 0
+static void ddb_input_start_all(struct ddb_input *input)
+{
+	struct ddb_input *next;
+
+	ddb_input_start(input);
+	while ((next = input->redirect) &&
+	       next != input) {
+		ddb_input_start(next);
+		ddb_output_start(next->port->output);
+	}
 }
+#endif
 
 static void ddb_output_stop(struct ddb_output *output)
 {
 	struct ddb *dev = output->port->dev;
 
-	spin_lock_irq(&output->lock);
-	ddbwritel(0, TS_OUTPUT_CONTROL(output->nr));
-	ddbwritel(0, DMA_BUFFER_CONTROL(output->nr + 8));
-	output->running = 0;
-	spin_unlock_irq(&output->lock);
+	spin_lock_irq(&output->dma->lock);
+	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(output->nr));
+	ddbwritel(dev, 0, DMA_BUFFER_CONTROL(output->dma->nr));
+	output->dma->running = 0;
+	spin_unlock_irq(&output->dma->lock);
+}
+
+#if 0
+static void ddb_input_stop_all(struct ddb_input *input)
+{
+	struct ddb_input *next;
+
+	ddb_input_stop(input);
+	while ((next = input->redirect) &&
+	       next != input) {
+		ddb_input_stop(next);
+		ddb_output_stop(next->port->output);
+	}
 }
+#endif
 
 static u32 ddb_output_free(struct ddb_output *output)
 {
-	u32 idx, off, stat = output->stat;
+	u32 idx, off, stat = output->dma->stat;
 	s32 diff;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
-	if (output->cbuf != idx) {
-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
-		    (output->dma_buf_size - output->coff <= 188))
+	if (output->dma->cbuf != idx) {
+		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
+		    (output->dma->size - output->dma->coff <= 188))
 			return 0;
 		return 188;
 	}
-	diff = off - output->coff;
+	diff = off - output->dma->coff;
 	if (diff <= 0 || diff > 188)
 		return 188;
 	return 0;
@@ -444,24 +550,24 @@
 				const u8 *buf, size_t count)
 {
 	struct ddb *dev = output->port->dev;
-	u32 idx, off, stat = output->stat;
+	u32 idx, off, stat = output->dma->stat;
 	u32 left = count, len;
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		len = output->dma_buf_size - output->coff;
-		if ((((output->cbuf + 1) % output->dma_buf_num) == idx) &&
+		len = output->dma->size - output->dma->coff;
+		if ((((output->dma->cbuf + 1) % output->dma->num) == idx) &&
 		    (off == 0)) {
 			if (len <= 188)
 				break;
 			len -= 188;
 		}
-		if (output->cbuf == idx) {
-			if (off > output->coff) {
+		if (output->dma->cbuf == idx) {
+			if (off > output->dma->coff) {
 #if 1
-				len = off - output->coff;
+				len = off - output->dma->coff;
 				len -= (len % 188);
 				if (len <= 188)
 
@@ -472,68 +578,146 @@
 		}
 		if (len > left)
 			len = left;
-		if (copy_from_user(output->vbuf[output->cbuf] + output->coff,
+		if (copy_from_user(output->dma->vbuf[output->dma->cbuf] +
+				   output->dma->coff,
 				   buf, len))
 			return -EIO;
+		/* printk("cfu %d  %d %d\n", len, output->cbuf, output->coff); */
 		left -= len;
 		buf += len;
-		output->coff += len;
-		if (output->coff == output->dma_buf_size) {
-			output->coff = 0;
-			output->cbuf = ((output->cbuf + 1) % output->dma_buf_num);
+		output->dma->coff += len;
+		if (output->dma->coff == output->dma->size) {
+			output->dma->coff = 0;
+			output->dma->cbuf = ((output->dma->cbuf + 1) %
+					     output->dma->num);
 		}
-		ddbwritel((output->cbuf << 11) | (output->coff >> 7),
-			  DMA_BUFFER_ACK(output->nr + 8));
+		ddbwritel(dev, (output->dma->cbuf << 11) | (output->dma->coff >> 7),
+			  DMA_BUFFER_ACK(output->dma->nr));
 	}
 	return count - left;
 }
 
+#if 0
+static u32 ddb_input_free_bytes(struct ddb_input *input)
+{
+	struct ddb *dev = input->port->dev;
+	u32 idx, off, stat = input->dma->stat;
+	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
+
+	idx = (stat >> 11) & 0x1f;
+	off = (stat & 0x7ff) << 7;
+
+	if (ctrl & 4)
+		return 0;
+	if (input->dma->cbuf != idx)
+		return 1;
+	return 0;
+}
+
+static s32 ddb_output_used_bufs(struct ddb_output *output)
+{
+	u32 idx, off, stat, ctrl;
+	s32 diff;
+
+	spin_lock_irq(&output->dma->lock);
+	stat = output->dma->stat;
+	ctrl = output->dma->ctrl;
+	spin_unlock_irq(&output->dma->lock);
+
+	idx = (stat >> 11) & 0x1f;
+	off = (stat & 0x7ff) << 7;
+
+	if (ctrl & 4)
+		return 0;
+	diff = output->dma->cbuf - idx;
+	if (diff == 0 && off < output->dma->coff)
+		return 0;
+	if (diff <= 0)
+		diff += output->dma->num;
+	return diff;
+}
+
+static s32 ddb_input_free_bufs(struct ddb_input *input)
+{
+	u32 idx, off, stat, ctrl;
+	s32 free;
+
+	spin_lock_irq(&input->dma->lock);
+	ctrl = input->dma->ctrl;
+	stat = input->dma->stat;
+	spin_unlock_irq(&input->dma->lock);
+	if (ctrl & 4)
+		return 0;
+	idx = (stat >> 11) & 0x1f;
+	off = (stat & 0x7ff) << 7;
+	free = input->dma->cbuf - idx;
+	if (free == 0 && off < input->dma->coff)
+		return 0;
+	if (free <= 0)
+		free += input->dma->num;
+	return free - 1;
+}
+
+static u32 ddb_output_ok(struct ddb_output *output)
+{
+	struct ddb_input *input = output->port->input[0];
+	s32 diff;
+
+	diff = ddb_input_free_bufs(input) - ddb_output_used_bufs(output);
+	if (diff > 0)
+		return 1;
+	return 0;
+}
+#endif
+
 static u32 ddb_input_avail(struct ddb_input *input)
 {
 	struct ddb *dev = input->port->dev;
-	u32 idx, off, stat = input->stat;
-	u32 ctrl = ddbreadl(DMA_BUFFER_CONTROL(input->nr));
+	u32 idx, off, stat = input->dma->stat;
+	u32 ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(input->dma->nr));
 
 	idx = (stat >> 11) & 0x1f;
 	off = (stat & 0x7ff) << 7;
 
 	if (ctrl & 4) {
 		printk(KERN_ERR "IA %d %d %08x\n", idx, off, ctrl);
-		ddbwritel(input->stat, DMA_BUFFER_ACK(input->nr));
+		ddbwritel(dev, stat, DMA_BUFFER_ACK(input->dma->nr));
 		return 0;
 	}
-	if (input->cbuf != idx)
+	if (input->dma->cbuf != idx || off < input->dma->coff)
 		return 188;
 	return 0;
 }
 
-static ssize_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
+static size_t ddb_input_read(struct ddb_input *input, u8 *buf, size_t count)
 {
 	struct ddb *dev = input->port->dev;
 	u32 left = count;
-	u32 idx, free, stat = input->stat;
+	u32 idx, off, free, stat = input->dma->stat;
 	int ret;
 
 	idx = (stat >> 11) & 0x1f;
+	off = (stat & 0x7ff) << 7;
 
 	while (left) {
-		if (input->cbuf == idx)
+		if (input->dma->cbuf == idx)
 			return count - left;
-		free = input->dma_buf_size - input->coff;
+		free = input->dma->size - input->dma->coff;
 		if (free > left)
 			free = left;
-		ret = copy_to_user(buf, input->vbuf[input->cbuf] +
-				   input->coff, free);
+		ret = copy_to_user(buf, input->dma->vbuf[input->dma->cbuf] +
+				   input->dma->coff, free);
 		if (ret)
 			return -EFAULT;
-		input->coff += free;
-		if (input->coff == input->dma_buf_size) {
-			input->coff = 0;
-			input->cbuf = (input->cbuf+1) % input->dma_buf_num;
+		input->dma->coff += free;
+		if (input->dma->coff == input->dma->size) {
+			input->dma->coff = 0;
+			input->dma->cbuf = (input->dma->cbuf+1) %
+				input->dma->num;
 		}
 		left -= free;
-		ddbwritel((input->cbuf << 11) | (input->coff >> 7),
-			  DMA_BUFFER_ACK(input->nr));
+		ddbwritel(dev, (input->dma->cbuf << 11) | (input->dma->coff >> 7),
+			  DMA_BUFFER_ACK(input->dma->nr));
 	}
 	return count;
 }
@@ -555,7 +739,7 @@
 }
 #endif
 
-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
+static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct ddb_input *input = fe->sec_priv;
 	struct ddb_port *port = input->port;
@@ -563,9 +747,9 @@
 
 	if (enable) {
 		mutex_lock(&port->i2c_gate_lock);
-		status = input->gate_ctrl(fe, 1);
+		status = input->dvb.gate_ctrl(fe, 1);
 	} else {
-		status = input->gate_ctrl(fe, 0);
+		status = input->dvb.gate_ctrl(fe, 0);
 		mutex_unlock(&port->i2c_gate_lock);
 	}
 	return status;
@@ -578,17 +762,88 @@
 	struct drxk_config config;
 
 	memset(&config, 0, sizeof(config));
-	config.microcode_name = "drxk_a3.mc";
 	config.adr = 0x29 + (input->nr & 1);
+	config.microcode_name = "drxk_a3.mc";
 
-	fe = input->fe = dvb_attach(drxk_attach, &config, i2c);
-	if (!input->fe) {
+#ifdef USE_API3
+	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c, &input->dvb.fe2);
+#else
+	fe = input->dvb.fe = dvb_attach(drxk_attach, &config, i2c);
+#endif
+	if (!input->dvb.fe) {
 		printk(KERN_ERR "No DRXK found!\n");
 		return -ENODEV;
 	}
 	fe->sec_priv = input;
-	input->gate_ctrl = fe->ops.i2c_gate_ctrl;
-	fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
+	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	return 0;
+}
+
+#if 0
+struct stv0367_config stv0367_0 = {
+	.demod_address = 0x1f,
+	.xtal = 27000000,
+	.if_khz = 5000,
+	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
+	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
+	.clk_pol = STV0367_RISINGEDGE_CLOCK,
+};
+
+struct stv0367_config stv0367_1 = {
+	.demod_address = 0x1e,
+	.xtal = 27000000,
+	.if_khz = 5000,
+	.if_iq_mode = FE_TER_NORMAL_IF_TUNER,
+	.ts_mode = STV0367_SERIAL_PUNCT_CLOCK,
+	.clk_pol = STV0367_RISINGEDGE_CLOCK,
+};
+
+
+static int demod_attach_stv0367(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct dvb_frontend *fe;
+
+	fe = input->dvb.fe = dvb_attach(stv0367ter_attach,
+				    (input->nr & 1) ? &stv0367_1 : &stv0367_0,
+				    i2c);
+	if (!input->dvb.fe) {
+		printk(KERN_ERR "No stv0367 found!\n");
+		return -ENODEV;
+	}
+	fe->sec_priv = input;
+	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	return 0;
+}
+#endif
+
+struct stv0367_cfg stv0367dd_0 = {
+	.adr = 0x1f,
+	.xtal = 27000000,
+};
+
+struct stv0367_cfg stv0367dd_1 = {
+	.adr = 0x1e,
+	.xtal = 27000000,
+};
+
+static int demod_attach_stv0367dd(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct dvb_frontend *fe;
+
+	fe = input->dvb.fe = dvb_attach(stv0367_attach, i2c,
+				    (input->nr & 1) ? &stv0367dd_1 : &stv0367dd_0,
+				    &input->dvb.fe2);
+	if (!input->dvb.fe) {
+		printk(KERN_ERR "No stv0367 found!\n");
+		return -ENODEV;
+	}
+	fe->sec_priv = input;
+	input->dvb.gate_ctrl = fe->ops.i2c_gate_ctrl;
+	fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
 	return 0;
 }
 
@@ -597,18 +852,57 @@
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
 	struct dvb_frontend *fe;
 
-	if (input->fe->ops.i2c_gate_ctrl)
-		input->fe->ops.i2c_gate_ctrl(input->fe, 1);
-	fe = dvb_attach(tda18271c2dd_attach, input->fe, i2c, 0x60);
+	if (input->dvb.fe->ops.i2c_gate_ctrl)
+		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 1);
+	fe = dvb_attach(tda18271c2dd_attach, input->dvb.fe, i2c, 0x60);
+	if (input->dvb.fe->ops.i2c_gate_ctrl)
+		input->dvb.fe->ops.i2c_gate_ctrl(input->dvb.fe, 0);
 	if (!fe) {
 		printk(KERN_ERR "No TDA18271 found!\n");
 		return -ENODEV;
 	}
-	if (input->fe->ops.i2c_gate_ctrl)
-		input->fe->ops.i2c_gate_ctrl(input->fe, 0);
 	return 0;
 }
 
+static int tuner_attach_tda18212dd(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct dvb_frontend *fe;
+
+	fe = dvb_attach(tda18212dd_attach, input->dvb.fe, i2c,
+			(input->nr & 1) ? 0x63 : 0x60);
+	if (!fe) {
+		printk(KERN_ERR "No TDA18212 found!\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+#if 0
+struct tda18212_config tda18212_0 = {
+	.i2c_address = 0x60,
+};
+
+struct tda18212_config tda18212_1 = {
+	.i2c_address = 0x63,
+};
+
+static int tuner_attach_tda18212(struct ddb_input *input)
+{
+	struct i2c_adapter *i2c = &input->port->i2c->adap;
+	struct dvb_frontend *fe;
+	struct tda18212_config *cfg;
+
+	cfg = (input->nr & 1) ? &tda18212_1 : &tda18212_0;
+	fe = dvb_attach(tda18212_attach, input->dvb.fe, i2c, cfg);
+	if (!fe) {
+		printk(KERN_ERR "No TDA18212 found!\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+#endif
+
 /******************************************************************************/
 /******************************************************************************/
 /******************************************************************************/
@@ -668,14 +962,14 @@
 	struct i2c_adapter *i2c = &input->port->i2c->adap;
 	struct stv090x_config *feconf = type ? &stv0900_aa : &stv0900;
 
-	input->fe = dvb_attach(stv090x_attach, feconf, i2c,
+	input->dvb.fe = dvb_attach(stv090x_attach, feconf, i2c,
 			       (input->nr & 1) ? STV090x_DEMODULATOR_1
 			       : STV090x_DEMODULATOR_0);
-	if (!input->fe) {
+	if (!input->dvb.fe) {
 		printk(KERN_ERR "No STV0900 found!\n");
 		return -ENODEV;
 	}
-	if (!dvb_attach(lnbh24_attach, input->fe, i2c, 0,
+	if (!dvb_attach(lnbh24_attach, input->dvb.fe, i2c, 0,
 			0, (input->nr & 1) ?
 			(0x09 - type) : (0x0b - type))) {
 		printk(KERN_ERR "No LNBH24 found!\n");
@@ -692,7 +986,7 @@
 		&stv6110b : &stv6110a;
 	struct stv6110x_devctl *ctl;
 
-	ctl = dvb_attach(stv6110x_attach, input->fe, tunerconf, i2c);
+	ctl = dvb_attach(stv6110x_attach, input->dvb.fe, tunerconf, i2c);
 	if (!ctl) {
 		printk(KERN_ERR "No STV6110X found!\n");
 		return -ENODEV;
@@ -760,10 +1054,10 @@
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
 
-	if (!input->users)
+	if (!input->dvb.users)
 		ddb_input_start(input);
 
-	return ++input->users;
+	return ++input->dvb.users;
 }
 
 static int stop_feed(struct dvb_demux_feed *dvbdmxfeed)
@@ -771,8 +1065,8 @@
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ddb_input *input = dvbdmx->priv;
 
-	if (--input->users)
-		return input->users;
+	if (--input->dvb.users)
+		return input->dvb.users;
 
 	ddb_input_stop(input);
 	return 0;
@@ -781,116 +1075,200 @@
 
 static void dvb_input_detach(struct ddb_input *input)
 {
-	struct dvb_adapter *adap = &input->adap;
-	struct dvb_demux *dvbdemux = &input->demux;
+	struct dvb_demux *dvbdemux = &input->dvb.demux;
 
-	switch (input->attached) {
+	switch (input->dvb.attached) {
+	case 6:
+		if (input->dvb.fe2)
+			dvb_unregister_frontend(input->dvb.fe2);
+		if (input->dvb.fe)
+			dvb_unregister_frontend(input->dvb.fe);
 	case 5:
-		if (input->fe2)
-			dvb_unregister_frontend(input->fe2);
-		if (input->fe) {
-			dvb_unregister_frontend(input->fe);
-			dvb_frontend_detach(input->fe);
-			input->fe = NULL;
-		}
+		dvb_frontend_detach(input->dvb.fe);
+		input->dvb.fe = NULL;
 	case 4:
-		dvb_net_release(&input->dvbnet);
-
+		dvb_net_release(&input->dvb.dvbnet);
 	case 3:
 		dvbdemux->dmx.close(&dvbdemux->dmx);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->hw_frontend);
+					      &input->dvb.hw_frontend);
 		dvbdemux->dmx.remove_frontend(&dvbdemux->dmx,
-					      &input->mem_frontend);
-		dvb_dmxdev_release(&input->dmxdev);
-
+					      &input->dvb.mem_frontend);
+		dvb_dmxdev_release(&input->dvb.dmxdev);
 	case 2:
-		dvb_dmx_release(&input->demux);
-
+		dvb_dmx_release(&input->dvb.demux);
 	case 1:
-		dvb_unregister_adapter(adap);
+		break;
+	}
+	input->dvb.attached = 0;
+}
+
+static int dvb_register_adapters(struct ddb *dev)
+{
+	int i, ret = 0;
+	struct ddb_port *port;
+	struct dvb_adapter *adap;
+
+	if (adapter_alloc == 3) {
+		port = &dev->port[0];
+		adap = port->input[0]->dvb.adap;
+		ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+					   &port->dev->pdev->dev,
+					   adapter_nr);
+		if (ret < 0)
+			return ret;
+		port->input[0]->dvb.adap_registered = 1;
+		for (i = 0; i < dev->info->port_num; i++) {
+			port = &dev->port[i];
+			port->input[0]->dvb.adap = adap;
+			port->input[1]->dvb.adap = adap;
+		}
+		return 0;
+	}
+
+	for (i = 0; i < dev->info->port_num; i++) {
+		port = &dev->port[i];
+		switch (port->class) {
+		case DDB_PORT_TUNER:
+			adap = port->input[0]->dvb.adap;
+			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+						   &port->dev->pdev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->input[0]->dvb.adap_registered = 1;
+
+			if (adapter_alloc > 0) {
+				port->input[1]->dvb.adap = port->input[0]->dvb.adap;
+				break;
+			}
+			adap = port->input[1]->dvb.adap;
+			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+						   &port->dev->pdev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->input[1]->dvb.adap_registered = 1;
+			break;
+
+		case DDB_PORT_CI:
+		case DDB_PORT_LOOP:
+			adap = port->input[0]->dvb.adap;
+			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+						   &port->dev->pdev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->input[0]->dvb.adap_registered = 1;
+			break;
+		default:
+			if (adapter_alloc < 2)
+				break;
+			adap = port->input[0]->dvb.adap;
+			ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
+						   &port->dev->pdev->dev,
+						   adapter_nr);
+			if (ret < 0)
+				return ret;
+			port->input[0]->dvb.adap_registered = 1;
+			break;
+		}
+	}
+	return ret;
+}
+
+static void dvb_unregister_adapters(struct ddb *dev)
+{
+	int i;
+	struct ddb_port *port;
+	struct ddb_input *input;
+
+	for (i = 0; i < dev->info->port_num; i++) {
+		port = &dev->port[i];
+
+		input = port->input[0];
+		if (input->dvb.adap_registered)
+			dvb_unregister_adapter(input->dvb.adap);
+		input->dvb.adap_registered = 0;
+
+		input = port->input[1];
+		if (input->dvb.adap_registered)
+			dvb_unregister_adapter(input->dvb.adap);
+		input->dvb.adap_registered = 0;
 	}
-	input->attached = 0;
 }
 
+
 static int dvb_input_attach(struct ddb_input *input)
 {
-	int ret;
+	int ret = 0;
 	struct ddb_port *port = input->port;
-	struct dvb_adapter *adap = &input->adap;
-	struct dvb_demux *dvbdemux = &input->demux;
+	struct dvb_adapter *adap = input->dvb.adap;
+	struct dvb_demux *dvbdemux = &input->dvb.demux;
 
-	ret = dvb_register_adapter(adap, "DDBridge", THIS_MODULE,
-				   &input->port->dev->pdev->dev,
-				   adapter_nr);
-	if (ret < 0) {
-		printk(KERN_ERR "ddbridge: Could not register adapter."
-		       "Check if you enabled enough adapters in dvb-core!\n");
-		return ret;
-	}
-	input->attached = 1;
+	input->dvb.attached = 1;
 
 	ret = my_dvb_dmx_ts_card_init(dvbdemux, "SW demux",
 				      start_feed,
 				      stop_feed, input);
 	if (ret < 0)
 		return ret;
-	input->attached = 2;
+	input->dvb.attached = 2;
 
-	ret = my_dvb_dmxdev_ts_card_init(&input->dmxdev, &input->demux,
-					 &input->hw_frontend,
-					 &input->mem_frontend, adap);
+	ret = my_dvb_dmxdev_ts_card_init(&input->dvb.dmxdev,
+					 &input->dvb.demux,
+					 &input->dvb.hw_frontend,
+					 &input->dvb.mem_frontend, adap);
 	if (ret < 0)
 		return ret;
-	input->attached = 3;
+	input->dvb.attached = 3;
 
-	ret = dvb_net_init(adap, &input->dvbnet, input->dmxdev.demux);
+	ret = dvb_net_init(adap, &input->dvb.dvbnet, input->dvb.dmxdev.demux);
 	if (ret < 0)
 		return ret;
-	input->attached = 4;
+	input->dvb.attached = 4;
 
-	input->fe = 0;
+	input->dvb.fe = 0;
 	switch (port->type) {
 	case DDB_TUNER_DVBS_ST:
 		if (demod_attach_stv0900(input, 0) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 0) < 0)
 			return -ENODEV;
-		if (input->fe) {
-			if (dvb_register_frontend(adap, input->fe) < 0)
-				return -ENODEV;
-		}
 		break;
 	case DDB_TUNER_DVBS_ST_AA:
 		if (demod_attach_stv0900(input, 1) < 0)
 			return -ENODEV;
 		if (tuner_attach_stv6110(input, 1) < 0)
 			return -ENODEV;
-		if (input->fe) {
-			if (dvb_register_frontend(adap, input->fe) < 0)
-				return -ENODEV;
-		}
 		break;
 	case DDB_TUNER_DVBCT_TR:
 		if (demod_attach_drxk(input) < 0)
 			return -ENODEV;
 		if (tuner_attach_tda18271(input) < 0)
 			return -ENODEV;
-		if (input->fe) {
-			if (dvb_register_frontend(adap, input->fe) < 0)
-				return -ENODEV;
-		}
-		if (input->fe2) {
-			if (dvb_register_frontend(adap, input->fe2) < 0)
-				return -ENODEV;
-			input->fe2->tuner_priv = input->fe->tuner_priv;
-			memcpy(&input->fe2->ops.tuner_ops,
-			       &input->fe->ops.tuner_ops,
-			       sizeof(struct dvb_tuner_ops));
-		}
 		break;
+	case DDB_TUNER_DVBCT_ST:
+		if (demod_attach_stv0367dd(input) < 0)
+			return -ENODEV;
+		if (tuner_attach_tda18212dd(input) < 0)
+			return -ENODEV;
+		break;
+	}
+	input->dvb.attached = 5;
+	if (input->dvb.fe) {
+		if (dvb_register_frontend(adap, input->dvb.fe) < 0)
+			return -ENODEV;
+	}
+	if (input->dvb.fe2) {
+		if (dvb_register_frontend(adap, input->dvb.fe2) < 0)
+			return -ENODEV;
+		input->dvb.fe2->tuner_priv = input->dvb.fe->tuner_priv;
+		memcpy(&input->dvb.fe2->ops.tuner_ops,
+		       &input->dvb.fe->ops.tuner_ops,
+		       sizeof(struct dvb_tuner_ops));
 	}
-	input->attached = 5;
+	input->dvb.attached = 6;
 	return 0;
 }
 
@@ -910,7 +1288,8 @@
 			if (file->f_flags & O_NONBLOCK)
 				break;
 			if (wait_event_interruptible(
-				    output->wq, ddb_output_free(output) >= 188) < 0)
+				    output->dma->wq,
+				    ddb_output_free(output) >= 188) < 0)
 				break;
 		}
 		stat = ddb_output_write(output, buf, left);
@@ -937,7 +1316,7 @@
 			if (file->f_flags & O_NONBLOCK)
 				break;
 			if (wait_event_interruptible(
-				    input->wq, ddb_input_avail(input) >= 188) < 0)
+				    input->dma->wq, ddb_input_avail(input) >= 188) < 0)
 				break;
 		}
 		read = ddb_input_read(input, buf, left);
@@ -970,21 +1349,53 @@
 	return mask;
 }
 
-static const struct file_operations ci_fops = {
-	.owner   = THIS_MODULE,
-	.read    = ts_read,
-	.write   = ts_write,
-	.open    = dvb_generic_open,
-	.release = dvb_generic_release,
-	.poll    = ts_poll,
-	.mmap    = 0,
-};
-
-static struct dvb_device dvbdev_ci = {
+#if 0
+static int ts_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
+
+
+	return dvb_generic_release(inode, file);
+}
+
+static unsigned int ts_open(struct inode *inode, struct file *file)
+{
+	int err;
+	struct dvb_device *dvbdev = file->private_data;
+	struct ddb_output *output = dvbdev->priv;
+	struct ddb_input *input = output->port->input[0];
+
+	err = dvb_generic_open(inode, file);
+	if (err < 0)
+		return err;
+
+#if 0
+	if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+		ddb_input_start(input);
+	else
+		ddb_output_start(output);
+#endif
+	return err;
+}
+#endif
+
+static const struct file_operations ci_fops = {
+	.owner   = THIS_MODULE,
+	.read    = ts_read,
+	.write   = ts_write,
+	.open    = dvb_generic_open,
+	.release = dvb_generic_release,
+	.poll    = ts_poll,
+	.mmap    = 0,
+};
+
+static struct dvb_device dvbdev_ci = {
 	.priv    = 0,
-	.readers = -1,
-	.writers = -1,
-	.users   = -1,
+	.readers = 1,
+	.writers = 1,
+	.users   = 2,
 	.fops    = &ci_fops,
 };
 
@@ -992,53 +1403,297 @@
 /****************************************************************************/
 /****************************************************************************/
 
+static int set_redirect(u32 i, u32 p)
+{
+	struct ddb *idev = ddbs[(i >> 4) & 0x1f];
+	struct ddb_input *input;
+	struct ddb *pdev = ddbs[(p >> 4) & 0x1f];
+	struct ddb_port *port;
+
+	if (!idev || !pdev)
+		return -EINVAL;
+
+	port = &pdev->port[p & 3];
+	if (port->class != DDB_PORT_CI && port->class != DDB_PORT_LOOP)
+		return -EINVAL;
+
+	ddb_unredirect(port);
+	if (i == 8)
+		return 0;
+	input = &idev->input[i & 7];
+	if (input->port->class != DDB_PORT_TUNER)
+		port->input[0]->redirect = input->redirect;
+	else
+		port->input[0]->redirect = input;
+	input->redirect = port->input[0];
+	port->output->redirect = input;
+
+	ddb_redirect_dma(input->port->dev, input->dma, port->output->dma);
+	return 0;
+}
+
+static void input_write_output(struct ddb_input *input,
+			       struct ddb_output *output)
+{
+	ddbwritel(output->port->dev,
+		  input->dma->stat, DMA_BUFFER_ACK(output->dma->nr));
+}
+
+static void output_ack_input(struct ddb_output *output,
+			     struct ddb_input *input)
+{
+	ddbwritel(input->port->dev,
+		  output->dma->stat, DMA_BUFFER_ACK(input->dma->nr));
+}
+
+static void input_write_dvb(struct ddb_input *input, struct ddb_dvb *dvb)
+{
+	struct ddb_dma *dma = input->dma;
+	struct ddb *dev = input->port->dev;
+
+	if (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))
+		printk(KERN_ERR "Overflow dma %d\n", dma->nr);
+	while (dma->cbuf != ((dma->stat >> 11) & 0x1f)
+	       || (4 & ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr)))) {
+		dvb_dmx_swfilter_packets(&dvb->demux,
+					 dma->vbuf[dma->cbuf],
+					 dma->size / 188);
+		dma->cbuf = (dma->cbuf + 1) % dma->num;
+		ddbwritel(dev, (dma->cbuf << 11),  DMA_BUFFER_ACK(dma->nr));
+		dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	}
+}
+
 static void input_tasklet(unsigned long data)
 {
 	struct ddb_input *input = (struct ddb_input *) data;
+	struct ddb_dma *dma = input->dma;
 	struct ddb *dev = input->port->dev;
 
-	spin_lock(&input->lock);
-	if (!input->running) {
-		spin_unlock(&input->lock);
+	spin_lock(&dma->lock);
+	if (!dma->running) {
+		spin_unlock(&dma->lock);
 		return;
 	}
-	input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
+	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
 
 	if (input->port->class == DDB_PORT_TUNER) {
-		if (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))
-			printk(KERN_ERR "Overflow input %d\n", input->nr);
-		while (input->cbuf != ((input->stat >> 11) & 0x1f)
-		       || (4&ddbreadl(DMA_BUFFER_CONTROL(input->nr)))) {
-			dvb_dmx_swfilter_packets(&input->demux,
-						 input->vbuf[input->cbuf],
-						 input->dma_buf_size / 188);
-
-			input->cbuf = (input->cbuf + 1) % input->dma_buf_num;
-			ddbwritel((input->cbuf << 11),
-				  DMA_BUFFER_ACK(input->nr));
-			input->stat = ddbreadl(DMA_BUFFER_CURRENT(input->nr));
-		       }
-	}
-	if (input->port->class == DDB_PORT_CI)
-		wake_up(&input->wq);
-	spin_unlock(&input->lock);
+		if (input->redirect)
+			input_write_output(input,
+					   input->redirect->port->output);
+		else
+			input_write_dvb(input, &input->dvb);
+	}
+	if (input->port->class == DDB_PORT_CI ||
+	    input->port->class == DDB_PORT_LOOP) {
+		if (input->redirect) {
+			if (input->redirect->port->class == DDB_PORT_TUNER)
+				input_write_dvb(input, &input->redirect->dvb);
+			else
+				input_write_output(input,
+						   input->redirect->port->output);
+		} else
+			wake_up(&dma->wq);
+	}
+	spin_unlock(&dma->lock);
 }
 
 static void output_tasklet(unsigned long data)
 {
 	struct ddb_output *output = (struct ddb_output *) data;
+	struct ddb_dma *dma = output->dma;
 	struct ddb *dev = output->port->dev;
 
-	spin_lock(&output->lock);
-	if (!output->running) {
-		spin_unlock(&output->lock);
+	spin_lock(&dma->lock);
+	if (!dma->running) {
+		spin_unlock(&dma->lock);
 		return;
 	}
-	output->stat = ddbreadl(DMA_BUFFER_CURRENT(output->nr + 8));
-	wake_up(&output->wq);
-	spin_unlock(&output->lock);
+	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
+	if (output->redirect)
+		output_ack_input(output, output->redirect);
+	wake_up(&dma->wq);
+	spin_unlock(&dma->lock);
 }
 
+#if 0
+static void io_tasklet(unsigned long data)
+{
+	struct ddb_dma *dma = (struct ddb_dma *) data;
+
+	spin_lock(&dma->lock);
+	if (!dma->running) {
+		spin_unlock(&dma->lock);
+		return;
+	}
+	dma->stat = ddbreadl(dev, DMA_BUFFER_CURRENT(dma->nr));
+	dma->ctrl = ddbreadl(dev, DMA_BUFFER_CONTROL(dma->nr));
+	if (dma->nr & 8)
+		handle_output((struct ddb_output *) dma->io);
+	else
+		handle_input((struct ddb_input *) dma->io);
+	wake_up(&dma->wq);
+	spin_unlock(&dma->lock);
+}
+#endif
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
+static int wait_ci_ready(struct ddb_ci *ci)
+{
+	u32 count = 100;
+
+	do {
+		if (ddbreadl(ci->port->dev,
+			     CI_CONTROL(ci->nr)) & CI_READY)
+			break;
+		msleep(1);
+		if ((--count) == 0)
+			return -1;
+	} while (1);
+	return 0;
+}
+
+static int read_attribute_mem(struct dvb_ca_en50221 *ca,
+			      int slot, int address)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val, off = (address >> 1) & (CI_BUFFER_SIZE-1);
+
+	if (address > CI_BUFFER_SIZE)
+		return -1;
+	ddbwritel(ci->port->dev, CI_READ_CMD | (1 << 16) | address,
+		  CI_DO_READ_ATTRIBUTES(ci->nr));
+	wait_ci_ready(ci);
+	val = 0xff & ddbreadl(ci->port->dev, CI_BUFFER(ci->nr) + off);
+	/* printk("%04x: %02x\n", address, val); */
+	return val;
+}
+
+static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
+			       int address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
+		  CI_DO_ATTRIBUTE_RW(ci->nr));
+	wait_ci_ready(ci);
+	return 0;
+}
+
+static int read_cam_control(struct dvb_ca_en50221 *ca,
+			    int slot, u8 address)
+{
+	u32 count = 100;
+	struct ddb_ci *ci = ca->data;
+	u32 res;
+
+	ddbwritel(ci->port->dev, CI_READ_CMD | address,
+		  CI_DO_IO_RW(ci->nr));
+	do {
+		res = ddbreadl(ci->port->dev, CI_READDATA(ci->nr));
+		if (res & CI_READY)
+			break;
+		msleep(1);
+		if ((--count) == 0)
+			return -1;
+	} while (1);
+	return 0xff & res;
+}
+
+static int write_cam_control(struct dvb_ca_en50221 *ca, int slot,
+			     u8 address, u8 value)
+{
+	struct ddb_ci *ci = ca->data;
+
+	ddbwritel(ci->port->dev, CI_WRITE_CMD | (value << 16) | address,
+		  CI_DO_IO_RW(ci->nr));
+	wait_ci_ready(ci);
+	return 0;
+}
+
+static int slot_reset(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	printk(KERN_INFO "slot reset %d\n", ci->nr);
+	ddbwritel(ci->port->dev, CI_POWER_ON,
+		  CI_CONTROL(ci->nr));
+	msleep(300);
+	ddbwritel(ci->port->dev, CI_POWER_ON | CI_RESET_CAM,
+		  CI_CONTROL(ci->nr));
+	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON | CI_RESET_CAM,
+		  CI_CONTROL(ci->nr));
+	udelay(20);
+	ddbwritel(ci->port->dev, CI_ENABLE | CI_POWER_ON,
+		  CI_CONTROL(ci->nr));
+	return 0;
+}
+
+static int slot_shutdown(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+
+	printk(KERN_INFO "slot shutdown\n");
+	ddbwritel(ci->port->dev, 0, CI_CONTROL(ci->nr));
+	return 0;
+}
+
+static int slot_ts_enable(struct dvb_ca_en50221 *ca, int slot)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
+
+	ddbwritel(ci->port->dev, val | CI_BYPASS_DISABLE,
+		  CI_CONTROL(ci->nr));
+	return 0;
+}
+
+static int poll_slot_status(struct dvb_ca_en50221 *ca, int slot, int open)
+{
+	struct ddb_ci *ci = ca->data;
+	u32 val = ddbreadl(ci->port->dev, CI_CONTROL(ci->nr));
+	int stat = 0;
+
+	if (val & CI_CAM_DETECT)
+		stat |= DVB_CA_EN50221_POLL_CAM_PRESENT;
+	if (val & CI_CAM_READY)
+		stat |= DVB_CA_EN50221_POLL_CAM_READY;
+	return stat;
+}
+
+static struct dvb_ca_en50221 en_templ = {
+	.read_attribute_mem  = read_attribute_mem,
+	.write_attribute_mem = write_attribute_mem,
+	.read_cam_control    = read_cam_control,
+	.write_cam_control   = write_cam_control,
+	.slot_reset          = slot_reset,
+	.slot_shutdown       = slot_shutdown,
+	.slot_ts_enable      = slot_ts_enable,
+	.poll_slot_status    = poll_slot_status,
+};
+
+static void ci_attach(struct ddb_port *port)
+{
+	struct ddb_ci *ci = 0;
+
+	ci = kzalloc(sizeof(*ci), GFP_KERNEL);
+	if (!ci)
+		return;
+	memcpy(&ci->en, &en_templ, sizeof(en_templ));
+	ci->en.data = ci;
+	port->en = &ci->en;
+	ci->port = port;
+	ci->nr = port->nr - 2;
+}
+
+/****************************************************************************/
+/****************************************************************************/
+/****************************************************************************/
+
 
 struct cxd2099_cfg cxd_cfg = {
 	.bitrate =  62000,
@@ -1049,28 +1704,22 @@
 
 static int ddb_ci_attach(struct ddb_port *port)
 {
-	int ret;
-
-	ret = dvb_register_adapter(&port->output->adap,
-				   "DDBridge",
-				   THIS_MODULE,
-				   &port->dev->pdev->dev,
-				   adapter_nr);
-	if (ret < 0)
-		return ret;
-	port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
-	if (!port->en) {
-		dvb_unregister_adapter(&port->output->adap);
-		return -ENODEV;
+	if (port->type == DDB_CI_EXTERNAL_SONY) {
+		port->en = cxd2099_attach(&cxd_cfg, port, &port->i2c->adap);
+		if (!port->en)
+			return -ENODEV;
+		dvb_ca_en50221_init(port->input[0]->dvb.adap,
+				    port->en, 0, 1);
 	}
-	ddb_input_start(port->input[0]);
-	ddb_output_start(port->output);
-	dvb_ca_en50221_init(&port->output->adap,
-			    port->en, 0, 1);
-	ret = dvb_register_device(&port->output->adap, &port->output->dev,
-				  &dvbdev_ci, (void *) port->output,
-				  DVB_DEVICE_SEC);
-	return ret;
+#if 1
+	if (port->type == DDB_CI_INTERNAL) {
+		ci_attach(port);
+		if (!port->en)
+			return -ENODEV;
+		dvb_ca_en50221_init(port->input[0]->dvb.adap, port->en, 0, 1);
+	}
+#endif
+	return 0;
 }
 
 static int ddb_port_attach(struct ddb_port *port)
@@ -1086,6 +1735,15 @@
 		break;
 	case DDB_PORT_CI:
 		ret = ddb_ci_attach(port);
+		if (ret < 0)
+			break;
+	case DDB_PORT_LOOP:
+		ddb_input_start(port->input[0]);
+		ddb_output_start(port->output);
+		ret = dvb_register_device(port->input[0]->dvb.adap,
+					  &port->input[0]->dvb.dev,
+					  &dvbdev_ci, (void *) port->output,
+					  DVB_DEVICE_SEC);
 		break;
 	default:
 		break;
@@ -1100,6 +1758,10 @@
 	int i, ret = 0;
 	struct ddb_port *port;
 
+	ret = dvb_register_adapters(dev);
+	if (ret < 0)
+		return ret;
+
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
 		ret = ddb_port_attach(port);
@@ -1122,25 +1784,26 @@
 			dvb_input_detach(port->input[1]);
 			break;
 		case DDB_PORT_CI:
-			if (port->output->dev)
-				dvb_unregister_device(port->output->dev);
+		case DDB_PORT_LOOP:
+			if (port->input[0]->dvb.dev)
+				dvb_unregister_device(port->input[0]->dvb.dev);
+			ddb_input_stop(port->input[0]);
+			ddb_output_stop(port->output);
 			if (port->en) {
-				ddb_input_stop(port->input[0]);
-				ddb_output_stop(port->output);
 				dvb_ca_en50221_release(port->en);
 				kfree(port->en);
 				port->en = 0;
-				dvb_unregister_adapter(&port->output->adap);
 			}
 			break;
 		}
 	}
+	dvb_unregister_adapters(dev);
 }
 
 /****************************************************************************/
 /****************************************************************************/
 
-static int port_has_ci(struct ddb_port *port)
+static int port_has_cxd(struct ddb_port *port)
 {
 	u8 val;
 	return i2c_read_reg(&port->i2c->adap, 0x40, 0, &val) ? 0 : 1;
@@ -1172,6 +1835,21 @@
 	return 1;
 }
 
+static int port_has_stv0367(struct ddb_port *port)
+{
+	u8 val;
+
+	if (i2c_read_reg16(&port->i2c->adap, 0x1e, 0xf000, &val) < 0)
+		return 0;
+	if (val != 0x60)
+		return 0;
+	if (i2c_read_reg16(&port->i2c->adap, 0x1f, 0xf000, &val) < 0)
+		return 0;
+	if (val != 0x60)
+		return 0;
+	return 1;
+}
+
 static void ddb_port_probe(struct ddb_port *port)
 {
 	struct ddb *dev = port->dev;
@@ -1179,62 +1857,92 @@
 
 	port->class = DDB_PORT_NONE;
 
-	if (port_has_ci(port)) {
+	if (port->nr > 1 && dev->info->type == DDB_OCTOPUS_CI) {
+		modname = "CI internal";
+		port->class = DDB_PORT_CI;
+		port->type = DDB_CI_INTERNAL;
+	} else if (port_has_cxd(port)) {
 		modname = "CI";
 		port->class = DDB_PORT_CI;
-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+		port->type = DDB_CI_EXTERNAL_SONY;
+		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_stv0900(port)) {
 		modname = "DUAL DVB-S2";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBS_ST;
-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_stv0900_aa(port)) {
 		modname = "DUAL DVB-S2";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBS_ST_AA;
-		ddbwritel(I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
 	} else if (port_has_drxks(port)) {
 		modname = "DUAL DVB-C/T";
 		port->class = DDB_PORT_TUNER;
 		port->type = DDB_TUNER_DVBCT_TR;
-		ddbwritel(I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+		ddbwritel(dev, I2C_SPEED_400, port->i2c->regs + I2C_TIMING);
+	} else if (port_has_stv0367(port)) {
+		modname = "DUAL DVB-C/T";
+		port->class = DDB_PORT_TUNER;
+		port->type = DDB_TUNER_DVBCT_ST;
+		ddbwritel(dev, I2C_SPEED_100, port->i2c->regs + I2C_TIMING);
+	} else if (port->nr == ts_loop) {
+		modname = "TS LOOP";
+		port->class = DDB_PORT_LOOP;
+	}
+	printk(KERN_INFO "Port %d (TAB %d): %s\n", port->nr, port->nr+1, modname);
+}
+
+static void ddb_dma_init(struct ddb_dma *dma, int nr, void *io)
+{
+	unsigned long priv = (unsigned long) io;
+
+	dma->io = io;
+	dma->nr = nr;
+	spin_lock_init(&dma->lock);
+	init_waitqueue_head(&dma->wq);
+	if (nr & 8) {
+		tasklet_init(&dma->tasklet, output_tasklet, priv);
+		dma->num = OUTPUT_DMA_BUFS;
+		dma->size = OUTPUT_DMA_SIZE;
+		dma->div = OUTPUT_DMA_IRQ_DIV;
+	} else {
+		tasklet_init(&dma->tasklet, input_tasklet, priv);
+		dma->num = INPUT_DMA_BUFS;
+		dma->size = INPUT_DMA_SIZE;
+		dma->div = INPUT_DMA_IRQ_DIV;
 	}
-	printk(KERN_INFO "Port %d (TAB %d): %s\n",
-			 port->nr, port->nr+1, modname);
 }
 
-static void ddb_input_init(struct ddb_port *port, int nr)
+static void ddb_input_init(struct ddb_port *port, int nr, int pnr)
 {
 	struct ddb *dev = port->dev;
 	struct ddb_input *input = &dev->input[nr];
 
+	port->input[pnr] = input;
 	input->nr = nr;
 	input->port = port;
-	input->dma_buf_num = INPUT_DMA_BUFS;
-	input->dma_buf_size = INPUT_DMA_SIZE;
-	ddbwritel(0, TS_INPUT_CONTROL(nr));
-	ddbwritel(2, TS_INPUT_CONTROL(nr));
-	ddbwritel(0, TS_INPUT_CONTROL(nr));
-	ddbwritel(0, DMA_BUFFER_ACK(nr));
-	tasklet_init(&input->tasklet, input_tasklet, (unsigned long) input);
-	spin_lock_init(&input->lock);
-	init_waitqueue_head(&input->wq);
+	input->dma = &dev->dma[nr];
+	ddb_dma_init(input->dma, nr, (void *) input);
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
+	ddbwritel(dev, 2, TS_INPUT_CONTROL(nr));
+	ddbwritel(dev, 0, TS_INPUT_CONTROL(nr));
+	ddbwritel(dev, 0, DMA_BUFFER_ACK(input->dma->nr));
+	input->dvb.adap = &dev->adap[input->nr];
 }
 
 static void ddb_output_init(struct ddb_port *port, int nr)
 {
 	struct ddb *dev = port->dev;
 	struct ddb_output *output = &dev->output[nr];
+	port->output = output;
 	output->nr = nr;
 	output->port = port;
-	output->dma_buf_num = OUTPUT_DMA_BUFS;
-	output->dma_buf_size = OUTPUT_DMA_SIZE;
-
-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(2, TS_OUTPUT_CONTROL(nr));
-	ddbwritel(0, TS_OUTPUT_CONTROL(nr));
-	tasklet_init(&output->tasklet, output_tasklet, (unsigned long) output);
-	init_waitqueue_head(&output->wq);
+	output->dma = &dev->dma[nr + 8];
+	ddb_dma_init(output->dma, nr + 8, (void *) output);
+	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
+	ddbwritel(dev, 2, TS_OUTPUT_CONTROL(nr));
+	ddbwritel(dev, 0, TS_OUTPUT_CONTROL(nr));
 }
 
 static void ddb_ports_init(struct ddb *dev)
@@ -1247,14 +1955,16 @@
 		port->dev = dev;
 		port->nr = i;
 		port->i2c = &dev->i2c[i];
-		port->input[0] = &dev->input[2 * i];
-		port->input[1] = &dev->input[2 * i + 1];
-		port->output = &dev->output[i];
 
 		mutex_init(&port->i2c_gate_lock);
 		ddb_port_probe(port);
-		ddb_input_init(port, 2 * i);
-		ddb_input_init(port, 2 * i + 1);
+		if (i >= 2 && dev->info->type == DDB_OCTOPUS_CI) {
+			ddb_input_init(port, 2 + i, 0);
+			ddb_input_init(port, 4 + i, 1);
+		} else {
+			ddb_input_init(port, 2 * i, 0);
+			ddb_input_init(port, 2 * i + 1, 1);
+		}
 		ddb_output_init(port, i);
 	}
 }
@@ -1267,9 +1977,12 @@
 	for (i = 0; i < dev->info->port_num; i++) {
 		port = &dev->port[i];
 		port->dev = dev;
-		tasklet_kill(&port->input[0]->tasklet);
-		tasklet_kill(&port->input[1]->tasklet);
-		tasklet_kill(&port->output->tasklet);
+		if (port->input[0])
+			tasklet_kill(&port->input[0]->dma->tasklet);
+		if (port->input[1])
+			tasklet_kill(&port->input[1]->dma->tasklet);
+		if (port->output)
+			tasklet_kill(&port->output->dma->tasklet);
 	}
 }
 
@@ -1288,13 +2001,18 @@
 static irqreturn_t irq_handler(int irq, void *dev_id)
 {
 	struct ddb *dev = (struct ddb *) dev_id;
-	u32 s = ddbreadl(INTERRUPT_STATUS);
+	u32 s = ddbreadl(dev, INTERRUPT_STATUS);
 
 	if (!s)
 		return IRQ_NONE;
 
 	do {
-		ddbwritel(s, INTERRUPT_ACK);
+		ddbwritel(dev, s, INTERRUPT_ACK);
+
+		if (s & 0x0000000f)
+			dev->i2c_irq++;
+		if (s & 0x000fff00)
+			dev->ts_irq++;
 
 		if (s & 0x00000001)
 			irq_handle_i2c(dev, 0);
@@ -1306,33 +2024,32 @@
 			irq_handle_i2c(dev, 3);
 
 		if (s & 0x00000100)
-			tasklet_schedule(&dev->input[0].tasklet);
+			tasklet_schedule(&dev->dma[0].tasklet);
 		if (s & 0x00000200)
-			tasklet_schedule(&dev->input[1].tasklet);
+			tasklet_schedule(&dev->dma[1].tasklet);
 		if (s & 0x00000400)
-			tasklet_schedule(&dev->input[2].tasklet);
+			tasklet_schedule(&dev->dma[2].tasklet);
 		if (s & 0x00000800)
-			tasklet_schedule(&dev->input[3].tasklet);
+			tasklet_schedule(&dev->dma[3].tasklet);
 		if (s & 0x00001000)
-			tasklet_schedule(&dev->input[4].tasklet);
+			tasklet_schedule(&dev->dma[4].tasklet);
 		if (s & 0x00002000)
-			tasklet_schedule(&dev->input[5].tasklet);
+			tasklet_schedule(&dev->dma[5].tasklet);
 		if (s & 0x00004000)
-			tasklet_schedule(&dev->input[6].tasklet);
+			tasklet_schedule(&dev->dma[6].tasklet);
 		if (s & 0x00008000)
-			tasklet_schedule(&dev->input[7].tasklet);
-
+			tasklet_schedule(&dev->dma[7].tasklet);
 		if (s & 0x00010000)
-			tasklet_schedule(&dev->output[0].tasklet);
+			tasklet_schedule(&dev->dma[8].tasklet);
 		if (s & 0x00020000)
-			tasklet_schedule(&dev->output[1].tasklet);
+			tasklet_schedule(&dev->dma[9].tasklet);
 		if (s & 0x00040000)
-			tasklet_schedule(&dev->output[2].tasklet);
+			tasklet_schedule(&dev->dma[10].tasklet);
 		if (s & 0x00080000)
-			tasklet_schedule(&dev->output[3].tasklet);
+			tasklet_schedule(&dev->dma[11].tasklet);
 
-		/* if (s & 0x000f0000)	printk(KERN_DEBUG "%08x\n", istat); */
-	} while ((s = ddbreadl(INTERRUPT_STATUS)));
+		/* if (s & 0x000f0000)	printk("%08x\n", istat); */
+	} while ((s = ddbreadl(dev, INTERRUPT_STATUS)));
 
 	return IRQ_HANDLED;
 }
@@ -1346,21 +2063,21 @@
 	u32 data, shift;
 
 	if (wlen > 4)
-		ddbwritel(1, SPI_CONTROL);
+		ddbwritel(dev, 1, SPI_CONTROL);
 	while (wlen > 4) {
 		/* FIXME: check for big-endian */
 		data = swab32(*(u32 *)wbuf);
 		wbuf += 4;
 		wlen -= 4;
-		ddbwritel(data, SPI_DATA);
-		while (ddbreadl(SPI_CONTROL) & 0x0004)
+		ddbwritel(dev, data, SPI_DATA);
+		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
 			;
 	}
 
 	if (rlen)
-		ddbwritel(0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+		ddbwritel(dev, 0x0001 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
 	else
-		ddbwritel(0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
+		ddbwritel(dev, 0x0003 | ((wlen << (8 + 3)) & 0x1f00), SPI_CONTROL);
 
 	data = 0;
 	shift = ((4 - wlen) * 8);
@@ -1372,33 +2089,33 @@
 	}
 	if (shift)
 		data <<= shift;
-	ddbwritel(data, SPI_DATA);
-	while (ddbreadl(SPI_CONTROL) & 0x0004)
+	ddbwritel(dev, data, SPI_DATA);
+	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
 		;
 
 	if (!rlen) {
-		ddbwritel(0, SPI_CONTROL);
+		ddbwritel(dev, 0, SPI_CONTROL);
 		return 0;
 	}
 	if (rlen > 4)
-		ddbwritel(1, SPI_CONTROL);
+		ddbwritel(dev, 1, SPI_CONTROL);
 
 	while (rlen > 4) {
-		ddbwritel(0xffffffff, SPI_DATA);
-		while (ddbreadl(SPI_CONTROL) & 0x0004)
+		ddbwritel(dev, 0xffffffff, SPI_DATA);
+		while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
 			;
-		data = ddbreadl(SPI_DATA);
+		data = ddbreadl(dev, SPI_DATA);
 		*(u32 *) rbuf = swab32(data);
 		rbuf += 4;
 		rlen -= 4;
 	}
-	ddbwritel(0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
-	ddbwritel(0xffffffff, SPI_DATA);
-	while (ddbreadl(SPI_CONTROL) & 0x0004)
+	ddbwritel(dev, 0x0003 | ((rlen << (8 + 3)) & 0x1F00), SPI_CONTROL);
+	ddbwritel(dev, 0xffffffff, SPI_DATA);
+	while (ddbreadl(dev, SPI_CONTROL) & 0x0004)
 		;
 
-	data = ddbreadl(SPI_DATA);
-	ddbwritel(0, SPI_CONTROL);
+	data = ddbreadl(dev, SPI_DATA);
+	ddbwritel(dev, 0, SPI_CONTROL);
 
 	if (rlen < 4)
 		data <<= ((4 - rlen) * 8);
@@ -1421,14 +2138,21 @@
 	__u32 read_len;
 };
 
+struct ddb_gpio {
+	__u32 mask;
+	__u32 data;
+};
+
+
 #define IOCTL_DDB_FLASHIO  _IOWR(DDB_MAGIC, 0x00, struct ddb_flashio)
+#define IOCTL_DDB_GPIO_IN  _IOWR(DDB_MAGIC, 0x01, struct ddb_gpio)
+#define IOCTL_DDB_GPIO_OUT _IOWR(DDB_MAGIC, 0x02, struct ddb_gpio)
 
 #define DDB_NAME "ddbridge"
 
 static u32 ddb_num;
-static struct ddb *ddbs[32];
-static struct class *ddb_class;
 static int ddb_major;
+static DEFINE_MUTEX(ddb_mutex);
 
 static int ddb_open(struct inode *inode, struct file *file)
 {
@@ -1470,6 +2194,16 @@
 			return -EFAULT;
 		break;
 	}
+	case IOCTL_DDB_GPIO_OUT:
+	{
+		struct ddb_gpio gpio;
+		if (copy_from_user(&gpio, parg, sizeof(gpio)))
+			break;
+		ddbwritel(dev, gpio.mask, GPIO_DIRECTION);
+		ddbwritel(dev, gpio.data, GPIO_OUTPUT);
+		res = 0;
+		break;
+	}
 	default:
 		return -ENOTTY;
 	}
@@ -1481,41 +2215,248 @@
 	.open           = ddb_open,
 };
 
-static char *ddb_devnode(struct device *device, umode_t *mode)
+static char *ddb_devnode(struct device *device, mode_t *mode)
 {
 	struct ddb *dev = dev_get_drvdata(device);
 
 	return kasprintf(GFP_KERNEL, "ddbridge/card%d", dev->nr);
 }
 
+static ssize_t ports_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", dev->info->port_num);
+}
+
+static ssize_t ts_irq_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", dev->ts_irq);
+}
+
+static ssize_t i2c_irq_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+
+	return sprintf(buf, "%d\n", dev->i2c_irq);
+}
+
+static char *class_name[] = {
+	"NONE", "CI", "TUNER", "LOOP"
+};
+
+static char *type_name[] = {
+	"NONE", "DVBS_ST", "DVBS_ST_AA", "DVBCT_TR", "DVBCT_ST", "INTERNAL", "CXD2099",
+};
+
+static ssize_t fan_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	u32 val;
+
+	val = ddbreadl(dev, GPIO_OUTPUT) & 1;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t fan_store(struct device *device, struct device_attribute *d,
+			 const char *buf, size_t count)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	unsigned val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	ddbwritel(dev, 1, GPIO_DIRECTION);
+	ddbwritel(dev, val & 1, GPIO_OUTPUT);
+	return count;
+}
+
+static ssize_t temp_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int temp;
+	u8 tmp[2];
+
+	if (!dev->info->temp_num)
+		return sprintf(buf, "no sensor\n");
+	if (i2c_read_regs(&dev->i2c[0].adap, 0x48, 0, tmp, 2) < 0)
+		return sprintf(buf, "read_error\n");
+	temp = (tmp[0] << 3) | (tmp[1] >> 5);
+	temp *= 125;
+	return sprintf(buf, "%d\n", temp);
+}
+
+static ssize_t mod_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+
+	return sprintf(buf, "%s:%s\n",
+		       class_name[dev->port[num].class],
+		       type_name[dev->port[num].type]);
+}
+
+static ssize_t led_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+
+	return sprintf(buf, "%d\n", dev->leds & (1 << num) ? 1 : 0);
+}
+
+
+static void ddb_set_led(struct ddb *dev, int num, int val)
+{
+	if (!dev->info->led_num)
+		return;
+	switch (dev->port[num].class) {
+	case DDB_PORT_TUNER:
+		switch (dev->port[num].type) {
+		case DDB_TUNER_DVBS_ST:
+			printk(KERN_INFO "LED %d %d\n", num, val);
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x69, 0xf14c, val ? 2 : 0);
+			break;
+		case DDB_TUNER_DVBCT_ST:
+			printk(KERN_INFO "LED %d %d\n", num, val);
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x1f, 0xf00e, 0);
+			i2c_write_reg16(&dev->i2c[num].adap,
+					0x1f, 0xf00f, val ? 1 : 0);
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static ssize_t led_store(struct device *device, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+	unsigned val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val)
+		dev->leds |= (1 << num);
+	else
+		dev->leds &= ~(1 << num);
+	ddb_set_led(dev, num, val);
+	return count;
+}
+
+static ssize_t snr_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	char snr[32];
+	int num = attr->attr.name[3] - 0x30;
+
+	/* serial number at 0x100-0x11f */
+	if (i2c_read_regs16(&dev->i2c[num].adap, 0x57, 0x100, snr, 32) < 0)
+		return sprintf(buf, "NO SNR\n");
+	snr[31] = 0; /* in case it is not terminated on EEPROM */
+	return sprintf(buf, "%s\n", snr);
+}
+
+
+static ssize_t snr_store(struct device *device, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct ddb *dev = dev_get_drvdata(device);
+	int num = attr->attr.name[3] - 0x30;
+	u8 snr[34] = { 0x01, 0x00 };
+
+	if (count > 31)
+		return -EINVAL;
+	memcpy(snr + 2, buf, count);
+	i2c_write(&dev->i2c[num].adap, 0x57, snr, 34);
+	return count;
+}
+
+static ssize_t redirect_show(struct device *device, struct device_attribute *attr, char *buf)
+{
+	return 0;
+}
+
+static ssize_t redirect_store(struct device *device, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	unsigned int i, p;
+	int res;
+
+	if (sscanf(buf, "%x %x\n", &i, &p) != 2)
+		return -EINVAL;
+	printk(KERN_INFO "redirect: %02x, %02x\n", i, p);
+	res = set_redirect(i, p);
+	if (res < 0)
+		return res;
+	return count;
+}
+
+#define __ATTR_MRO(_name, _show) {				\
+	.attr	= { .name = __stringify(_name), .mode = 0444 },	\
+	.show	= _show,					\
+}
+
+struct device_attribute ddb_attrs[] = {
+	__ATTR_RO(ports),
+	__ATTR_RO(ts_irq),
+	__ATTR_RO(i2c_irq),
+	__ATTR_MRO(mod0, mod_show),
+	__ATTR_MRO(mod1, mod_show),
+	__ATTR_MRO(mod2, mod_show),
+	__ATTR_MRO(mod3, mod_show),
+	__ATTR_RO(temp),
+	__ATTR(fan, 0666, fan_show, fan_store),
+	__ATTR(led0, 0666, led_show, led_store),
+	__ATTR(led1, 0666, led_show, led_store),
+	__ATTR(led2, 0666, led_show, led_store),
+	__ATTR(led3, 0666, led_show, led_store),
+	__ATTR(snr0, 0666, snr_show, snr_store),
+	__ATTR(snr1, 0666, snr_show, snr_store),
+	__ATTR(snr2, 0666, snr_show, snr_store),
+	__ATTR(snr3, 0666, snr_show, snr_store),
+	__ATTR(redirect, 0666, redirect_show, redirect_store),
+	__ATTR_NULL
+};
+
+static struct class ddb_class = {
+	.name		= "ddbridge",
+	.owner          = THIS_MODULE,
+	.dev_attrs	= ddb_attrs,
+	.devnode        = ddb_devnode,
+};
+
 static int ddb_class_create(void)
 {
 	ddb_major = register_chrdev(0, DDB_NAME, &ddb_fops);
 	if (ddb_major < 0)
 		return ddb_major;
-
-	ddb_class = class_create(THIS_MODULE, DDB_NAME);
-	if (IS_ERR(ddb_class)) {
-		unregister_chrdev(ddb_major, DDB_NAME);
+	if (class_register(&ddb_class) < 0)
 		return -1;
-	}
-	ddb_class->devnode = ddb_devnode;
 	return 0;
 }
 
 static void ddb_class_destroy(void)
 {
-	class_destroy(ddb_class);
+	class_unregister(&ddb_class);
 	unregister_chrdev(ddb_major, DDB_NAME);
 }
 
 static int ddb_device_create(struct ddb *dev)
 {
+	mutex_lock(&ddb_mutex);
 	dev->nr = ddb_num++;
-	dev->ddb_dev = device_create(ddb_class, NULL,
+	ddbs[dev->nr] = dev;
+	mutex_unlock(&ddb_mutex);
+	dev->ddb_dev = device_create(&ddb_class, &dev->pdev->dev,
 				     MKDEV(ddb_major, dev->nr),
 				     dev, "ddbridge%d", dev->nr);
-	ddbs[dev->nr] = dev;
 	if (IS_ERR(dev->ddb_dev))
 		return -1;
 	return 0;
@@ -1523,10 +2464,9 @@
 
 static void ddb_device_destroy(struct ddb *dev)
 {
-	ddb_num--;
 	if (IS_ERR(dev->ddb_dev))
 		return;
-	device_destroy(ddb_class, MKDEV(ddb_major, 0));
+	device_destroy(&ddb_class, MKDEV(ddb_major, dev->nr));
 }
 
 
@@ -1549,7 +2489,7 @@
 	ddb_ports_detach(dev);
 	ddb_i2c_release(dev);
 
-	ddbwritel(0, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0, INTERRUPT_ENABLE);
 	free_irq(dev->pdev->irq, dev);
 #ifdef CONFIG_PCI_MSI
 	if (dev->msi)
@@ -1564,7 +2504,6 @@
 	pci_disable_device(pdev);
 }
 
-
 static int __devinit ddb_probe(struct pci_dev *pdev,
 			       const struct pci_device_id *id)
 {
@@ -1575,10 +2514,9 @@
 	if (pci_enable_device(pdev) < 0)
 		return -ENODEV;
 
-	dev = vmalloc(sizeof(struct ddb));
+	dev = vzalloc(sizeof(struct ddb));
 	if (dev == NULL)
 		return -ENOMEM;
-	memset(dev, 0, sizeof(struct ddb));
 
 	dev->pdev = pdev;
 	pci_set_drvdata(pdev, dev);
@@ -1591,7 +2529,8 @@
 		stat = -ENOMEM;
 		goto fail;
 	}
-	printk(KERN_INFO "HW %08x FW %08x\n", ddbreadl(0), ddbreadl(4));
+	printk(KERN_INFO "HW %08x REG %08x\n",
+	       ddbreadl(dev, 0), ddbreadl(dev, 4));
 
 #ifdef CONFIG_PCI_MSI
 	if (pci_msi_enabled())
@@ -1607,11 +2546,11 @@
 			   irq_flag, "DDBridge", (void *) dev);
 	if (stat < 0)
 		goto fail1;
-	ddbwritel(0, DMA_BASE_WRITE);
-	ddbwritel(0, DMA_BASE_READ);
-	ddbwritel(0xffffffff, INTERRUPT_ACK);
-	ddbwritel(0xfff0f, INTERRUPT_ENABLE);
-	ddbwritel(0, MSI1_ENABLE);
+	ddbwritel(dev, 0, DMA_BASE_WRITE);
+	ddbwritel(dev, 0, DMA_BASE_READ);
+	ddbwritel(dev, 0xffffffff, INTERRUPT_ACK);
+	ddbwritel(dev, 0x000fff0f, INTERRUPT_ENABLE);
+	ddbwritel(dev, 0, MSI1_ENABLE);
 
 	if (ddb_i2c_init(dev) < 0)
 		goto fail1;
@@ -1622,7 +2561,13 @@
 	}
 	if (ddb_ports_attach(dev) < 0)
 		goto fail3;
+
 	ddb_device_create(dev);
+
+	if (dev->info->fan_num)	{
+		ddbwritel(dev, 1, GPIO_DIRECTION);
+		ddbwritel(dev, 1, GPIO_OUTPUT);
+	}
 	return 0;
 
 fail3:
@@ -1632,11 +2577,14 @@
 fail2:
 	printk(KERN_ERR "fail2\n");
 	ddb_buffers_free(dev);
+	ddb_i2c_release(dev);
 fail1:
 	printk(KERN_ERR "fail1\n");
+	free_irq(dev->pdev->irq, dev);
+#ifdef CONFIG_PCI_MSI
 	if (dev->msi)
 		pci_disable_msi(dev->pdev);
-	free_irq(dev->pdev->irq, dev);
+#endif
 fail:
 	printk(KERN_ERR "fail\n");
 	ddb_unmap(dev);
@@ -1658,23 +2606,65 @@
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus DVB adapter",
 	.port_num = 4,
+	.i2c_num  = 4,
 };
 
 static struct ddb_info ddb_octopus_le = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Octopus LE DVB adapter",
 	.port_num = 2,
+	.i2c_num  = 2,
+};
+
+static struct ddb_info ddb_octopus_oem = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus OEM",
+	.port_num = 4,
+	.i2c_num  = 4,
+	.led_num  = 1,
+	.fan_num  = 1,
+	.temp_num = 1,
+};
+
+static struct ddb_info ddb_octopus_mini = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices Octopus Mini",
+	.port_num = 4,
+	.i2c_num  = 4,
 };
 
 static struct ddb_info ddb_v6 = {
 	.type     = DDB_OCTOPUS,
 	.name     = "Digital Devices Cine S2 V6 DVB adapter",
 	.port_num = 3,
+	.i2c_num  = 3,
+};
+
+static struct ddb_info ddb_dvbct = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Digital Devices DVBCT V6.1 DVB adapter",
+	.port_num = 3,
+	.i2c_num  = 3,
+};
+
+static struct ddb_info ddb_satixS2v3 = {
+	.type     = DDB_OCTOPUS,
+	.name     = "Mystique SaTiX-S2 V3 DVB adapter",
+	.port_num = 3,
+	.i2c_num  = 3,
 };
 
+static struct ddb_info ddb_ci = {
+	.type     = DDB_OCTOPUS_CI,
+	.name     = "Digital Devices Octopus CI",
+	.port_num = 4,
+	.i2c_num  = 2,
+};
+
+
 #define DDVID 0xdd01 /* Digital Devices Vendor ID */
 
-#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) {	\
+#define DDB_ID(_vend, _dev, _subvend, _subdev, _driverdata) { \
 	.vendor      = _vend,    .device    = _dev, \
 	.subvendor   = _subvend, .subdevice = _subdev, \
 	.driver_data = (unsigned long)&_driverdata }
@@ -1683,8 +2673,12 @@
 	DDB_ID(DDVID, 0x0002, DDVID, 0x0001, ddb_octopus),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0001, ddb_octopus),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0002, ddb_octopus_le),
-	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0003, ddb_octopus_oem),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0010, ddb_octopus_mini),
 	DDB_ID(DDVID, 0x0003, DDVID, 0x0020, ddb_v6),
+	DDB_ID(DDVID, 0x0003, DDVID, 0x0030, ddb_dvbct),
+	DDB_ID(DDVID, 0x0003, DDVID, 0xdb03, ddb_satixS2v3),
+	DDB_ID(DDVID, 0x0011, DDVID, 0x0040, ddb_ci),
 	/* in case sub-ids got deleted in flash */
 	DDB_ID(DDVID, 0x0003, PCI_ANY_ID, PCI_ANY_ID, ddb_none),
 	{0}
@@ -1701,11 +2695,16 @@
 
 static __init int module_init_ddbridge(void)
 {
+	int stat;
+
 	printk(KERN_INFO "Digital Devices PCIE bridge driver, "
 	       "Copyright (C) 2010-11 Digital Devices GmbH\n");
 	if (ddb_class_create())
 		return -1;
-	return pci_register_driver(&ddb_pci_driver);
+	stat = pci_register_driver(&ddb_pci_driver);
+	if (stat < 0)
+		ddb_class_destroy();
+	return stat;
 }
 
 static __exit void module_exit_ddbridge(void)
@@ -1720,4 +2719,4 @@
 MODULE_DESCRIPTION("Digital Devices PCIe Bridge");
 MODULE_AUTHOR("Ralph Metzler");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("0.5");
+MODULE_VERSION("0.8");
diff -urN linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge.h linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge.h
--- linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge.h	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge.h	2012-06-18 23:17:45.304033609 +0200
@@ -32,7 +32,10 @@
 #include <asm/dma.h>
 #include <linux/dvb/frontend.h>
 #include <linux/dvb/ca.h>
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
 #include <linux/socket.h>
+#include <linux/device.h>
 
 #include "dmxdev.h"
 #include "dvbdev.h"
@@ -41,7 +44,7 @@
 #include "dvb_ringbuffer.h"
 #include "dvb_ca_en50221.h"
 #include "dvb_net.h"
-#include "cxd2099.h"
+#include "../drivers/staging/media/cxd2099/cxd2099.h"
 
 #define DDB_MAX_I2C     4
 #define DDB_MAX_PORT    4
@@ -52,43 +55,53 @@
 	int   type;
 #define DDB_NONE         0
 #define DDB_OCTOPUS      1
+#define DDB_OCTOPUS_CI   2
 	char *name;
 	int   port_num;
-	u32   port_type[DDB_MAX_PORT];
+	int   i2c_num;
+	int   led_num;
+	int   fan_num;
+	int   temp_num;
 };
 
 /* DMA_SIZE MUST be divisible by 188 and 128 !!! */
 
-#define INPUT_DMA_MAX_BUFS 32      /* hardware table limit */
+#define DMA_MAX_BUFS 32      /* hardware table limit */
+
 #define INPUT_DMA_BUFS 8
 #define INPUT_DMA_SIZE (128*47*21)
+#define INPUT_DMA_IRQ_DIV 1
 
-#define OUTPUT_DMA_MAX_BUFS 32
 #define OUTPUT_DMA_BUFS 8
 #define OUTPUT_DMA_SIZE (128*47*21)
+#define OUTPUT_DMA_IRQ_DIV 1
 
 struct ddb;
 struct ddb_port;
 
-struct ddb_input {
-	struct ddb_port       *port;
+struct ddb_dma {
+	void                  *io;
 	u32                    nr;
-	int                    attached;
-
-	dma_addr_t             pbuf[INPUT_DMA_MAX_BUFS];
-	u8                    *vbuf[INPUT_DMA_MAX_BUFS];
-	u32                    dma_buf_num;
-	u32                    dma_buf_size;
+	dma_addr_t             pbuf[DMA_MAX_BUFS];
+	u8                    *vbuf[DMA_MAX_BUFS];
+	u32                    num;
+	u32                    size;
+	u32                    div;
+	u32                    bufreg;
 
 	struct tasklet_struct  tasklet;
 	spinlock_t             lock;
 	wait_queue_head_t      wq;
 	int                    running;
 	u32                    stat;
+	u32                    ctrl;
 	u32                    cbuf;
 	u32                    coff;
+};
 
-	struct dvb_adapter     adap;
+struct ddb_dvb {
+	struct dvb_adapter    *adap;
+	int                    adap_registered;
 	struct dvb_device     *dev;
 	struct dvb_frontend   *fe;
 	struct dvb_frontend   *fe2;
@@ -99,32 +112,36 @@
 	struct dmx_frontend    mem_frontend;
 	int                    users;
 	int (*gate_ctrl)(struct dvb_frontend *, int);
+	int                    attached;
 };
 
-struct ddb_output {
+struct ddb_ci {
+	struct dvb_ca_en50221  en;
 	struct ddb_port       *port;
 	u32                    nr;
-	dma_addr_t             pbuf[OUTPUT_DMA_MAX_BUFS];
-	u8                    *vbuf[OUTPUT_DMA_MAX_BUFS];
-	u32                    dma_buf_num;
-	u32                    dma_buf_size;
-	struct tasklet_struct  tasklet;
-	spinlock_t             lock;
-	wait_queue_head_t      wq;
-	int                    running;
-	u32                    stat;
-	u32                    cbuf;
-	u32                    coff;
+};
 
-	struct dvb_adapter     adap;
-	struct dvb_device     *dev;
+
+struct ddb_input {
+	struct ddb_port       *port;
+	u32                    nr;
+	struct ddb_dma        *dma;
+	struct ddb_input      *redirect;
+
+	struct ddb_dvb         dvb;
+};
+
+struct ddb_output {
+	struct ddb_port       *port;
+	u32                    nr;
+	struct ddb_dma        *dma;
+	struct ddb_input      *redirect;
 };
 
 struct ddb_i2c {
 	struct ddb            *dev;
 	u32                    nr;
 	struct i2c_adapter     adap;
-	struct i2c_adapter     adap2;
 	u32                    regs;
 	u32                    rbuf;
 	u32                    wbuf;
@@ -141,12 +158,15 @@
 #define DDB_PORT_NONE           0
 #define DDB_PORT_CI             1
 #define DDB_PORT_TUNER          2
+#define DDB_PORT_LOOP           3
 	u32                    type;
 #define DDB_TUNER_NONE          0
 #define DDB_TUNER_DVBS_ST       1
 #define DDB_TUNER_DVBS_ST_AA    2
-#define DDB_TUNER_DVBCT_TR     16
-#define DDB_TUNER_DVBCT_ST     17
+#define DDB_TUNER_DVBCT_TR      3
+#define DDB_TUNER_DVBCT_ST      4
+#define DDB_CI_INTERNAL         5
+#define DDB_CI_EXTERNAL_SONY    6
 	u32                    adr;
 
 	struct ddb_input      *input[2];
@@ -161,25 +181,20 @@
 	struct ddb_i2c         i2c[DDB_MAX_I2C];
 	struct ddb_input       input[DDB_MAX_INPUT];
 	struct ddb_output      output[DDB_MAX_OUTPUT];
+	struct dvb_adapter     adap[DDB_MAX_INPUT];
+	struct ddb_dma         dma[DDB_MAX_INPUT + DDB_MAX_OUTPUT];
 
 	struct device         *ddb_dev;
-	int                    nr;
+	u32                    nr;
 	u8                     iobuf[1028];
 
 	struct ddb_info       *info;
 	int                    msi;
-};
-
-/****************************************************************************/
 
-#define ddbwritel(_val, _adr)        writel((_val), \
-				     (char *) (dev->regs+(_adr)))
-#define ddbreadl(_adr)               readl((char *) (dev->regs+(_adr)))
-#define ddbcpyto(_adr, _src, _count) memcpy_toio((char *)	\
-				     (dev->regs+(_adr)), (_src), (_count))
-#define ddbcpyfrom(_dst, _adr, _count) memcpy_fromio((_dst), (char *) \
-				       (dev->regs+(_adr)), (_count))
+	u8                     leds;
 
-/****************************************************************************/
+	u32                    ts_irq;
+	u32                    i2c_irq;
+};
 
 #endif
diff -urN linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge-regs.h linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge-regs.h
--- linux-3.4.3/drivers/media/dvb/ddbridge/ddbridge-regs.h	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ddbridge/ddbridge-regs.h	2012-06-18 22:31:48.134032196 +0200
@@ -21,11 +21,12 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
-/* DD-DVBBridgeV1.h 273 2010-09-17 05:03:16Z manfred */
+/* DD-DVBBridgeV1.h 388 2011-07-13 20:47:08Z manfred */
 
 /* Register Definitions */
 
-#define CUR_REGISTERMAP_VERSION 0x10000
+#define CUR_REGISTERMAP_VERSION     0x10003
+#define CUR_REGISTERMAP_VERSION_CI  0x10000
 
 #define HARDWARE_VERSION       0x00
 #define REGISTERMAP_VERSION    0x04
@@ -36,8 +37,14 @@
 #define SPI_CONTROL     0x10
 #define SPI_DATA        0x14
 
-/* ------------------------------------------------------------------------- */
+/* -------------------------------------------------------------------------- */
+/* GPIO */
+
+#define GPIO_OUTPUT      0x20
+#define GPIO_INPUT       0x24
+#define GPIO_DIRECTION   0x28
 
+/* -------------------------------------------------------------------------- */
 /* Interrupt controller                                     */
 /* How many MSI's are available depends on HW (Min 2 max 8) */
 /* How many are usable also depends on Host platform        */
@@ -149,3 +156,46 @@
 #define DMA_BASE_ADDRESS_TABLE  (0x2000)
 #define DMA_BASE_ADDRESS_TABLE_ENTRIES (512)
 
+/* -------------------------------------------------------------------------- */
+/* CI Interface (only CI-Bridge) */
+
+#define CI_BASE                     (0x400)
+#define CI_CONTROL(i)               (CI_BASE + (i) * 32 + 0x00)
+
+#define CI_DO_ATTRIBUTE_RW(i)       (CI_BASE + (i) * 32 + 0x04)
+#define CI_DO_IO_RW(i)              (CI_BASE + (i) * 32 + 0x08)
+#define CI_READDATA(i)              (CI_BASE + (i) * 32 + 0x0c)
+#define CI_DO_READ_ATTRIBUTES(i)    (CI_BASE + (i) * 32 + 0x10)
+
+#define CI_RESET_CAM                    (0x00000001)
+#define CI_POWER_ON                     (0x00000002)
+#define CI_ENABLE                       (0x00000004)
+#define CI_BLOCKIO_ENABLE               (0x00000008)
+#define CI_BYPASS_DISABLE               (0x00000010)
+#define CI_DISABLE_AUTO_OFF             (0x00000020)
+
+#define CI_CAM_READY                    (0x00010000)
+#define CI_CAM_DETECT                   (0x00020000)
+#define CI_READY                        (0x80000000)
+#define CI_BLOCKIO_ACTIVE               (0x40000000)
+#define CI_BLOCKIO_RCVDATA              (0x20000000)
+#define CI_BLOCKIO_SEND_PENDING         (0x10000000)
+#define CI_BLOCKIO_SEND_COMPLETE        (0x08000000)
+
+#define CI_READ_CMD                     (0x40000000)
+#define CI_WRITE_CMD                    (0x80000000)
+
+#define CI_BLOCKIO_SEND(i)              (CI_BASE + (i) * 32 + 0x14)
+#define CI_BLOCKIO_RECEIVE(i)           (CI_BASE + (i) * 32 + 0x18)
+
+#define CI_BLOCKIO_SEND_COMMAND         (0x80000000)
+#define CI_BLOCKIO_SEND_COMPLETE_ACK    (0x40000000)
+#define CI_BLOCKIO_RCVDATA_ACK          (0x40000000)
+
+#define CI_BUFFER_BASE                  (0x3000)
+#define CI_BUFFER_SIZE                  (0x0800)
+#define CI_BLOCKIO_BUFFER_SIZE          (CI_BUFFER_SIZE/2)
+
+#define CI_BUFFER(i)                    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
+#define CI_BLOCKIO_RECEIVE_BUFFER(i)    (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE)
+#define CI_BLOCKIO_SEND_BUFFER(i)       (CI_BUFFER_BASE + (i) * CI_BUFFER_SIZE + CI_BLOCKIO_BUFFER_SIZE)
diff -urN linux-3.4.3/drivers/media/dvb/ddbridge/Kconfig linux-3.4.3.dd/drivers/media/dvb/ddbridge/Kconfig
--- linux-3.4.3/drivers/media/dvb/ddbridge/Kconfig	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ddbridge/Kconfig	2012-06-18 22:31:48.134032196 +0200
@@ -6,6 +6,8 @@
 	select DVB_STV090x if !DVB_FE_CUSTOMISE
 	select DVB_DRXK if !DVB_FE_CUSTOMISE
 	select DVB_TDA18271C2DD if !DVB_FE_CUSTOMISE
+	select DVB_STV0367DD if !DVB_FE_CUSTOMISE
+	select DVB_TDA18212DD if !DVB_FE_CUSTOMISE
 	---help---
 	  Support for cards with the Digital Devices PCI express bridge:
 	  - Octopus PCIe Bridge
@@ -14,5 +16,6 @@
 	  - DuoFlex S2 Octopus
 	  - DuoFlex CT Octopus
 	  - cineS2(v6)
+	  - cineCT(v6)
 
 	  Say Y if you own such a card and want to use it.
diff -urN linux-3.4.3/drivers/media/dvb/ddbridge/Makefile linux-3.4.3.dd/drivers/media/dvb/ddbridge/Makefile
--- linux-3.4.3/drivers/media/dvb/ddbridge/Makefile	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ddbridge/Makefile	2012-06-18 22:31:48.134032196 +0200
@@ -11,4 +11,4 @@
 ccflags-y += -Idrivers/media/common/tuners/
 
 # For the staging CI driver cxd2099
-ccflags-y += -Idrivers/staging/media/cxd2099/
+ccflags-y += -Idrivers/staging/cxd2099/
diff -urN linux-3.4.3/drivers/media/dvb/frontends/drxk_hard.c linux-3.4.3.dd/drivers/media/dvb/frontends/drxk_hard.c
--- linux-3.4.3/drivers/media/dvb/frontends/drxk_hard.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/drxk_hard.c	2012-06-18 22:35:32.964032312 +0200
@@ -1952,6 +1952,7 @@
 		status = GetDVBTLockStatus(state, pLockStatus);
 		break;
 	default:
+		status = 0;
 		break;
 	}
 error:
diff -urN linux-3.4.3/drivers/media/dvb/frontends/drxk_hard.c.orig linux-3.4.3.dd/drivers/media/dvb/frontends/drxk_hard.c.orig
--- linux-3.4.3/drivers/media/dvb/frontends/drxk_hard.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/drxk_hard.c.orig	2012-06-17 20:21:44.000000000 +0200
@@ -0,0 +1,6451 @@
+/*
+ * drxk_hard: DRX-K DVB-C/T demodulator driver
+ *
+ * Copyright (C) 2010-2011 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <asm/div64.h>
+
+#include "dvb_frontend.h"
+#include "drxk.h"
+#include "drxk_hard.h"
+
+static int PowerDownDVBT(struct drxk_state *state, bool setPowerMode);
+static int PowerDownQAM(struct drxk_state *state);
+static int SetDVBTStandard(struct drxk_state *state,
+			   enum OperationMode oMode);
+static int SetQAMStandard(struct drxk_state *state,
+			  enum OperationMode oMode);
+static int SetQAM(struct drxk_state *state, u16 IntermediateFreqkHz,
+		  s32 tunerFreqOffset);
+static int SetDVBTStandard(struct drxk_state *state,
+			   enum OperationMode oMode);
+static int DVBTStart(struct drxk_state *state);
+static int SetDVBT(struct drxk_state *state, u16 IntermediateFreqkHz,
+		   s32 tunerFreqOffset);
+static int GetQAMLockStatus(struct drxk_state *state, u32 *pLockStatus);
+static int GetDVBTLockStatus(struct drxk_state *state, u32 *pLockStatus);
+static int SwitchAntennaToQAM(struct drxk_state *state);
+static int SwitchAntennaToDVBT(struct drxk_state *state);
+
+static bool IsDVBT(struct drxk_state *state)
+{
+	return state->m_OperationMode == OM_DVBT;
+}
+
+static bool IsQAM(struct drxk_state *state)
+{
+	return state->m_OperationMode == OM_QAM_ITU_A ||
+	    state->m_OperationMode == OM_QAM_ITU_B ||
+	    state->m_OperationMode == OM_QAM_ITU_C;
+}
+
+bool IsA1WithPatchCode(struct drxk_state *state)
+{
+	return state->m_DRXK_A1_PATCH_CODE;
+}
+
+bool IsA1WithRomCode(struct drxk_state *state)
+{
+	return state->m_DRXK_A1_ROM_CODE;
+}
+
+#define NOA1ROM 0
+
+#define DRXDAP_FASI_SHORT_FORMAT(addr) (((addr) & 0xFC30FF80) == 0)
+#define DRXDAP_FASI_LONG_FORMAT(addr)  (((addr) & 0xFC30FF80) != 0)
+
+#define DEFAULT_MER_83  165
+#define DEFAULT_MER_93  250
+
+#ifndef DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH
+#define DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH (0x02)
+#endif
+
+#ifndef DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH
+#define DRXK_MPEG_PARALLEL_OUTPUT_PIN_DRIVE_STRENGTH (0x03)
+#endif
+
+#define DEFAULT_DRXK_MPEG_LOCK_TIMEOUT 700
+#define DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT 500
+
+#ifndef DRXK_KI_RAGC_ATV
+#define DRXK_KI_RAGC_ATV   4
+#endif
+#ifndef DRXK_KI_IAGC_ATV
+#define DRXK_KI_IAGC_ATV   6
+#endif
+#ifndef DRXK_KI_DAGC_ATV
+#define DRXK_KI_DAGC_ATV   7
+#endif
+
+#ifndef DRXK_KI_RAGC_QAM
+#define DRXK_KI_RAGC_QAM   3
+#endif
+#ifndef DRXK_KI_IAGC_QAM
+#define DRXK_KI_IAGC_QAM   4
+#endif
+#ifndef DRXK_KI_DAGC_QAM
+#define DRXK_KI_DAGC_QAM   7
+#endif
+#ifndef DRXK_KI_RAGC_DVBT
+#define DRXK_KI_RAGC_DVBT  (IsA1WithPatchCode(state) ? 3 : 2)
+#endif
+#ifndef DRXK_KI_IAGC_DVBT
+#define DRXK_KI_IAGC_DVBT  (IsA1WithPatchCode(state) ? 4 : 2)
+#endif
+#ifndef DRXK_KI_DAGC_DVBT
+#define DRXK_KI_DAGC_DVBT  (IsA1WithPatchCode(state) ? 10 : 7)
+#endif
+
+#ifndef DRXK_AGC_DAC_OFFSET
+#define DRXK_AGC_DAC_OFFSET (0x800)
+#endif
+
+#ifndef DRXK_BANDWIDTH_8MHZ_IN_HZ
+#define DRXK_BANDWIDTH_8MHZ_IN_HZ  (0x8B8249L)
+#endif
+
+#ifndef DRXK_BANDWIDTH_7MHZ_IN_HZ
+#define DRXK_BANDWIDTH_7MHZ_IN_HZ  (0x7A1200L)
+#endif
+
+#ifndef DRXK_BANDWIDTH_6MHZ_IN_HZ
+#define DRXK_BANDWIDTH_6MHZ_IN_HZ  (0x68A1B6L)
+#endif
+
+#ifndef DRXK_QAM_SYMBOLRATE_MAX
+#define DRXK_QAM_SYMBOLRATE_MAX         (7233000)
+#endif
+
+#define DRXK_BL_ROM_OFFSET_TAPS_DVBT    56
+#define DRXK_BL_ROM_OFFSET_TAPS_ITU_A   64
+#define DRXK_BL_ROM_OFFSET_TAPS_ITU_C   0x5FE0
+#define DRXK_BL_ROM_OFFSET_TAPS_BG      24
+#define DRXK_BL_ROM_OFFSET_TAPS_DKILLP  32
+#define DRXK_BL_ROM_OFFSET_TAPS_NTSC    40
+#define DRXK_BL_ROM_OFFSET_TAPS_FM      48
+#define DRXK_BL_ROM_OFFSET_UCODE        0
+
+#define DRXK_BLC_TIMEOUT                100
+
+#define DRXK_BLCC_NR_ELEMENTS_TAPS      2
+#define DRXK_BLCC_NR_ELEMENTS_UCODE     6
+
+#define DRXK_BLDC_NR_ELEMENTS_TAPS      28
+
+#ifndef DRXK_OFDM_NE_NOTCH_WIDTH
+#define DRXK_OFDM_NE_NOTCH_WIDTH             (4)
+#endif
+
+#define DRXK_QAM_SL_SIG_POWER_QAM16       (40960)
+#define DRXK_QAM_SL_SIG_POWER_QAM32       (20480)
+#define DRXK_QAM_SL_SIG_POWER_QAM64       (43008)
+#define DRXK_QAM_SL_SIG_POWER_QAM128      (20992)
+#define DRXK_QAM_SL_SIG_POWER_QAM256      (43520)
+
+static unsigned int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "enable debug messages");
+
+#define dprintk(level, fmt, arg...) do {			\
+if (debug >= level)						\
+	printk(KERN_DEBUG "drxk: %s" fmt, __func__, ## arg);	\
+} while (0)
+
+
+static inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64) a * (u64) b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+inline u32 Frac28a(u32 a, u32 c)
+{
+	int i = 0;
+	u32 Q1 = 0;
+	u32 R0 = 0;
+
+	R0 = (a % c) << 4;	/* 32-28 == 4 shifts possible at max */
+	Q1 = a / c;		/* integer part, only the 4 least significant bits
+				   will be visible in the result */
+
+	/* division using radix 16, 7 nibbles in the result */
+	for (i = 0; i < 7; i++) {
+		Q1 = (Q1 << 4) | (R0 / c);
+		R0 = (R0 % c) << 4;
+	}
+	/* rounding */
+	if ((R0 >> 3) >= c)
+		Q1++;
+
+	return Q1;
+}
+
+static u32 Log10Times100(u32 x)
+{
+	static const u8 scale = 15;
+	static const u8 indexWidth = 5;
+	u8 i = 0;
+	u32 y = 0;
+	u32 d = 0;
+	u32 k = 0;
+	u32 r = 0;
+	/*
+	   log2lut[n] = (1<<scale) * 200 * log2(1.0 + ((1.0/(1<<INDEXWIDTH)) * n))
+	   0 <= n < ((1<<INDEXWIDTH)+1)
+	 */
+
+	static const u32 log2lut[] = {
+		0,		/* 0.000000 */
+		290941,		/* 290941.300628 */
+		573196,		/* 573196.476418 */
+		847269,		/* 847269.179851 */
+		1113620,	/* 1113620.489452 */
+		1372674,	/* 1372673.576986 */
+		1624818,	/* 1624817.752104 */
+		1870412,	/* 1870411.981536 */
+		2109788,	/* 2109787.962654 */
+		2343253,	/* 2343252.817465 */
+		2571091,	/* 2571091.461923 */
+		2793569,	/* 2793568.696416 */
+		3010931,	/* 3010931.055901 */
+		3223408,	/* 3223408.452106 */
+		3431216,	/* 3431215.635215 */
+		3634553,	/* 3634553.498355 */
+		3833610,	/* 3833610.244726 */
+		4028562,	/* 4028562.434393 */
+		4219576,	/* 4219575.925308 */
+		4406807,	/* 4406806.721144 */
+		4590402,	/* 4590401.736809 */
+		4770499,	/* 4770499.491025 */
+		4947231,	/* 4947230.734179 */
+		5120719,	/* 5120719.018555 */
+		5291081,	/* 5291081.217197 */
+		5458428,	/* 5458427.996830 */
+		5622864,	/* 5622864.249668 */
+		5784489,	/* 5784489.488298 */
+		5943398,	/* 5943398.207380 */
+		6099680,	/* 6099680.215452 */
+		6253421,	/* 6253420.939751 */
+		6404702,	/* 6404701.706649 */
+		6553600,	/* 6553600.000000 */
+	};
+
+
+	if (x == 0)
+		return 0;
+
+	/* Scale x (normalize) */
+	/* computing y in log(x/y) = log(x) - log(y) */
+	if ((x & ((0xffffffff) << (scale + 1))) == 0) {
+		for (k = scale; k > 0; k--) {
+			if (x & (((u32) 1) << scale))
+				break;
+			x <<= 1;
+		}
+	} else {
+		for (k = scale; k < 31; k++) {
+			if ((x & (((u32) (-1)) << (scale + 1))) == 0)
+				break;
+			x >>= 1;
+		}
+	}
+	/*
+	   Now x has binary point between bit[scale] and bit[scale-1]
+	   and 1.0 <= x < 2.0 */
+
+	/* correction for divison: log(x) = log(x/y)+log(y) */
+	y = k * ((((u32) 1) << scale) * 200);
+
+	/* remove integer part */
+	x &= ((((u32) 1) << scale) - 1);
+	/* get index */
+	i = (u8) (x >> (scale - indexWidth));
+	/* compute delta (x - a) */
+	d = x & ((((u32) 1) << (scale - indexWidth)) - 1);
+	/* compute log, multiplication (d* (..)) must be within range ! */
+	y += log2lut[i] +
+	    ((d * (log2lut[i + 1] - log2lut[i])) >> (scale - indexWidth));
+	/* Conver to log10() */
+	y /= 108853;		/* (log2(10) << scale) */
+	r = (y >> 1);
+	/* rounding */
+	if (y & ((u32) 1))
+		r++;
+	return r;
+}
+
+/****************************************************************************/
+/* I2C **********************************************************************/
+/****************************************************************************/
+
+static int i2c_read1(struct i2c_adapter *adapter, u8 adr, u8 *val)
+{
+	struct i2c_msg msgs[1] = { {.addr = adr, .flags = I2C_M_RD,
+				    .buf = val, .len = 1}
+	};
+
+	return i2c_transfer(adapter, msgs, 1);
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	int status;
+	struct i2c_msg msg = {
+	    .addr = adr, .flags = 0, .buf = data, .len = len };
+
+	dprintk(3, ":");
+	if (debug > 2) {
+		int i;
+		for (i = 0; i < len; i++)
+			printk(KERN_CONT " %02x", data[i]);
+		printk(KERN_CONT "\n");
+	}
+	status = i2c_transfer(adap, &msg, 1);
+	if (status >= 0 && status != 1)
+		status = -EIO;
+
+	if (status < 0)
+		printk(KERN_ERR "drxk: i2c write error at addr 0x%02x\n", adr);
+
+	return status;
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	int status;
+	struct i2c_msg msgs[2] = {
+		{.addr = adr, .flags = 0,
+				    .buf = msg, .len = len},
+		{.addr = adr, .flags = I2C_M_RD,
+		 .buf = answ, .len = alen}
+	};
+
+	status = i2c_transfer(adap, msgs, 2);
+	if (status != 2) {
+		if (debug > 2)
+			printk(KERN_CONT ": ERROR!\n");
+		if (status >= 0)
+			status = -EIO;
+
+		printk(KERN_ERR "drxk: i2c read error at addr 0x%02x\n", adr);
+		return status;
+	}
+	if (debug > 2) {
+		int i;
+		dprintk(2, ": read from");
+		for (i = 0; i < len; i++)
+			printk(KERN_CONT " %02x", msg[i]);
+		printk(KERN_CONT ", value = ");
+		for (i = 0; i < alen; i++)
+			printk(KERN_CONT " %02x", answ[i]);
+		printk(KERN_CONT "\n");
+	}
+	return 0;
+}
+
+static int read16_flags(struct drxk_state *state, u32 reg, u16 *data, u8 flags)
+{
+	int status;
+	u8 adr = state->demod_address, mm1[4], mm2[2], len;
+
+	if (state->single_master)
+		flags |= 0xC0;
+
+	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
+		mm1[0] = (((reg << 1) & 0xFF) | 0x01);
+		mm1[1] = ((reg >> 16) & 0xFF);
+		mm1[2] = ((reg >> 24) & 0xFF) | flags;
+		mm1[3] = ((reg >> 7) & 0xFF);
+		len = 4;
+	} else {
+		mm1[0] = ((reg << 1) & 0xFF);
+		mm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
+		len = 2;
+	}
+	dprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);
+	status = i2c_read(state->i2c, adr, mm1, len, mm2, 2);
+	if (status < 0)
+		return status;
+	if (data)
+		*data = mm2[0] | (mm2[1] << 8);
+
+	return 0;
+}
+
+static int read16(struct drxk_state *state, u32 reg, u16 *data)
+{
+	return read16_flags(state, reg, data, 0);
+}
+
+static int read32_flags(struct drxk_state *state, u32 reg, u32 *data, u8 flags)
+{
+	int status;
+	u8 adr = state->demod_address, mm1[4], mm2[4], len;
+
+	if (state->single_master)
+		flags |= 0xC0;
+
+	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
+		mm1[0] = (((reg << 1) & 0xFF) | 0x01);
+		mm1[1] = ((reg >> 16) & 0xFF);
+		mm1[2] = ((reg >> 24) & 0xFF) | flags;
+		mm1[3] = ((reg >> 7) & 0xFF);
+		len = 4;
+	} else {
+		mm1[0] = ((reg << 1) & 0xFF);
+		mm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
+		len = 2;
+	}
+	dprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);
+	status = i2c_read(state->i2c, adr, mm1, len, mm2, 4);
+	if (status < 0)
+		return status;
+	if (data)
+		*data = mm2[0] | (mm2[1] << 8) |
+		    (mm2[2] << 16) | (mm2[3] << 24);
+
+	return 0;
+}
+
+static int read32(struct drxk_state *state, u32 reg, u32 *data)
+{
+	return read32_flags(state, reg, data, 0);
+}
+
+static int write16_flags(struct drxk_state *state, u32 reg, u16 data, u8 flags)
+{
+	u8 adr = state->demod_address, mm[6], len;
+
+	if (state->single_master)
+		flags |= 0xC0;
+	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
+		mm[0] = (((reg << 1) & 0xFF) | 0x01);
+		mm[1] = ((reg >> 16) & 0xFF);
+		mm[2] = ((reg >> 24) & 0xFF) | flags;
+		mm[3] = ((reg >> 7) & 0xFF);
+		len = 4;
+	} else {
+		mm[0] = ((reg << 1) & 0xFF);
+		mm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
+		len = 2;
+	}
+	mm[len] = data & 0xff;
+	mm[len + 1] = (data >> 8) & 0xff;
+
+	dprintk(2, "(0x%08x, 0x%04x, 0x%02x)\n", reg, data, flags);
+	return i2c_write(state->i2c, adr, mm, len + 2);
+}
+
+static int write16(struct drxk_state *state, u32 reg, u16 data)
+{
+	return write16_flags(state, reg, data, 0);
+}
+
+static int write32_flags(struct drxk_state *state, u32 reg, u32 data, u8 flags)
+{
+	u8 adr = state->demod_address, mm[8], len;
+
+	if (state->single_master)
+		flags |= 0xC0;
+	if (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {
+		mm[0] = (((reg << 1) & 0xFF) | 0x01);
+		mm[1] = ((reg >> 16) & 0xFF);
+		mm[2] = ((reg >> 24) & 0xFF) | flags;
+		mm[3] = ((reg >> 7) & 0xFF);
+		len = 4;
+	} else {
+		mm[0] = ((reg << 1) & 0xFF);
+		mm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));
+		len = 2;
+	}
+	mm[len] = data & 0xff;
+	mm[len + 1] = (data >> 8) & 0xff;
+	mm[len + 2] = (data >> 16) & 0xff;
+	mm[len + 3] = (data >> 24) & 0xff;
+	dprintk(2, "(0x%08x, 0x%08x, 0x%02x)\n", reg, data, flags);
+
+	return i2c_write(state->i2c, adr, mm, len + 4);
+}
+
+static int write32(struct drxk_state *state, u32 reg, u32 data)
+{
+	return write32_flags(state, reg, data, 0);
+}
+
+static int write_block(struct drxk_state *state, u32 Address,
+		      const int BlockSize, const u8 pBlock[])
+{
+	int status = 0, BlkSize = BlockSize;
+	u8 Flags = 0;
+
+	if (state->single_master)
+		Flags |= 0xC0;
+
+	while (BlkSize > 0) {
+		int Chunk = BlkSize > state->m_ChunkSize ?
+		    state->m_ChunkSize : BlkSize;
+		u8 *AdrBuf = &state->Chunk[0];
+		u32 AdrLength = 0;
+
+		if (DRXDAP_FASI_LONG_FORMAT(Address) || (Flags != 0)) {
+			AdrBuf[0] = (((Address << 1) & 0xFF) | 0x01);
+			AdrBuf[1] = ((Address >> 16) & 0xFF);
+			AdrBuf[2] = ((Address >> 24) & 0xFF);
+			AdrBuf[3] = ((Address >> 7) & 0xFF);
+			AdrBuf[2] |= Flags;
+			AdrLength = 4;
+			if (Chunk == state->m_ChunkSize)
+				Chunk -= 2;
+		} else {
+			AdrBuf[0] = ((Address << 1) & 0xFF);
+			AdrBuf[1] = (((Address >> 16) & 0x0F) |
+				     ((Address >> 18) & 0xF0));
+			AdrLength = 2;
+		}
+		memcpy(&state->Chunk[AdrLength], pBlock, Chunk);
+		dprintk(2, "(0x%08x, 0x%02x)\n", Address, Flags);
+		if (debug > 1) {
+			int i;
+			if (pBlock)
+				for (i = 0; i < Chunk; i++)
+					printk(KERN_CONT " %02x", pBlock[i]);
+			printk(KERN_CONT "\n");
+		}
+		status = i2c_write(state->i2c, state->demod_address,
+				   &state->Chunk[0], Chunk + AdrLength);
+		if (status < 0) {
+			printk(KERN_ERR "drxk: %s: i2c write error at addr 0x%02x\n",
+			       __func__, Address);
+			break;
+		}
+		pBlock += Chunk;
+		Address += (Chunk >> 1);
+		BlkSize -= Chunk;
+	}
+	return status;
+}
+
+#ifndef DRXK_MAX_RETRIES_POWERUP
+#define DRXK_MAX_RETRIES_POWERUP 20
+#endif
+
+int PowerUpDevice(struct drxk_state *state)
+{
+	int status;
+	u8 data = 0;
+	u16 retryCount = 0;
+
+	dprintk(1, "\n");
+
+	status = i2c_read1(state->i2c, state->demod_address, &data);
+	if (status < 0) {
+		do {
+			data = 0;
+			status = i2c_write(state->i2c, state->demod_address,
+					   &data, 1);
+			msleep(10);
+			retryCount++;
+			if (status < 0)
+				continue;
+			status = i2c_read1(state->i2c, state->demod_address,
+					   &data);
+		} while (status < 0 &&
+			 (retryCount < DRXK_MAX_RETRIES_POWERUP));
+		if (status < 0 && retryCount >= DRXK_MAX_RETRIES_POWERUP)
+			goto error;
+	}
+
+	/* Make sure all clk domains are active */
+	status = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_NONE);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
+	if (status < 0)
+		goto error;
+	/* Enable pll lock tests */
+	status = write16(state, SIO_CC_PLL_LOCK__A, 1);
+	if (status < 0)
+		goto error;
+
+	state->m_currentPowerMode = DRX_POWER_UP;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+
+static int init_state(struct drxk_state *state)
+{
+	/*
+	 * FIXME: most (all?) of the values bellow should be moved into
+	 * struct drxk_config, as they are probably board-specific
+	 */
+	u32 ulVSBIfAgcMode = DRXK_AGC_CTRL_AUTO;
+	u32 ulVSBIfAgcOutputLevel = 0;
+	u32 ulVSBIfAgcMinLevel = 0;
+	u32 ulVSBIfAgcMaxLevel = 0x7FFF;
+	u32 ulVSBIfAgcSpeed = 3;
+
+	u32 ulVSBRfAgcMode = DRXK_AGC_CTRL_AUTO;
+	u32 ulVSBRfAgcOutputLevel = 0;
+	u32 ulVSBRfAgcMinLevel = 0;
+	u32 ulVSBRfAgcMaxLevel = 0x7FFF;
+	u32 ulVSBRfAgcSpeed = 3;
+	u32 ulVSBRfAgcTop = 9500;
+	u32 ulVSBRfAgcCutOffCurrent = 4000;
+
+	u32 ulATVIfAgcMode = DRXK_AGC_CTRL_AUTO;
+	u32 ulATVIfAgcOutputLevel = 0;
+	u32 ulATVIfAgcMinLevel = 0;
+	u32 ulATVIfAgcMaxLevel = 0;
+	u32 ulATVIfAgcSpeed = 3;
+
+	u32 ulATVRfAgcMode = DRXK_AGC_CTRL_OFF;
+	u32 ulATVRfAgcOutputLevel = 0;
+	u32 ulATVRfAgcMinLevel = 0;
+	u32 ulATVRfAgcMaxLevel = 0;
+	u32 ulATVRfAgcTop = 9500;
+	u32 ulATVRfAgcCutOffCurrent = 4000;
+	u32 ulATVRfAgcSpeed = 3;
+
+	u32 ulQual83 = DEFAULT_MER_83;
+	u32 ulQual93 = DEFAULT_MER_93;
+
+	u32 ulMpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;
+	u32 ulDemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;
+
+	/* io_pad_cfg register (8 bit reg.) MSB bit is 1 (default value) */
+	/* io_pad_cfg_mode output mode is drive always */
+	/* io_pad_cfg_drive is set to power 2 (23 mA) */
+	u32 ulGPIOCfg = 0x0113;
+	u32 ulInvertTSClock = 0;
+	u32 ulTSDataStrength = DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH;
+	u32 ulDVBTBitrate = 50000000;
+	u32 ulDVBCBitrate = DRXK_QAM_SYMBOLRATE_MAX * 8;
+
+	u32 ulInsertRSByte = 0;
+
+	u32 ulRfMirror = 1;
+	u32 ulPowerDown = 0;
+
+	dprintk(1, "\n");
+
+	state->m_hasLNA = false;
+	state->m_hasDVBT = false;
+	state->m_hasDVBC = false;
+	state->m_hasATV = false;
+	state->m_hasOOB = false;
+	state->m_hasAudio = false;
+
+	if (!state->m_ChunkSize)
+		state->m_ChunkSize = 124;
+
+	state->m_oscClockFreq = 0;
+	state->m_smartAntInverted = false;
+	state->m_bPDownOpenBridge = false;
+
+	/* real system clock frequency in kHz */
+	state->m_sysClockFreq = 151875;
+	/* Timing div, 250ns/Psys */
+	/* Timing div, = (delay (nano seconds) * sysclk (kHz))/ 1000 */
+	state->m_HICfgTimingDiv = ((state->m_sysClockFreq / 1000) *
+				   HI_I2C_DELAY) / 1000;
+	/* Clipping */
+	if (state->m_HICfgTimingDiv > SIO_HI_RA_RAM_PAR_2_CFG_DIV__M)
+		state->m_HICfgTimingDiv = SIO_HI_RA_RAM_PAR_2_CFG_DIV__M;
+	state->m_HICfgWakeUpKey = (state->demod_address << 1);
+	/* port/bridge/power down ctrl */
+	state->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;
+
+	state->m_bPowerDown = (ulPowerDown != 0);
+
+	state->m_DRXK_A1_PATCH_CODE = false;
+	state->m_DRXK_A1_ROM_CODE = false;
+	state->m_DRXK_A2_ROM_CODE = false;
+	state->m_DRXK_A3_ROM_CODE = false;
+	state->m_DRXK_A2_PATCH_CODE = false;
+	state->m_DRXK_A3_PATCH_CODE = false;
+
+	/* Init AGC and PGA parameters */
+	/* VSB IF */
+	state->m_vsbIfAgcCfg.ctrlMode = (ulVSBIfAgcMode);
+	state->m_vsbIfAgcCfg.outputLevel = (ulVSBIfAgcOutputLevel);
+	state->m_vsbIfAgcCfg.minOutputLevel = (ulVSBIfAgcMinLevel);
+	state->m_vsbIfAgcCfg.maxOutputLevel = (ulVSBIfAgcMaxLevel);
+	state->m_vsbIfAgcCfg.speed = (ulVSBIfAgcSpeed);
+	state->m_vsbPgaCfg = 140;
+
+	/* VSB RF */
+	state->m_vsbRfAgcCfg.ctrlMode = (ulVSBRfAgcMode);
+	state->m_vsbRfAgcCfg.outputLevel = (ulVSBRfAgcOutputLevel);
+	state->m_vsbRfAgcCfg.minOutputLevel = (ulVSBRfAgcMinLevel);
+	state->m_vsbRfAgcCfg.maxOutputLevel = (ulVSBRfAgcMaxLevel);
+	state->m_vsbRfAgcCfg.speed = (ulVSBRfAgcSpeed);
+	state->m_vsbRfAgcCfg.top = (ulVSBRfAgcTop);
+	state->m_vsbRfAgcCfg.cutOffCurrent = (ulVSBRfAgcCutOffCurrent);
+	state->m_vsbPreSawCfg.reference = 0x07;
+	state->m_vsbPreSawCfg.usePreSaw = true;
+
+	state->m_Quality83percent = DEFAULT_MER_83;
+	state->m_Quality93percent = DEFAULT_MER_93;
+	if (ulQual93 <= 500 && ulQual83 < ulQual93) {
+		state->m_Quality83percent = ulQual83;
+		state->m_Quality93percent = ulQual93;
+	}
+
+	/* ATV IF */
+	state->m_atvIfAgcCfg.ctrlMode = (ulATVIfAgcMode);
+	state->m_atvIfAgcCfg.outputLevel = (ulATVIfAgcOutputLevel);
+	state->m_atvIfAgcCfg.minOutputLevel = (ulATVIfAgcMinLevel);
+	state->m_atvIfAgcCfg.maxOutputLevel = (ulATVIfAgcMaxLevel);
+	state->m_atvIfAgcCfg.speed = (ulATVIfAgcSpeed);
+
+	/* ATV RF */
+	state->m_atvRfAgcCfg.ctrlMode = (ulATVRfAgcMode);
+	state->m_atvRfAgcCfg.outputLevel = (ulATVRfAgcOutputLevel);
+	state->m_atvRfAgcCfg.minOutputLevel = (ulATVRfAgcMinLevel);
+	state->m_atvRfAgcCfg.maxOutputLevel = (ulATVRfAgcMaxLevel);
+	state->m_atvRfAgcCfg.speed = (ulATVRfAgcSpeed);
+	state->m_atvRfAgcCfg.top = (ulATVRfAgcTop);
+	state->m_atvRfAgcCfg.cutOffCurrent = (ulATVRfAgcCutOffCurrent);
+	state->m_atvPreSawCfg.reference = 0x04;
+	state->m_atvPreSawCfg.usePreSaw = true;
+
+
+	/* DVBT RF */
+	state->m_dvbtRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;
+	state->m_dvbtRfAgcCfg.outputLevel = 0;
+	state->m_dvbtRfAgcCfg.minOutputLevel = 0;
+	state->m_dvbtRfAgcCfg.maxOutputLevel = 0xFFFF;
+	state->m_dvbtRfAgcCfg.top = 0x2100;
+	state->m_dvbtRfAgcCfg.cutOffCurrent = 4000;
+	state->m_dvbtRfAgcCfg.speed = 1;
+
+
+	/* DVBT IF */
+	state->m_dvbtIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;
+	state->m_dvbtIfAgcCfg.outputLevel = 0;
+	state->m_dvbtIfAgcCfg.minOutputLevel = 0;
+	state->m_dvbtIfAgcCfg.maxOutputLevel = 9000;
+	state->m_dvbtIfAgcCfg.top = 13424;
+	state->m_dvbtIfAgcCfg.cutOffCurrent = 0;
+	state->m_dvbtIfAgcCfg.speed = 3;
+	state->m_dvbtIfAgcCfg.FastClipCtrlDelay = 30;
+	state->m_dvbtIfAgcCfg.IngainTgtMax = 30000;
+	/* state->m_dvbtPgaCfg = 140; */
+
+	state->m_dvbtPreSawCfg.reference = 4;
+	state->m_dvbtPreSawCfg.usePreSaw = false;
+
+	/* QAM RF */
+	state->m_qamRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;
+	state->m_qamRfAgcCfg.outputLevel = 0;
+	state->m_qamRfAgcCfg.minOutputLevel = 6023;
+	state->m_qamRfAgcCfg.maxOutputLevel = 27000;
+	state->m_qamRfAgcCfg.top = 0x2380;
+	state->m_qamRfAgcCfg.cutOffCurrent = 4000;
+	state->m_qamRfAgcCfg.speed = 3;
+
+	/* QAM IF */
+	state->m_qamIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;
+	state->m_qamIfAgcCfg.outputLevel = 0;
+	state->m_qamIfAgcCfg.minOutputLevel = 0;
+	state->m_qamIfAgcCfg.maxOutputLevel = 9000;
+	state->m_qamIfAgcCfg.top = 0x0511;
+	state->m_qamIfAgcCfg.cutOffCurrent = 0;
+	state->m_qamIfAgcCfg.speed = 3;
+	state->m_qamIfAgcCfg.IngainTgtMax = 5119;
+	state->m_qamIfAgcCfg.FastClipCtrlDelay = 50;
+
+	state->m_qamPgaCfg = 140;
+	state->m_qamPreSawCfg.reference = 4;
+	state->m_qamPreSawCfg.usePreSaw = false;
+
+	state->m_OperationMode = OM_NONE;
+	state->m_DrxkState = DRXK_UNINITIALIZED;
+
+	/* MPEG output configuration */
+	state->m_enableMPEGOutput = true;	/* If TRUE; enable MPEG ouput */
+	state->m_insertRSByte = false;	/* If TRUE; insert RS byte */
+	state->m_invertDATA = false;	/* If TRUE; invert DATA signals */
+	state->m_invertERR = false;	/* If TRUE; invert ERR signal */
+	state->m_invertSTR = false;	/* If TRUE; invert STR signals */
+	state->m_invertVAL = false;	/* If TRUE; invert VAL signals */
+	state->m_invertCLK = (ulInvertTSClock != 0);	/* If TRUE; invert CLK signals */
+
+	/* If TRUE; static MPEG clockrate will be used;
+	   otherwise clockrate will adapt to the bitrate of the TS */
+
+	state->m_DVBTBitrate = ulDVBTBitrate;
+	state->m_DVBCBitrate = ulDVBCBitrate;
+
+	state->m_TSDataStrength = (ulTSDataStrength & 0x07);
+
+	/* Maximum bitrate in b/s in case static clockrate is selected */
+	state->m_mpegTsStaticBitrate = 19392658;
+	state->m_disableTEIhandling = false;
+
+	if (ulInsertRSByte)
+		state->m_insertRSByte = true;
+
+	state->m_MpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;
+	if (ulMpegLockTimeOut < 10000)
+		state->m_MpegLockTimeOut = ulMpegLockTimeOut;
+	state->m_DemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;
+	if (ulDemodLockTimeOut < 10000)
+		state->m_DemodLockTimeOut = ulDemodLockTimeOut;
+
+	/* QAM defaults */
+	state->m_Constellation = DRX_CONSTELLATION_AUTO;
+	state->m_qamInterleaveMode = DRXK_QAM_I12_J17;
+	state->m_fecRsPlen = 204 * 8;	/* fecRsPlen  annex A */
+	state->m_fecRsPrescale = 1;
+
+	state->m_sqiSpeed = DRXK_DVBT_SQI_SPEED_MEDIUM;
+	state->m_agcFastClipCtrlDelay = 0;
+
+	state->m_GPIOCfg = (ulGPIOCfg);
+
+	state->m_bPowerDown = false;
+	state->m_currentPowerMode = DRX_POWER_DOWN;
+
+	state->m_rfmirror = (ulRfMirror == 0);
+	state->m_IfAgcPol = false;
+	return 0;
+}
+
+static int DRXX_Open(struct drxk_state *state)
+{
+	int status = 0;
+	u32 jtag = 0;
+	u16 bid = 0;
+	u16 key = 0;
+
+	dprintk(1, "\n");
+	/* stop lock indicator process */
+	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+	if (status < 0)
+		goto error;
+	/* Check device id */
+	status = read16(state, SIO_TOP_COMM_KEY__A, &key);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);
+	if (status < 0)
+		goto error;
+	status = read32(state, SIO_TOP_JTAGID_LO__A, &jtag);
+	if (status < 0)
+		goto error;
+	status = read16(state, SIO_PDR_UIO_IN_HI__A, &bid);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_TOP_COMM_KEY__A, key);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int GetDeviceCapabilities(struct drxk_state *state)
+{
+	u16 sioPdrOhwCfg = 0;
+	u32 sioTopJtagidLo = 0;
+	int status;
+	const char *spin = "";
+
+	dprintk(1, "\n");
+
+	/* driver 0.9.0 */
+	/* stop lock indicator process */
+	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_TOP_COMM_KEY__A, 0xFABA);
+	if (status < 0)
+		goto error;
+	status = read16(state, SIO_PDR_OHW_CFG__A, &sioPdrOhwCfg);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
+	if (status < 0)
+		goto error;
+
+	switch ((sioPdrOhwCfg & SIO_PDR_OHW_CFG_FREF_SEL__M)) {
+	case 0:
+		/* ignore (bypass ?) */
+		break;
+	case 1:
+		/* 27 MHz */
+		state->m_oscClockFreq = 27000;
+		break;
+	case 2:
+		/* 20.25 MHz */
+		state->m_oscClockFreq = 20250;
+		break;
+	case 3:
+		/* 4 MHz */
+		state->m_oscClockFreq = 20250;
+		break;
+	default:
+		printk(KERN_ERR "drxk: Clock Frequency is unkonwn\n");
+		return -EINVAL;
+	}
+	/*
+		Determine device capabilities
+		Based on pinning v14
+		*/
+	status = read32(state, SIO_TOP_JTAGID_LO__A, &sioTopJtagidLo);
+	if (status < 0)
+		goto error;
+
+printk(KERN_ERR "drxk: status = 0x%08x\n", sioTopJtagidLo);
+
+	/* driver 0.9.0 */
+	switch ((sioTopJtagidLo >> 29) & 0xF) {
+	case 0:
+		state->m_deviceSpin = DRXK_SPIN_A1;
+		spin = "A1";
+		break;
+	case 2:
+		state->m_deviceSpin = DRXK_SPIN_A2;
+		spin = "A2";
+		break;
+	case 3:
+		state->m_deviceSpin = DRXK_SPIN_A3;
+		spin = "A3";
+		break;
+	default:
+		state->m_deviceSpin = DRXK_SPIN_UNKNOWN;
+		status = -EINVAL;
+		printk(KERN_ERR "drxk: Spin %d unknown\n",
+		       (sioTopJtagidLo >> 29) & 0xF);
+		goto error2;
+	}
+	switch ((sioTopJtagidLo >> 12) & 0xFF) {
+	case 0x13:
+		/* typeId = DRX3913K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = false;
+		state->m_hasAudio = false;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = true;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = false;
+		state->m_hasGPIO1 = false;
+		state->m_hasIRQN = false;
+		break;
+	case 0x15:
+		/* typeId = DRX3915K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = false;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = false;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x16:
+		/* typeId = DRX3916K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = false;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = false;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x18:
+		/* typeId = DRX3918K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = true;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = false;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x21:
+		/* typeId = DRX3921K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = true;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = true;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x23:
+		/* typeId = DRX3923K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = true;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = true;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x25:
+		/* typeId = DRX3925K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = true;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = true;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	case 0x26:
+		/* typeId = DRX3926K_TYPE_ID */
+		state->m_hasLNA = false;
+		state->m_hasOOB = false;
+		state->m_hasATV = true;
+		state->m_hasAudio = false;
+		state->m_hasDVBT = true;
+		state->m_hasDVBC = true;
+		state->m_hasSAWSW = true;
+		state->m_hasGPIO2 = true;
+		state->m_hasGPIO1 = true;
+		state->m_hasIRQN = false;
+		break;
+	default:
+		printk(KERN_ERR "drxk: DeviceID 0x%02x not supported\n",
+			((sioTopJtagidLo >> 12) & 0xFF));
+		status = -EINVAL;
+		goto error2;
+	}
+
+	printk(KERN_INFO
+	       "drxk: detected a drx-39%02xk, spin %s, xtal %d.%03d MHz\n",
+	       ((sioTopJtagidLo >> 12) & 0xFF), spin,
+	       state->m_oscClockFreq / 1000,
+	       state->m_oscClockFreq % 1000);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+error2:
+	return status;
+}
+
+static int HI_Command(struct drxk_state *state, u16 cmd, u16 *pResult)
+{
+	int status;
+	bool powerdown_cmd;
+
+	dprintk(1, "\n");
+
+	/* Write command */
+	status = write16(state, SIO_HI_RA_RAM_CMD__A, cmd);
+	if (status < 0)
+		goto error;
+	if (cmd == SIO_HI_RA_RAM_CMD_RESET)
+		msleep(1);
+
+	powerdown_cmd =
+	    (bool) ((cmd == SIO_HI_RA_RAM_CMD_CONFIG) &&
+		    ((state->m_HICfgCtrl) &
+		     SIO_HI_RA_RAM_PAR_5_CFG_SLEEP__M) ==
+		    SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ);
+	if (powerdown_cmd == false) {
+		/* Wait until command rdy */
+		u32 retryCount = 0;
+		u16 waitCmd;
+
+		do {
+			msleep(1);
+			retryCount += 1;
+			status = read16(state, SIO_HI_RA_RAM_CMD__A,
+					  &waitCmd);
+		} while ((status < 0) && (retryCount < DRXK_MAX_RETRIES)
+			 && (waitCmd != 0));
+		if (status < 0)
+			goto error;
+		status = read16(state, SIO_HI_RA_RAM_RES__A, pResult);
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int HI_CfgCommand(struct drxk_state *state)
+{
+	int status;
+
+	dprintk(1, "\n");
+
+	mutex_lock(&state->mutex);
+
+	status = write16(state, SIO_HI_RA_RAM_PAR_6__A, state->m_HICfgTimeout);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_HI_RA_RAM_PAR_5__A, state->m_HICfgCtrl);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_HI_RA_RAM_PAR_4__A, state->m_HICfgWakeUpKey);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_HI_RA_RAM_PAR_3__A, state->m_HICfgBridgeDelay);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_HI_RA_RAM_PAR_2__A, state->m_HICfgTimingDiv);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);
+	if (status < 0)
+		goto error;
+	status = HI_Command(state, SIO_HI_RA_RAM_CMD_CONFIG, 0);
+	if (status < 0)
+		goto error;
+
+	state->m_HICfgCtrl &= ~SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
+error:
+	mutex_unlock(&state->mutex);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int InitHI(struct drxk_state *state)
+{
+	dprintk(1, "\n");
+
+	state->m_HICfgWakeUpKey = (state->demod_address << 1);
+	state->m_HICfgTimeout = 0x96FF;
+	/* port/bridge/power down ctrl */
+	state->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;
+
+	return HI_CfgCommand(state);
+}
+
+static int MPEGTSConfigurePins(struct drxk_state *state, bool mpegEnable)
+{
+	int status = -1;
+	u16 sioPdrMclkCfg = 0;
+	u16 sioPdrMdxCfg = 0;
+	u16 err_cfg = 0;
+
+	dprintk(1, ": mpeg %s, %s mode\n",
+		mpegEnable ? "enable" : "disable",
+		state->m_enableParallel ? "parallel" : "serial");
+
+	/* stop lock indicator process */
+	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+	if (status < 0)
+		goto error;
+
+	/*  MPEG TS pad configuration */
+	status = write16(state, SIO_TOP_COMM_KEY__A, 0xFABA);
+	if (status < 0)
+		goto error;
+
+	if (mpegEnable == false) {
+		/*  Set MPEG TS pads to inputmode */
+		status = write16(state, SIO_PDR_MSTRT_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MERR_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MCLK_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MVAL_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD0_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);
+		if (status < 0)
+			goto error;
+	} else {
+		/* Enable MPEG output */
+		sioPdrMdxCfg =
+			((state->m_TSDataStrength <<
+			SIO_PDR_MD0_CFG_DRIVE__B) | 0x0003);
+		sioPdrMclkCfg = ((state->m_TSClockkStrength <<
+					SIO_PDR_MCLK_CFG_DRIVE__B) |
+					0x0003);
+
+		status = write16(state, SIO_PDR_MSTRT_CFG__A, sioPdrMdxCfg);
+		if (status < 0)
+			goto error;
+
+		if (state->enable_merr_cfg)
+			err_cfg = sioPdrMdxCfg;
+
+		status = write16(state, SIO_PDR_MERR_CFG__A, err_cfg);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MVAL_CFG__A, err_cfg);
+		if (status < 0)
+			goto error;
+
+		if (state->m_enableParallel == true) {
+			/* paralel -> enable MD1 to MD7 */
+			status = write16(state, SIO_PDR_MD1_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD2_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD3_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD4_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD5_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD6_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD7_CFG__A, sioPdrMdxCfg);
+			if (status < 0)
+				goto error;
+		} else {
+			sioPdrMdxCfg = ((state->m_TSDataStrength <<
+						SIO_PDR_MD0_CFG_DRIVE__B)
+					| 0x0003);
+			/* serial -> disable MD1 to MD7 */
+			status = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+			status = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);
+			if (status < 0)
+				goto error;
+		}
+		status = write16(state, SIO_PDR_MCLK_CFG__A, sioPdrMclkCfg);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_PDR_MD0_CFG__A, sioPdrMdxCfg);
+		if (status < 0)
+			goto error;
+	}
+	/*  Enable MB output over MPEG pads and ctl input */
+	status = write16(state, SIO_PDR_MON_CFG__A, 0x0000);
+	if (status < 0)
+		goto error;
+	/*  Write nomagic word to enable pdr reg write */
+	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int MPEGTSDisable(struct drxk_state *state)
+{
+	dprintk(1, "\n");
+
+	return MPEGTSConfigurePins(state, false);
+}
+
+static int BLChainCmd(struct drxk_state *state,
+		      u16 romOffset, u16 nrOfElements, u32 timeOut)
+{
+	u16 blStatus = 0;
+	int status;
+	unsigned long end;
+
+	dprintk(1, "\n");
+	mutex_lock(&state->mutex);
+	status = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_CHAIN);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_CHAIN_ADDR__A, romOffset);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_CHAIN_LEN__A, nrOfElements);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);
+	if (status < 0)
+		goto error;
+
+	end = jiffies + msecs_to_jiffies(timeOut);
+	do {
+		msleep(1);
+		status = read16(state, SIO_BL_STATUS__A, &blStatus);
+		if (status < 0)
+			goto error;
+	} while ((blStatus == 0x1) &&
+			((time_is_after_jiffies(end))));
+
+	if (blStatus == 0x1) {
+		printk(KERN_ERR "drxk: SIO not ready\n");
+		status = -EINVAL;
+		goto error2;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+error2:
+	mutex_unlock(&state->mutex);
+	return status;
+}
+
+
+static int DownloadMicrocode(struct drxk_state *state,
+			     const u8 pMCImage[], u32 Length)
+{
+	const u8 *pSrc = pMCImage;
+	u16 Flags;
+	u16 Drain;
+	u32 Address;
+	u16 nBlocks;
+	u16 BlockSize;
+	u16 BlockCRC;
+	u32 offset = 0;
+	u32 i;
+	int status = 0;
+
+	dprintk(1, "\n");
+
+	/* down the drain (we don care about MAGIC_WORD) */
+	Drain = (pSrc[0] << 8) | pSrc[1];
+	pSrc += sizeof(u16);
+	offset += sizeof(u16);
+	nBlocks = (pSrc[0] << 8) | pSrc[1];
+	pSrc += sizeof(u16);
+	offset += sizeof(u16);
+
+	for (i = 0; i < nBlocks; i += 1) {
+		Address = (pSrc[0] << 24) | (pSrc[1] << 16) |
+		    (pSrc[2] << 8) | pSrc[3];
+		pSrc += sizeof(u32);
+		offset += sizeof(u32);
+
+		BlockSize = ((pSrc[0] << 8) | pSrc[1]) * sizeof(u16);
+		pSrc += sizeof(u16);
+		offset += sizeof(u16);
+
+		Flags = (pSrc[0] << 8) | pSrc[1];
+		pSrc += sizeof(u16);
+		offset += sizeof(u16);
+
+		BlockCRC = (pSrc[0] << 8) | pSrc[1];
+		pSrc += sizeof(u16);
+		offset += sizeof(u16);
+
+		if (offset + BlockSize > Length) {
+			printk(KERN_ERR "drxk: Firmware is corrupted.\n");
+			return -EINVAL;
+		}
+
+		status = write_block(state, Address, BlockSize, pSrc);
+		if (status < 0) {
+			printk(KERN_ERR "drxk: Error %d while loading firmware\n", status);
+			break;
+		}
+		pSrc += BlockSize;
+		offset += BlockSize;
+	}
+	return status;
+}
+
+static int DVBTEnableOFDMTokenRing(struct drxk_state *state, bool enable)
+{
+	int status;
+	u16 data = 0;
+	u16 desiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_ON;
+	u16 desiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_ENABLED;
+	unsigned long end;
+
+	dprintk(1, "\n");
+
+	if (enable == false) {
+		desiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_OFF;
+		desiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_DOWN;
+	}
+
+	status = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);
+	if (status >= 0 && data == desiredStatus) {
+		/* tokenring already has correct status */
+		return status;
+	}
+	/* Disable/enable dvbt tokenring bridge   */
+	status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, desiredCtrl);
+
+	end = jiffies + msecs_to_jiffies(DRXK_OFDM_TR_SHUTDOWN_TIMEOUT);
+	do {
+		status = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);
+		if ((status >= 0 && data == desiredStatus) || time_is_after_jiffies(end))
+			break;
+		msleep(1);
+	} while (1);
+	if (data != desiredStatus) {
+		printk(KERN_ERR "drxk: SIO not ready\n");
+		return -EINVAL;
+	}
+	return status;
+}
+
+static int MPEGTSStop(struct drxk_state *state)
+{
+	int status = 0;
+	u16 fecOcSncMode = 0;
+	u16 fecOcIprMode = 0;
+
+	dprintk(1, "\n");
+
+	/* Gracefull shutdown (byte boundaries) */
+	status = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);
+	if (status < 0)
+		goto error;
+	fecOcSncMode |= FEC_OC_SNC_MODE_SHUTDOWN__M;
+	status = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);
+	if (status < 0)
+		goto error;
+
+	/* Suppress MCLK during absence of data */
+	status = read16(state, FEC_OC_IPR_MODE__A, &fecOcIprMode);
+	if (status < 0)
+		goto error;
+	fecOcIprMode |= FEC_OC_IPR_MODE_MCLK_DIS_DAT_ABS__M;
+	status = write16(state, FEC_OC_IPR_MODE__A, fecOcIprMode);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int scu_command(struct drxk_state *state,
+		       u16 cmd, u8 parameterLen,
+		       u16 *parameter, u8 resultLen, u16 *result)
+{
+#if (SCU_RAM_PARAM_0__A - SCU_RAM_PARAM_15__A) != 15
+#error DRXK register mapping no longer compatible with this routine!
+#endif
+	u16 curCmd = 0;
+	int status = -EINVAL;
+	unsigned long end;
+	u8 buffer[34];
+	int cnt = 0, ii;
+	const char *p;
+	char errname[30];
+
+	dprintk(1, "\n");
+
+	if ((cmd == 0) || ((parameterLen > 0) && (parameter == NULL)) ||
+	    ((resultLen > 0) && (result == NULL))) {
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+		return status;
+	}
+
+	mutex_lock(&state->mutex);
+
+	/* assume that the command register is ready
+		since it is checked afterwards */
+	for (ii = parameterLen - 1; ii >= 0; ii -= 1) {
+		buffer[cnt++] = (parameter[ii] & 0xFF);
+		buffer[cnt++] = ((parameter[ii] >> 8) & 0xFF);
+	}
+	buffer[cnt++] = (cmd & 0xFF);
+	buffer[cnt++] = ((cmd >> 8) & 0xFF);
+
+	write_block(state, SCU_RAM_PARAM_0__A -
+			(parameterLen - 1), cnt, buffer);
+	/* Wait until SCU has processed command */
+	end = jiffies + msecs_to_jiffies(DRXK_MAX_WAITTIME);
+	do {
+		msleep(1);
+		status = read16(state, SCU_RAM_COMMAND__A, &curCmd);
+		if (status < 0)
+			goto error;
+	} while (!(curCmd == DRX_SCU_READY) && (time_is_after_jiffies(end)));
+	if (curCmd != DRX_SCU_READY) {
+		printk(KERN_ERR "drxk: SCU not ready\n");
+		status = -EIO;
+		goto error2;
+	}
+	/* read results */
+	if ((resultLen > 0) && (result != NULL)) {
+		s16 err;
+		int ii;
+
+		for (ii = resultLen - 1; ii >= 0; ii -= 1) {
+			status = read16(state, SCU_RAM_PARAM_0__A - ii, &result[ii]);
+			if (status < 0)
+				goto error;
+		}
+
+		/* Check if an error was reported by SCU */
+		err = (s16)result[0];
+		if (err >= 0)
+			goto error;
+
+		/* check for the known error codes */
+		switch (err) {
+		case SCU_RESULT_UNKCMD:
+			p = "SCU_RESULT_UNKCMD";
+			break;
+		case SCU_RESULT_UNKSTD:
+			p = "SCU_RESULT_UNKSTD";
+			break;
+		case SCU_RESULT_SIZE:
+			p = "SCU_RESULT_SIZE";
+			break;
+		case SCU_RESULT_INVPAR:
+			p = "SCU_RESULT_INVPAR";
+			break;
+		default: /* Other negative values are errors */
+			sprintf(errname, "ERROR: %d\n", err);
+			p = errname;
+		}
+		printk(KERN_ERR "drxk: %s while sending cmd 0x%04x with params:", p, cmd);
+		print_hex_dump_bytes("drxk: ", DUMP_PREFIX_NONE, buffer, cnt);
+		status = -EINVAL;
+		goto error2;
+	}
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+error2:
+	mutex_unlock(&state->mutex);
+	return status;
+}
+
+static int SetIqmAf(struct drxk_state *state, bool active)
+{
+	u16 data = 0;
+	int status;
+
+	dprintk(1, "\n");
+
+	/* Configure IQM */
+	status = read16(state, IQM_AF_STDBY__A, &data);
+	if (status < 0)
+		goto error;
+
+	if (!active) {
+		data |= (IQM_AF_STDBY_STDBY_ADC_STANDBY
+				| IQM_AF_STDBY_STDBY_AMP_STANDBY
+				| IQM_AF_STDBY_STDBY_PD_STANDBY
+				| IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY
+				| IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY);
+	} else {
+		data &= ((~IQM_AF_STDBY_STDBY_ADC_STANDBY)
+				& (~IQM_AF_STDBY_STDBY_AMP_STANDBY)
+				& (~IQM_AF_STDBY_STDBY_PD_STANDBY)
+				& (~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY)
+				& (~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY)
+			);
+	}
+	status = write16(state, IQM_AF_STDBY__A, data);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int CtrlPowerMode(struct drxk_state *state, enum DRXPowerMode *mode)
+{
+	int status = 0;
+	u16 sioCcPwdMode = 0;
+
+	dprintk(1, "\n");
+
+	/* Check arguments */
+	if (mode == NULL)
+		return -EINVAL;
+
+	switch (*mode) {
+	case DRX_POWER_UP:
+		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_NONE;
+		break;
+	case DRXK_POWER_DOWN_OFDM:
+		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OFDM;
+		break;
+	case DRXK_POWER_DOWN_CORE:
+		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_CLOCK;
+		break;
+	case DRXK_POWER_DOWN_PLL:
+		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_PLL;
+		break;
+	case DRX_POWER_DOWN:
+		sioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OSC;
+		break;
+	default:
+		/* Unknow sleep mode */
+		return -EINVAL;
+	}
+
+	/* If already in requested power mode, do nothing */
+	if (state->m_currentPowerMode == *mode)
+		return 0;
+
+	/* For next steps make sure to start from DRX_POWER_UP mode */
+	if (state->m_currentPowerMode != DRX_POWER_UP) {
+		status = PowerUpDevice(state);
+		if (status < 0)
+			goto error;
+		status = DVBTEnableOFDMTokenRing(state, true);
+		if (status < 0)
+			goto error;
+	}
+
+	if (*mode == DRX_POWER_UP) {
+		/* Restore analog & pin configuartion */
+	} else {
+		/* Power down to requested mode */
+		/* Backup some register settings */
+		/* Set pins with possible pull-ups connected
+		   to them in input mode */
+		/* Analog power down */
+		/* ADC power down */
+		/* Power down device */
+		/* stop all comm_exec */
+		/* Stop and power down previous standard */
+		switch (state->m_OperationMode) {
+		case OM_DVBT:
+			status = MPEGTSStop(state);
+			if (status < 0)
+				goto error;
+			status = PowerDownDVBT(state, false);
+			if (status < 0)
+				goto error;
+			break;
+		case OM_QAM_ITU_A:
+		case OM_QAM_ITU_C:
+			status = MPEGTSStop(state);
+			if (status < 0)
+				goto error;
+			status = PowerDownQAM(state);
+			if (status < 0)
+				goto error;
+			break;
+		default:
+			break;
+		}
+		status = DVBTEnableOFDMTokenRing(state, false);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_CC_PWD_MODE__A, sioCcPwdMode);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
+		if (status < 0)
+			goto error;
+
+		if (*mode != DRXK_POWER_DOWN_OFDM) {
+			state->m_HICfgCtrl |=
+				SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
+			status = HI_CfgCommand(state);
+			if (status < 0)
+				goto error;
+		}
+	}
+	state->m_currentPowerMode = *mode;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int PowerDownDVBT(struct drxk_state *state, bool setPowerMode)
+{
+	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
+	u16 cmdResult = 0;
+	u16 data = 0;
+	int status;
+
+	dprintk(1, "\n");
+
+	status = read16(state, SCU_COMM_EXEC__A, &data);
+	if (status < 0)
+		goto error;
+	if (data == SCU_COMM_EXEC_ACTIVE) {
+		/* Send OFDM stop command */
+		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
+		if (status < 0)
+			goto error;
+		/* Send OFDM reset command */
+		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
+		if (status < 0)
+			goto error;
+	}
+
+	/* Reset datapath for OFDM, processors first */
+	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
+	if (status < 0)
+		goto error;
+
+	/* powerdown AFE                   */
+	status = SetIqmAf(state, false);
+	if (status < 0)
+		goto error;
+
+	/* powerdown to OFDM mode          */
+	if (setPowerMode) {
+		status = CtrlPowerMode(state, &powerMode);
+		if (status < 0)
+			goto error;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SetOperationMode(struct drxk_state *state,
+			    enum OperationMode oMode)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+	/*
+	   Stop and power down previous standard
+	   TODO investigate total power down instead of partial
+	   power down depending on "previous" standard.
+	 */
+
+	/* disable HW lock indicator */
+	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+	if (status < 0)
+		goto error;
+
+	/* Device is already at the required mode */
+	if (state->m_OperationMode == oMode)
+		return 0;
+
+	switch (state->m_OperationMode) {
+		/* OM_NONE was added for start up */
+	case OM_NONE:
+		break;
+	case OM_DVBT:
+		status = MPEGTSStop(state);
+		if (status < 0)
+			goto error;
+		status = PowerDownDVBT(state, true);
+		if (status < 0)
+			goto error;
+		state->m_OperationMode = OM_NONE;
+		break;
+	case OM_QAM_ITU_A:	/* fallthrough */
+	case OM_QAM_ITU_C:
+		status = MPEGTSStop(state);
+		if (status < 0)
+			goto error;
+		status = PowerDownQAM(state);
+		if (status < 0)
+			goto error;
+		state->m_OperationMode = OM_NONE;
+		break;
+	case OM_QAM_ITU_B:
+	default:
+		status = -EINVAL;
+		goto error;
+	}
+
+	/*
+		Power up new standard
+		*/
+	switch (oMode) {
+	case OM_DVBT:
+		dprintk(1, ": DVB-T\n");
+		state->m_OperationMode = oMode;
+		status = SetDVBTStandard(state, oMode);
+		if (status < 0)
+			goto error;
+		break;
+	case OM_QAM_ITU_A:	/* fallthrough */
+	case OM_QAM_ITU_C:
+		dprintk(1, ": DVB-C Annex %c\n",
+			(state->m_OperationMode == OM_QAM_ITU_A) ? 'A' : 'C');
+		state->m_OperationMode = oMode;
+		status = SetQAMStandard(state, oMode);
+		if (status < 0)
+			goto error;
+		break;
+	case OM_QAM_ITU_B:
+	default:
+		status = -EINVAL;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int Start(struct drxk_state *state, s32 offsetFreq,
+		 s32 IntermediateFrequency)
+{
+	int status = -EINVAL;
+
+	u16 IFreqkHz;
+	s32 OffsetkHz = offsetFreq / 1000;
+
+	dprintk(1, "\n");
+	if (state->m_DrxkState != DRXK_STOPPED &&
+		state->m_DrxkState != DRXK_DTV_STARTED)
+		goto error;
+
+	state->m_bMirrorFreqSpect = (state->props.inversion == INVERSION_ON);
+
+	if (IntermediateFrequency < 0) {
+		state->m_bMirrorFreqSpect = !state->m_bMirrorFreqSpect;
+		IntermediateFrequency = -IntermediateFrequency;
+	}
+
+	switch (state->m_OperationMode) {
+	case OM_QAM_ITU_A:
+	case OM_QAM_ITU_C:
+		IFreqkHz = (IntermediateFrequency / 1000);
+		status = SetQAM(state, IFreqkHz, OffsetkHz);
+		if (status < 0)
+			goto error;
+		state->m_DrxkState = DRXK_DTV_STARTED;
+		break;
+	case OM_DVBT:
+		IFreqkHz = (IntermediateFrequency / 1000);
+		status = MPEGTSStop(state);
+		if (status < 0)
+			goto error;
+		status = SetDVBT(state, IFreqkHz, OffsetkHz);
+		if (status < 0)
+			goto error;
+		status = DVBTStart(state);
+		if (status < 0)
+			goto error;
+		state->m_DrxkState = DRXK_DTV_STARTED;
+		break;
+	default:
+		break;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int ShutDown(struct drxk_state *state)
+{
+	dprintk(1, "\n");
+
+	MPEGTSStop(state);
+	return 0;
+}
+
+static int GetLockStatus(struct drxk_state *state, u32 *pLockStatus,
+			 u32 Time)
+{
+	int status = -EINVAL;
+
+	dprintk(1, "\n");
+
+	if (pLockStatus == NULL)
+		goto error;
+
+	*pLockStatus = NOT_LOCKED;
+
+	/* define the SCU command code */
+	switch (state->m_OperationMode) {
+	case OM_QAM_ITU_A:
+	case OM_QAM_ITU_B:
+	case OM_QAM_ITU_C:
+		status = GetQAMLockStatus(state, pLockStatus);
+		break;
+	case OM_DVBT:
+		status = GetDVBTLockStatus(state, pLockStatus);
+		break;
+	default:
+		break;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int MPEGTSStart(struct drxk_state *state)
+{
+	int status;
+
+	u16 fecOcSncMode = 0;
+
+	/* Allow OC to sync again */
+	status = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);
+	if (status < 0)
+		goto error;
+	fecOcSncMode &= ~FEC_OC_SNC_MODE_SHUTDOWN__M;
+	status = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_SNC_UNLOCK__A, 1);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int MPEGTSDtoInit(struct drxk_state *state)
+{
+	int status;
+
+	dprintk(1, "\n");
+
+	/* Rate integration settings */
+	status = write16(state, FEC_OC_RCN_CTL_STEP_LO__A, 0x0000);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_RCN_CTL_STEP_HI__A, 0x000C);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_RCN_GAIN__A, 0x000A);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_AVR_PARM_A__A, 0x0008);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_AVR_PARM_B__A, 0x0006);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_TMD_HI_MARGIN__A, 0x0680);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_TMD_LO_MARGIN__A, 0x0080);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_TMD_COUNT__A, 0x03F4);
+	if (status < 0)
+		goto error;
+
+	/* Additional configuration */
+	status = write16(state, FEC_OC_OCR_INVERT__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_SNC_LWM__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_SNC_HWM__A, 12);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int MPEGTSDtoSetup(struct drxk_state *state,
+			  enum OperationMode oMode)
+{
+	int status;
+
+	u16 fecOcRegMode = 0;	/* FEC_OC_MODE       register value */
+	u16 fecOcRegIprMode = 0;	/* FEC_OC_IPR_MODE   register value */
+	u16 fecOcDtoMode = 0;	/* FEC_OC_IPR_INVERT register value */
+	u16 fecOcFctMode = 0;	/* FEC_OC_IPR_INVERT register value */
+	u16 fecOcDtoPeriod = 2;	/* FEC_OC_IPR_INVERT register value */
+	u16 fecOcDtoBurstLen = 188;	/* FEC_OC_IPR_INVERT register value */
+	u32 fecOcRcnCtlRate = 0;	/* FEC_OC_IPR_INVERT register value */
+	u16 fecOcTmdMode = 0;
+	u16 fecOcTmdIntUpdRate = 0;
+	u32 maxBitRate = 0;
+	bool staticCLK = false;
+
+	dprintk(1, "\n");
+
+	/* Check insertion of the Reed-Solomon parity bytes */
+	status = read16(state, FEC_OC_MODE__A, &fecOcRegMode);
+	if (status < 0)
+		goto error;
+	status = read16(state, FEC_OC_IPR_MODE__A, &fecOcRegIprMode);
+	if (status < 0)
+		goto error;
+	fecOcRegMode &= (~FEC_OC_MODE_PARITY__M);
+	fecOcRegIprMode &= (~FEC_OC_IPR_MODE_MVAL_DIS_PAR__M);
+	if (state->m_insertRSByte == true) {
+		/* enable parity symbol forward */
+		fecOcRegMode |= FEC_OC_MODE_PARITY__M;
+		/* MVAL disable during parity bytes */
+		fecOcRegIprMode |= FEC_OC_IPR_MODE_MVAL_DIS_PAR__M;
+		/* TS burst length to 204 */
+		fecOcDtoBurstLen = 204;
+	}
+
+	/* Check serial or parrallel output */
+	fecOcRegIprMode &= (~(FEC_OC_IPR_MODE_SERIAL__M));
+	if (state->m_enableParallel == false) {
+		/* MPEG data output is serial -> set ipr_mode[0] */
+		fecOcRegIprMode |= FEC_OC_IPR_MODE_SERIAL__M;
+	}
+
+	switch (oMode) {
+	case OM_DVBT:
+		maxBitRate = state->m_DVBTBitrate;
+		fecOcTmdMode = 3;
+		fecOcRcnCtlRate = 0xC00000;
+		staticCLK = state->m_DVBTStaticCLK;
+		break;
+	case OM_QAM_ITU_A:	/* fallthrough */
+	case OM_QAM_ITU_C:
+		fecOcTmdMode = 0x0004;
+		fecOcRcnCtlRate = 0xD2B4EE;	/* good for >63 Mb/s */
+		maxBitRate = state->m_DVBCBitrate;
+		staticCLK = state->m_DVBCStaticCLK;
+		break;
+	default:
+		status = -EINVAL;
+	}		/* switch (standard) */
+	if (status < 0)
+		goto error;
+
+	/* Configure DTO's */
+	if (staticCLK) {
+		u32 bitRate = 0;
+
+		/* Rational DTO for MCLK source (static MCLK rate),
+			Dynamic DTO for optimal grouping
+			(avoid intra-packet gaps),
+			DTO offset enable to sync TS burst with MSTRT */
+		fecOcDtoMode = (FEC_OC_DTO_MODE_DYNAMIC__M |
+				FEC_OC_DTO_MODE_OFFSET_ENABLE__M);
+		fecOcFctMode = (FEC_OC_FCT_MODE_RAT_ENA__M |
+				FEC_OC_FCT_MODE_VIRT_ENA__M);
+
+		/* Check user defined bitrate */
+		bitRate = maxBitRate;
+		if (bitRate > 75900000UL) {	/* max is 75.9 Mb/s */
+			bitRate = 75900000UL;
+		}
+		/* Rational DTO period:
+			dto_period = (Fsys / bitrate) - 2
+
+			Result should be floored,
+			to make sure >= requested bitrate
+			*/
+		fecOcDtoPeriod = (u16) (((state->m_sysClockFreq)
+						* 1000) / bitRate);
+		if (fecOcDtoPeriod <= 2)
+			fecOcDtoPeriod = 0;
+		else
+			fecOcDtoPeriod -= 2;
+		fecOcTmdIntUpdRate = 8;
+	} else {
+		/* (commonAttr->staticCLK == false) => dynamic mode */
+		fecOcDtoMode = FEC_OC_DTO_MODE_DYNAMIC__M;
+		fecOcFctMode = FEC_OC_FCT_MODE__PRE;
+		fecOcTmdIntUpdRate = 5;
+	}
+
+	/* Write appropriate registers with requested configuration */
+	status = write16(state, FEC_OC_DTO_BURST_LEN__A, fecOcDtoBurstLen);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_DTO_PERIOD__A, fecOcDtoPeriod);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_DTO_MODE__A, fecOcDtoMode);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_FCT_MODE__A, fecOcFctMode);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_MODE__A, fecOcRegMode);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_IPR_MODE__A, fecOcRegIprMode);
+	if (status < 0)
+		goto error;
+
+	/* Rate integration settings */
+	status = write32(state, FEC_OC_RCN_CTL_RATE_LO__A, fecOcRcnCtlRate);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_TMD_INT_UPD_RATE__A, fecOcTmdIntUpdRate);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_TMD_MODE__A, fecOcTmdMode);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int MPEGTSConfigurePolarity(struct drxk_state *state)
+{
+	u16 fecOcRegIprInvert = 0;
+
+	/* Data mask for the output data byte */
+	u16 InvertDataMask =
+	    FEC_OC_IPR_INVERT_MD7__M | FEC_OC_IPR_INVERT_MD6__M |
+	    FEC_OC_IPR_INVERT_MD5__M | FEC_OC_IPR_INVERT_MD4__M |
+	    FEC_OC_IPR_INVERT_MD3__M | FEC_OC_IPR_INVERT_MD2__M |
+	    FEC_OC_IPR_INVERT_MD1__M | FEC_OC_IPR_INVERT_MD0__M;
+
+	dprintk(1, "\n");
+
+	/* Control selective inversion of output bits */
+	fecOcRegIprInvert &= (~(InvertDataMask));
+	if (state->m_invertDATA == true)
+		fecOcRegIprInvert |= InvertDataMask;
+	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MERR__M));
+	if (state->m_invertERR == true)
+		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MERR__M;
+	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MSTRT__M));
+	if (state->m_invertSTR == true)
+		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MSTRT__M;
+	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MVAL__M));
+	if (state->m_invertVAL == true)
+		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MVAL__M;
+	fecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MCLK__M));
+	if (state->m_invertCLK == true)
+		fecOcRegIprInvert |= FEC_OC_IPR_INVERT_MCLK__M;
+
+	return write16(state, FEC_OC_IPR_INVERT__A, fecOcRegIprInvert);
+}
+
+#define   SCU_RAM_AGC_KI_INV_RF_POL__M 0x4000
+
+static int SetAgcRf(struct drxk_state *state,
+		    struct SCfgAgc *pAgcCfg, bool isDTV)
+{
+	int status = -EINVAL;
+	u16 data = 0;
+	struct SCfgAgc *pIfAgcSettings;
+
+	dprintk(1, "\n");
+
+	if (pAgcCfg == NULL)
+		goto error;
+
+	switch (pAgcCfg->ctrlMode) {
+	case DRXK_AGC_CTRL_AUTO:
+		/* Enable RF AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+
+		/* Enable SCU RF AGC loop */
+		data &= ~SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
+
+		/* Polarity */
+		if (state->m_RfAgcPol)
+			data |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
+		else
+			data &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Set speed (using complementary reduction value) */
+		status = read16(state, SCU_RAM_AGC_KI_RED__A, &data);
+		if (status < 0)
+			goto error;
+
+		data &= ~SCU_RAM_AGC_KI_RED_RAGC_RED__M;
+		data |= (~(pAgcCfg->speed <<
+				SCU_RAM_AGC_KI_RED_RAGC_RED__B)
+				& SCU_RAM_AGC_KI_RED_RAGC_RED__M);
+
+		status = write16(state, SCU_RAM_AGC_KI_RED__A, data);
+		if (status < 0)
+			goto error;
+
+		if (IsDVBT(state))
+			pIfAgcSettings = &state->m_dvbtIfAgcCfg;
+		else if (IsQAM(state))
+			pIfAgcSettings = &state->m_qamIfAgcCfg;
+		else
+			pIfAgcSettings = &state->m_atvIfAgcCfg;
+		if (pIfAgcSettings == NULL) {
+			status = -EINVAL;
+			goto error;
+		}
+
+		/* Set TOP, only if IF-AGC is in AUTO mode */
+		if (pIfAgcSettings->ctrlMode == DRXK_AGC_CTRL_AUTO)
+			status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->top);
+			if (status < 0)
+				goto error;
+
+		/* Cut-Off current */
+		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, pAgcCfg->cutOffCurrent);
+		if (status < 0)
+			goto error;
+
+		/* Max. output level */
+		status = write16(state, SCU_RAM_AGC_RF_MAX__A, pAgcCfg->maxOutputLevel);
+		if (status < 0)
+			goto error;
+
+		break;
+
+	case DRXK_AGC_CTRL_USER:
+		/* Enable RF AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Disable SCU RF AGC loop */
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+		data |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
+		if (state->m_RfAgcPol)
+			data |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
+		else
+			data &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+
+		/* SCU c.o.c. to 0, enabling full control range */
+		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, 0);
+		if (status < 0)
+			goto error;
+
+		/* Write value to output pin */
+		status = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, pAgcCfg->outputLevel);
+		if (status < 0)
+			goto error;
+		break;
+
+	case DRXK_AGC_CTRL_OFF:
+		/* Disable RF AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data |= IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Disable SCU RF AGC loop */
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+		data |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+		break;
+
+	default:
+		status = -EINVAL;
+
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+#define SCU_RAM_AGC_KI_INV_IF_POL__M 0x2000
+
+static int SetAgcIf(struct drxk_state *state,
+		    struct SCfgAgc *pAgcCfg, bool isDTV)
+{
+	u16 data = 0;
+	int status = 0;
+	struct SCfgAgc *pRfAgcSettings;
+
+	dprintk(1, "\n");
+
+	switch (pAgcCfg->ctrlMode) {
+	case DRXK_AGC_CTRL_AUTO:
+
+		/* Enable IF AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+
+		/* Enable SCU IF AGC loop */
+		data &= ~SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
+
+		/* Polarity */
+		if (state->m_IfAgcPol)
+			data |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
+		else
+			data &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Set speed (using complementary reduction value) */
+		status = read16(state, SCU_RAM_AGC_KI_RED__A, &data);
+		if (status < 0)
+			goto error;
+		data &= ~SCU_RAM_AGC_KI_RED_IAGC_RED__M;
+		data |= (~(pAgcCfg->speed <<
+				SCU_RAM_AGC_KI_RED_IAGC_RED__B)
+				& SCU_RAM_AGC_KI_RED_IAGC_RED__M);
+
+		status = write16(state, SCU_RAM_AGC_KI_RED__A, data);
+		if (status < 0)
+			goto error;
+
+		if (IsQAM(state))
+			pRfAgcSettings = &state->m_qamRfAgcCfg;
+		else
+			pRfAgcSettings = &state->m_atvRfAgcCfg;
+		if (pRfAgcSettings == NULL)
+			return -1;
+		/* Restore TOP */
+		status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pRfAgcSettings->top);
+		if (status < 0)
+			goto error;
+		break;
+
+	case DRXK_AGC_CTRL_USER:
+
+		/* Enable IF AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+
+		/* Disable SCU IF AGC loop */
+		data |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
+
+		/* Polarity */
+		if (state->m_IfAgcPol)
+			data |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
+		else
+			data &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Write value to output pin */
+		status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->outputLevel);
+		if (status < 0)
+			goto error;
+		break;
+
+	case DRXK_AGC_CTRL_OFF:
+
+		/* Disable If AGC DAC */
+		status = read16(state, IQM_AF_STDBY__A, &data);
+		if (status < 0)
+			goto error;
+		data |= IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;
+		status = write16(state, IQM_AF_STDBY__A, data);
+		if (status < 0)
+			goto error;
+
+		/* Disable SCU IF AGC loop */
+		status = read16(state, SCU_RAM_AGC_CONFIG__A, &data);
+		if (status < 0)
+			goto error;
+		data |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;
+		status = write16(state, SCU_RAM_AGC_CONFIG__A, data);
+		if (status < 0)
+			goto error;
+		break;
+	}		/* switch (agcSettingsIf->ctrlMode) */
+
+	/* always set the top to support
+		configurations without if-loop */
+	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, pAgcCfg->top);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int ReadIFAgc(struct drxk_state *state, u32 *pValue)
+{
+	u16 agcDacLvl;
+	int status;
+	u16 Level = 0;
+
+	dprintk(1, "\n");
+
+	status = read16(state, IQM_AF_AGC_IF__A, &agcDacLvl);
+	if (status < 0) {
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+		return status;
+	}
+
+	*pValue = 0;
+
+	if (agcDacLvl > DRXK_AGC_DAC_OFFSET)
+		Level = agcDacLvl - DRXK_AGC_DAC_OFFSET;
+	if (Level < 14000)
+		*pValue = (14000 - Level) / 4;
+	else
+		*pValue = 0;
+
+	return status;
+}
+
+static int GetQAMSignalToNoise(struct drxk_state *state,
+			       s32 *pSignalToNoise)
+{
+	int status = 0;
+	u16 qamSlErrPower = 0;	/* accum. error between
+					raw and sliced symbols */
+	u32 qamSlSigPower = 0;	/* used for MER, depends of
+					QAM modulation */
+	u32 qamSlMer = 0;	/* QAM MER */
+
+	dprintk(1, "\n");
+
+	/* MER calculation */
+
+	/* get the register value needed for MER */
+	status = read16(state, QAM_SL_ERR_POWER__A, &qamSlErrPower);
+	if (status < 0) {
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+		return -EINVAL;
+	}
+
+	switch (state->props.modulation) {
+	case QAM_16:
+		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM16 << 2;
+		break;
+	case QAM_32:
+		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM32 << 2;
+		break;
+	case QAM_64:
+		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM64 << 2;
+		break;
+	case QAM_128:
+		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM128 << 2;
+		break;
+	default:
+	case QAM_256:
+		qamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM256 << 2;
+		break;
+	}
+
+	if (qamSlErrPower > 0) {
+		qamSlMer = Log10Times100(qamSlSigPower) -
+			Log10Times100((u32) qamSlErrPower);
+	}
+	*pSignalToNoise = qamSlMer;
+
+	return status;
+}
+
+static int GetDVBTSignalToNoise(struct drxk_state *state,
+				s32 *pSignalToNoise)
+{
+	int status;
+	u16 regData = 0;
+	u32 EqRegTdSqrErrI = 0;
+	u32 EqRegTdSqrErrQ = 0;
+	u16 EqRegTdSqrErrExp = 0;
+	u16 EqRegTdTpsPwrOfs = 0;
+	u16 EqRegTdReqSmbCnt = 0;
+	u32 tpsCnt = 0;
+	u32 SqrErrIQ = 0;
+	u32 a = 0;
+	u32 b = 0;
+	u32 c = 0;
+	u32 iMER = 0;
+	u16 transmissionParams = 0;
+
+	dprintk(1, "\n");
+
+	status = read16(state, OFDM_EQ_TOP_TD_TPS_PWR_OFS__A, &EqRegTdTpsPwrOfs);
+	if (status < 0)
+		goto error;
+	status = read16(state, OFDM_EQ_TOP_TD_REQ_SMB_CNT__A, &EqRegTdReqSmbCnt);
+	if (status < 0)
+		goto error;
+	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_EXP__A, &EqRegTdSqrErrExp);
+	if (status < 0)
+		goto error;
+	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_I__A, &regData);
+	if (status < 0)
+		goto error;
+	/* Extend SQR_ERR_I operational range */
+	EqRegTdSqrErrI = (u32) regData;
+	if ((EqRegTdSqrErrExp > 11) &&
+		(EqRegTdSqrErrI < 0x00000FFFUL)) {
+		EqRegTdSqrErrI += 0x00010000UL;
+	}
+	status = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_Q__A, &regData);
+	if (status < 0)
+		goto error;
+	/* Extend SQR_ERR_Q operational range */
+	EqRegTdSqrErrQ = (u32) regData;
+	if ((EqRegTdSqrErrExp > 11) &&
+		(EqRegTdSqrErrQ < 0x00000FFFUL))
+		EqRegTdSqrErrQ += 0x00010000UL;
+
+	status = read16(state, OFDM_SC_RA_RAM_OP_PARAM__A, &transmissionParams);
+	if (status < 0)
+		goto error;
+
+	/* Check input data for MER */
+
+	/* MER calculation (in 0.1 dB) without math.h */
+	if ((EqRegTdTpsPwrOfs == 0) || (EqRegTdReqSmbCnt == 0))
+		iMER = 0;
+	else if ((EqRegTdSqrErrI + EqRegTdSqrErrQ) == 0) {
+		/* No error at all, this must be the HW reset value
+			* Apparently no first measurement yet
+			* Set MER to 0.0 */
+		iMER = 0;
+	} else {
+		SqrErrIQ = (EqRegTdSqrErrI + EqRegTdSqrErrQ) <<
+			EqRegTdSqrErrExp;
+		if ((transmissionParams &
+			OFDM_SC_RA_RAM_OP_PARAM_MODE__M)
+			== OFDM_SC_RA_RAM_OP_PARAM_MODE_2K)
+			tpsCnt = 17;
+		else
+			tpsCnt = 68;
+
+		/* IMER = 100 * log10 (x)
+			where x = (EqRegTdTpsPwrOfs^2 *
+			EqRegTdReqSmbCnt * tpsCnt)/SqrErrIQ
+
+			=> IMER = a + b -c
+			where a = 100 * log10 (EqRegTdTpsPwrOfs^2)
+			b = 100 * log10 (EqRegTdReqSmbCnt * tpsCnt)
+			c = 100 * log10 (SqrErrIQ)
+			*/
+
+		/* log(x) x = 9bits * 9bits->18 bits  */
+		a = Log10Times100(EqRegTdTpsPwrOfs *
+					EqRegTdTpsPwrOfs);
+		/* log(x) x = 16bits * 7bits->23 bits  */
+		b = Log10Times100(EqRegTdReqSmbCnt * tpsCnt);
+		/* log(x) x = (16bits + 16bits) << 15 ->32 bits  */
+		c = Log10Times100(SqrErrIQ);
+
+		iMER = a + b;
+		/* No negative MER, clip to zero */
+		if (iMER > c)
+			iMER -= c;
+		else
+			iMER = 0;
+	}
+	*pSignalToNoise = iMER;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int GetSignalToNoise(struct drxk_state *state, s32 *pSignalToNoise)
+{
+	dprintk(1, "\n");
+
+	*pSignalToNoise = 0;
+	switch (state->m_OperationMode) {
+	case OM_DVBT:
+		return GetDVBTSignalToNoise(state, pSignalToNoise);
+	case OM_QAM_ITU_A:
+	case OM_QAM_ITU_C:
+		return GetQAMSignalToNoise(state, pSignalToNoise);
+	default:
+		break;
+	}
+	return 0;
+}
+
+#if 0
+static int GetDVBTQuality(struct drxk_state *state, s32 *pQuality)
+{
+	/* SNR Values for quasi errorfree reception rom Nordig 2.2 */
+	int status = 0;
+
+	dprintk(1, "\n");
+
+	static s32 QE_SN[] = {
+		51,		/* QPSK 1/2 */
+		69,		/* QPSK 2/3 */
+		79,		/* QPSK 3/4 */
+		89,		/* QPSK 5/6 */
+		97,		/* QPSK 7/8 */
+		108,		/* 16-QAM 1/2 */
+		131,		/* 16-QAM 2/3 */
+		146,		/* 16-QAM 3/4 */
+		156,		/* 16-QAM 5/6 */
+		160,		/* 16-QAM 7/8 */
+		165,		/* 64-QAM 1/2 */
+		187,		/* 64-QAM 2/3 */
+		202,		/* 64-QAM 3/4 */
+		216,		/* 64-QAM 5/6 */
+		225,		/* 64-QAM 7/8 */
+	};
+
+	*pQuality = 0;
+
+	do {
+		s32 SignalToNoise = 0;
+		u16 Constellation = 0;
+		u16 CodeRate = 0;
+		u32 SignalToNoiseRel;
+		u32 BERQuality;
+
+		status = GetDVBTSignalToNoise(state, &SignalToNoise);
+		if (status < 0)
+			break;
+		status = read16(state, OFDM_EQ_TOP_TD_TPS_CONST__A, &Constellation);
+		if (status < 0)
+			break;
+		Constellation &= OFDM_EQ_TOP_TD_TPS_CONST__M;
+
+		status = read16(state, OFDM_EQ_TOP_TD_TPS_CODE_HP__A, &CodeRate);
+		if (status < 0)
+			break;
+		CodeRate &= OFDM_EQ_TOP_TD_TPS_CODE_HP__M;
+
+		if (Constellation > OFDM_EQ_TOP_TD_TPS_CONST_64QAM ||
+		    CodeRate > OFDM_EQ_TOP_TD_TPS_CODE_LP_7_8)
+			break;
+		SignalToNoiseRel = SignalToNoise -
+		    QE_SN[Constellation * 5 + CodeRate];
+		BERQuality = 100;
+
+		if (SignalToNoiseRel < -70)
+			*pQuality = 0;
+		else if (SignalToNoiseRel < 30)
+			*pQuality = ((SignalToNoiseRel + 70) *
+				     BERQuality) / 100;
+		else
+			*pQuality = BERQuality;
+	} while (0);
+	return 0;
+};
+
+static int GetDVBCQuality(struct drxk_state *state, s32 *pQuality)
+{
+	int status = 0;
+	*pQuality = 0;
+
+	dprintk(1, "\n");
+
+	do {
+		u32 SignalToNoise = 0;
+		u32 BERQuality = 100;
+		u32 SignalToNoiseRel = 0;
+
+		status = GetQAMSignalToNoise(state, &SignalToNoise);
+		if (status < 0)
+			break;
+
+		switch (state->props.modulation) {
+		case QAM_16:
+			SignalToNoiseRel = SignalToNoise - 200;
+			break;
+		case QAM_32:
+			SignalToNoiseRel = SignalToNoise - 230;
+			break;	/* Not in NorDig */
+		case QAM_64:
+			SignalToNoiseRel = SignalToNoise - 260;
+			break;
+		case QAM_128:
+			SignalToNoiseRel = SignalToNoise - 290;
+			break;
+		default:
+		case QAM_256:
+			SignalToNoiseRel = SignalToNoise - 320;
+			break;
+		}
+
+		if (SignalToNoiseRel < -70)
+			*pQuality = 0;
+		else if (SignalToNoiseRel < 30)
+			*pQuality = ((SignalToNoiseRel + 70) *
+				     BERQuality) / 100;
+		else
+			*pQuality = BERQuality;
+	} while (0);
+
+	return status;
+}
+
+static int GetQuality(struct drxk_state *state, s32 *pQuality)
+{
+	dprintk(1, "\n");
+
+	switch (state->m_OperationMode) {
+	case OM_DVBT:
+		return GetDVBTQuality(state, pQuality);
+	case OM_QAM_ITU_A:
+		return GetDVBCQuality(state, pQuality);
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+/* Free data ram in SIO HI */
+#define SIO_HI_RA_RAM_USR_BEGIN__A 0x420040
+#define SIO_HI_RA_RAM_USR_END__A   0x420060
+
+#define DRXK_HI_ATOMIC_BUF_START (SIO_HI_RA_RAM_USR_BEGIN__A)
+#define DRXK_HI_ATOMIC_BUF_END   (SIO_HI_RA_RAM_USR_BEGIN__A + 7)
+#define DRXK_HI_ATOMIC_READ      SIO_HI_RA_RAM_PAR_3_ACP_RW_READ
+#define DRXK_HI_ATOMIC_WRITE     SIO_HI_RA_RAM_PAR_3_ACP_RW_WRITE
+
+#define DRXDAP_FASI_ADDR2BLOCK(addr)  (((addr) >> 22) & 0x3F)
+#define DRXDAP_FASI_ADDR2BANK(addr)   (((addr) >> 16) & 0x3F)
+#define DRXDAP_FASI_ADDR2OFFSET(addr) ((addr) & 0x7FFF)
+
+static int ConfigureI2CBridge(struct drxk_state *state, bool bEnableBridge)
+{
+	int status = -EINVAL;
+
+	dprintk(1, "\n");
+
+	if (state->m_DrxkState == DRXK_UNINITIALIZED)
+		goto error;
+	if (state->m_DrxkState == DRXK_POWERED_DOWN)
+		goto error;
+
+	if (state->no_i2c_bridge)
+		return 0;
+
+	status = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);
+	if (status < 0)
+		goto error;
+	if (bEnableBridge) {
+		status = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_CLOSED);
+		if (status < 0)
+			goto error;
+	} else {
+		status = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_OPEN);
+		if (status < 0)
+			goto error;
+	}
+
+	status = HI_Command(state, SIO_HI_RA_RAM_CMD_BRDCTRL, 0);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SetPreSaw(struct drxk_state *state,
+		     struct SCfgPreSaw *pPreSawCfg)
+{
+	int status = -EINVAL;
+
+	dprintk(1, "\n");
+
+	if ((pPreSawCfg == NULL)
+	    || (pPreSawCfg->reference > IQM_AF_PDREF__M))
+		goto error;
+
+	status = write16(state, IQM_AF_PDREF__A, pPreSawCfg->reference);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int BLDirectCmd(struct drxk_state *state, u32 targetAddr,
+		       u16 romOffset, u16 nrOfElements, u32 timeOut)
+{
+	u16 blStatus = 0;
+	u16 offset = (u16) ((targetAddr >> 0) & 0x00FFFF);
+	u16 blockbank = (u16) ((targetAddr >> 16) & 0x000FFF);
+	int status;
+	unsigned long end;
+
+	dprintk(1, "\n");
+
+	mutex_lock(&state->mutex);
+	status = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_DIRECT);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_TGT_HDR__A, blockbank);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_TGT_ADDR__A, offset);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_SRC_ADDR__A, romOffset);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_SRC_LEN__A, nrOfElements);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);
+	if (status < 0)
+		goto error;
+
+	end = jiffies + msecs_to_jiffies(timeOut);
+	do {
+		status = read16(state, SIO_BL_STATUS__A, &blStatus);
+		if (status < 0)
+			goto error;
+	} while ((blStatus == 0x1) && time_is_after_jiffies(end));
+	if (blStatus == 0x1) {
+		printk(KERN_ERR "drxk: SIO not ready\n");
+		status = -EINVAL;
+		goto error2;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+error2:
+	mutex_unlock(&state->mutex);
+	return status;
+
+}
+
+static int ADCSyncMeasurement(struct drxk_state *state, u16 *count)
+{
+	u16 data = 0;
+	int status;
+
+	dprintk(1, "\n");
+
+	/* Start measurement */
+	status = write16(state, IQM_AF_COMM_EXEC__A, IQM_AF_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_START_LOCK__A, 1);
+	if (status < 0)
+		goto error;
+
+	*count = 0;
+	status = read16(state, IQM_AF_PHASE0__A, &data);
+	if (status < 0)
+		goto error;
+	if (data == 127)
+		*count = *count + 1;
+	status = read16(state, IQM_AF_PHASE1__A, &data);
+	if (status < 0)
+		goto error;
+	if (data == 127)
+		*count = *count + 1;
+	status = read16(state, IQM_AF_PHASE2__A, &data);
+	if (status < 0)
+		goto error;
+	if (data == 127)
+		*count = *count + 1;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int ADCSynchronization(struct drxk_state *state)
+{
+	u16 count = 0;
+	int status;
+
+	dprintk(1, "\n");
+
+	status = ADCSyncMeasurement(state, &count);
+	if (status < 0)
+		goto error;
+
+	if (count == 1) {
+		/* Try sampling on a diffrent edge */
+		u16 clkNeg = 0;
+
+		status = read16(state, IQM_AF_CLKNEG__A, &clkNeg);
+		if (status < 0)
+			goto error;
+		if ((clkNeg | IQM_AF_CLKNEG_CLKNEGDATA__M) ==
+			IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS) {
+			clkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));
+			clkNeg |=
+				IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_NEG;
+		} else {
+			clkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));
+			clkNeg |=
+				IQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS;
+		}
+		status = write16(state, IQM_AF_CLKNEG__A, clkNeg);
+		if (status < 0)
+			goto error;
+		status = ADCSyncMeasurement(state, &count);
+		if (status < 0)
+			goto error;
+	}
+
+	if (count < 2)
+		status = -EINVAL;
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SetFrequencyShifter(struct drxk_state *state,
+			       u16 intermediateFreqkHz,
+			       s32 tunerFreqOffset, bool isDTV)
+{
+	bool selectPosImage = false;
+	u32 rfFreqResidual = tunerFreqOffset;
+	u32 fmFrequencyShift = 0;
+	bool tunerMirror = !state->m_bMirrorFreqSpect;
+	u32 adcFreq;
+	bool adcFlip;
+	int status;
+	u32 ifFreqActual;
+	u32 samplingFrequency = (u32) (state->m_sysClockFreq / 3);
+	u32 frequencyShift;
+	bool imageToSelect;
+
+	dprintk(1, "\n");
+
+	/*
+	   Program frequency shifter
+	   No need to account for mirroring on RF
+	 */
+	if (isDTV) {
+		if ((state->m_OperationMode == OM_QAM_ITU_A) ||
+		    (state->m_OperationMode == OM_QAM_ITU_C) ||
+		    (state->m_OperationMode == OM_DVBT))
+			selectPosImage = true;
+		else
+			selectPosImage = false;
+	}
+	if (tunerMirror)
+		/* tuner doesn't mirror */
+		ifFreqActual = intermediateFreqkHz +
+		    rfFreqResidual + fmFrequencyShift;
+	else
+		/* tuner mirrors */
+		ifFreqActual = intermediateFreqkHz -
+		    rfFreqResidual - fmFrequencyShift;
+	if (ifFreqActual > samplingFrequency / 2) {
+		/* adc mirrors */
+		adcFreq = samplingFrequency - ifFreqActual;
+		adcFlip = true;
+	} else {
+		/* adc doesn't mirror */
+		adcFreq = ifFreqActual;
+		adcFlip = false;
+	}
+
+	frequencyShift = adcFreq;
+	imageToSelect = state->m_rfmirror ^ tunerMirror ^
+	    adcFlip ^ selectPosImage;
+	state->m_IqmFsRateOfs =
+	    Frac28a((frequencyShift), samplingFrequency);
+
+	if (imageToSelect)
+		state->m_IqmFsRateOfs = ~state->m_IqmFsRateOfs + 1;
+
+	/* Program frequency shifter with tuner offset compensation */
+	/* frequencyShift += tunerFreqOffset; TODO */
+	status = write32(state, IQM_FS_RATE_OFS_LO__A,
+			 state->m_IqmFsRateOfs);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int InitAGC(struct drxk_state *state, bool isDTV)
+{
+	u16 ingainTgt = 0;
+	u16 ingainTgtMin = 0;
+	u16 ingainTgtMax = 0;
+	u16 clpCyclen = 0;
+	u16 clpSumMin = 0;
+	u16 clpDirTo = 0;
+	u16 snsSumMin = 0;
+	u16 snsSumMax = 0;
+	u16 clpSumMax = 0;
+	u16 snsDirTo = 0;
+	u16 kiInnergainMin = 0;
+	u16 ifIaccuHiTgt = 0;
+	u16 ifIaccuHiTgtMin = 0;
+	u16 ifIaccuHiTgtMax = 0;
+	u16 data = 0;
+	u16 fastClpCtrlDelay = 0;
+	u16 clpCtrlMode = 0;
+	int status = 0;
+
+	dprintk(1, "\n");
+
+	/* Common settings */
+	snsSumMax = 1023;
+	ifIaccuHiTgtMin = 2047;
+	clpCyclen = 500;
+	clpSumMax = 1023;
+
+	/* AGCInit() not available for DVBT; init done in microcode */
+	if (!IsQAM(state)) {
+		printk(KERN_ERR "drxk: %s: mode %d is not DVB-C\n", __func__, state->m_OperationMode);
+		return -EINVAL;
+	}
+
+	/* FIXME: Analog TV AGC require different settings */
+
+	/* Standard specific settings */
+	clpSumMin = 8;
+	clpDirTo = (u16) -9;
+	clpCtrlMode = 0;
+	snsSumMin = 8;
+	snsDirTo = (u16) -9;
+	kiInnergainMin = (u16) -1030;
+	ifIaccuHiTgtMax = 0x2380;
+	ifIaccuHiTgt = 0x2380;
+	ingainTgtMin = 0x0511;
+	ingainTgt = 0x0511;
+	ingainTgtMax = 5119;
+	fastClpCtrlDelay = state->m_qamIfAgcCfg.FastClipCtrlDelay;
+
+	status = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, fastClpCtrlDelay);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_AGC_CLP_CTRL_MODE__A, clpCtrlMode);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_INGAIN_TGT__A, ingainTgt);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, ingainTgtMin);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, ingainTgtMax);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MIN__A, ifIaccuHiTgtMin);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, ifIaccuHiTgtMax);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_IF_IACCU_LO__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_RF_IACCU_LO__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_SUM_MAX__A, clpSumMax);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_SUM_MAX__A, snsSumMax);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_AGC_KI_INNERGAIN_MIN__A, kiInnergainMin);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT__A, ifIaccuHiTgt);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_CYCLEN__A, clpCyclen);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MAX__A, 1023);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MIN__A, (u16) -1023);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_FAST_SNS_CTRL_DELAY__A, 50);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_AGC_KI_MAXMINGAIN_TH__A, 20);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_SUM_MIN__A, clpSumMin);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_SUM_MIN__A, snsSumMin);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_DIR_TO__A, clpDirTo);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_DIR_TO__A, snsDirTo);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_KI_MIN__A, 0x0117);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_KI_MAX__A, 0x0657);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_SUM__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_CYCCNT__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_DIR_WD__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_CLP_DIR_STP__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_SUM__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_CYCCNT__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_DIR_WD__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_DIR_STP__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_SNS_CYCLEN__A, 500);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_KI_CYCLEN__A, 500);
+	if (status < 0)
+		goto error;
+
+	/* Initialize inner-loop KI gain factors */
+	status = read16(state, SCU_RAM_AGC_KI__A, &data);
+	if (status < 0)
+		goto error;
+
+	data = 0x0657;
+	data &= ~SCU_RAM_AGC_KI_RF__M;
+	data |= (DRXK_KI_RAGC_QAM << SCU_RAM_AGC_KI_RF__B);
+	data &= ~SCU_RAM_AGC_KI_IF__M;
+	data |= (DRXK_KI_IAGC_QAM << SCU_RAM_AGC_KI_IF__B);
+
+	status = write16(state, SCU_RAM_AGC_KI__A, data);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int DVBTQAMGetAccPktErr(struct drxk_state *state, u16 *packetErr)
+{
+	int status;
+
+	dprintk(1, "\n");
+	if (packetErr == NULL)
+		status = write16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, 0);
+	else
+		status = read16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, packetErr);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int DVBTScCommand(struct drxk_state *state,
+			 u16 cmd, u16 subcmd,
+			 u16 param0, u16 param1, u16 param2,
+			 u16 param3, u16 param4)
+{
+	u16 curCmd = 0;
+	u16 errCode = 0;
+	u16 retryCnt = 0;
+	u16 scExec = 0;
+	int status;
+
+	dprintk(1, "\n");
+	status = read16(state, OFDM_SC_COMM_EXEC__A, &scExec);
+	if (scExec != 1) {
+		/* SC is not running */
+		status = -EINVAL;
+	}
+	if (status < 0)
+		goto error;
+
+	/* Wait until sc is ready to receive command */
+	retryCnt = 0;
+	do {
+		msleep(1);
+		status = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);
+		retryCnt++;
+	} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));
+	if (retryCnt >= DRXK_MAX_RETRIES && (status < 0))
+		goto error;
+
+	/* Write sub-command */
+	switch (cmd) {
+		/* All commands using sub-cmd */
+	case OFDM_SC_RA_RAM_CMD_PROC_START:
+	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
+	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
+		status = write16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, subcmd);
+		if (status < 0)
+			goto error;
+		break;
+	default:
+		/* Do nothing */
+		break;
+	}
+
+	/* Write needed parameters and the command */
+	switch (cmd) {
+		/* All commands using 5 parameters */
+		/* All commands using 4 parameters */
+		/* All commands using 3 parameters */
+		/* All commands using 2 parameters */
+	case OFDM_SC_RA_RAM_CMD_PROC_START:
+	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
+	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
+		status = write16(state, OFDM_SC_RA_RAM_PARAM1__A, param1);
+		/* All commands using 1 parameters */
+	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
+	case OFDM_SC_RA_RAM_CMD_USER_IO:
+		status = write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);
+		/* All commands using 0 parameters */
+	case OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:
+	case OFDM_SC_RA_RAM_CMD_NULL:
+		/* Write command */
+		status = write16(state, OFDM_SC_RA_RAM_CMD__A, cmd);
+		break;
+	default:
+		/* Unknown command */
+		status = -EINVAL;
+	}
+	if (status < 0)
+		goto error;
+
+	/* Wait until sc is ready processing command */
+	retryCnt = 0;
+	do {
+		msleep(1);
+		status = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);
+		retryCnt++;
+	} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));
+	if (retryCnt >= DRXK_MAX_RETRIES && (status < 0))
+		goto error;
+
+	/* Check for illegal cmd */
+	status = read16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, &errCode);
+	if (errCode == 0xFFFF) {
+		/* illegal command */
+		status = -EINVAL;
+	}
+	if (status < 0)
+		goto error;
+
+	/* Retreive results parameters from SC */
+	switch (cmd) {
+		/* All commands yielding 5 results */
+		/* All commands yielding 4 results */
+		/* All commands yielding 3 results */
+		/* All commands yielding 2 results */
+		/* All commands yielding 1 result */
+	case OFDM_SC_RA_RAM_CMD_USER_IO:
+	case OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:
+		status = read16(state, OFDM_SC_RA_RAM_PARAM0__A, &(param0));
+		/* All commands yielding 0 results */
+	case OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:
+	case OFDM_SC_RA_RAM_CMD_SET_TIMER:
+	case OFDM_SC_RA_RAM_CMD_PROC_START:
+	case OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:
+	case OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:
+	case OFDM_SC_RA_RAM_CMD_NULL:
+		break;
+	default:
+		/* Unknown command */
+		status = -EINVAL;
+		break;
+	}			/* switch (cmd->cmd) */
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int PowerUpDVBT(struct drxk_state *state)
+{
+	enum DRXPowerMode powerMode = DRX_POWER_UP;
+	int status;
+
+	dprintk(1, "\n");
+	status = CtrlPowerMode(state, &powerMode);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int DVBTCtrlSetIncEnable(struct drxk_state *state, bool *enabled)
+{
+	int status;
+
+	dprintk(1, "\n");
+	if (*enabled == true)
+		status = write16(state, IQM_CF_BYPASSDET__A, 0);
+	else
+		status = write16(state, IQM_CF_BYPASSDET__A, 1);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+#define DEFAULT_FR_THRES_8K     4000
+static int DVBTCtrlSetFrEnable(struct drxk_state *state, bool *enabled)
+{
+
+	int status;
+
+	dprintk(1, "\n");
+	if (*enabled == true) {
+		/* write mask to 1 */
+		status = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A,
+				   DEFAULT_FR_THRES_8K);
+	} else {
+		/* write mask to 0 */
+		status = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A, 0);
+	}
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int DVBTCtrlSetEchoThreshold(struct drxk_state *state,
+				    struct DRXKCfgDvbtEchoThres_t *echoThres)
+{
+	u16 data = 0;
+	int status;
+
+	dprintk(1, "\n");
+	status = read16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, &data);
+	if (status < 0)
+		goto error;
+
+	switch (echoThres->fftMode) {
+	case DRX_FFTMODE_2K:
+		data &= ~OFDM_SC_RA_RAM_ECHO_THRES_2K__M;
+		data |= ((echoThres->threshold <<
+			OFDM_SC_RA_RAM_ECHO_THRES_2K__B)
+			& (OFDM_SC_RA_RAM_ECHO_THRES_2K__M));
+		break;
+	case DRX_FFTMODE_8K:
+		data &= ~OFDM_SC_RA_RAM_ECHO_THRES_8K__M;
+		data |= ((echoThres->threshold <<
+			OFDM_SC_RA_RAM_ECHO_THRES_8K__B)
+			& (OFDM_SC_RA_RAM_ECHO_THRES_8K__M));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	status = write16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, data);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int DVBTCtrlSetSqiSpeed(struct drxk_state *state,
+			       enum DRXKCfgDvbtSqiSpeed *speed)
+{
+	int status = -EINVAL;
+
+	dprintk(1, "\n");
+
+	switch (*speed) {
+	case DRXK_DVBT_SQI_SPEED_FAST:
+	case DRXK_DVBT_SQI_SPEED_MEDIUM:
+	case DRXK_DVBT_SQI_SPEED_SLOW:
+		break;
+	default:
+		goto error;
+	}
+	status = write16(state, SCU_RAM_FEC_PRE_RS_BER_FILTER_SH__A,
+			   (u16) *speed);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief Activate DVBT specific presets
+* \param demod instance of demodulator.
+* \return DRXStatus_t.
+*
+* Called in DVBTSetStandard
+*
+*/
+static int DVBTActivatePresets(struct drxk_state *state)
+{
+	int status;
+	bool setincenable = false;
+	bool setfrenable = true;
+
+	struct DRXKCfgDvbtEchoThres_t echoThres2k = { 0, DRX_FFTMODE_2K };
+	struct DRXKCfgDvbtEchoThres_t echoThres8k = { 0, DRX_FFTMODE_8K };
+
+	dprintk(1, "\n");
+	status = DVBTCtrlSetIncEnable(state, &setincenable);
+	if (status < 0)
+		goto error;
+	status = DVBTCtrlSetFrEnable(state, &setfrenable);
+	if (status < 0)
+		goto error;
+	status = DVBTCtrlSetEchoThreshold(state, &echoThres2k);
+	if (status < 0)
+		goto error;
+	status = DVBTCtrlSetEchoThreshold(state, &echoThres8k);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, state->m_dvbtIfAgcCfg.IngainTgtMax);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief Initialize channelswitch-independent settings for DVBT.
+* \param demod instance of demodulator.
+* \return DRXStatus_t.
+*
+* For ROM code channel filter taps are loaded from the bootloader. For microcode
+* the DVB-T taps from the drxk_filters.h are used.
+*/
+static int SetDVBTStandard(struct drxk_state *state,
+			   enum OperationMode oMode)
+{
+	u16 cmdResult = 0;
+	u16 data = 0;
+	int status;
+
+	dprintk(1, "\n");
+
+	PowerUpDVBT(state);
+	/* added antenna switch */
+	SwitchAntennaToDVBT(state);
+	/* send OFDM reset command */
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
+	if (status < 0)
+		goto error;
+
+	/* send OFDM setenv command */
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV, 0, NULL, 1, &cmdResult);
+	if (status < 0)
+		goto error;
+
+	/* reset datapath for OFDM, processors first */
+	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
+	if (status < 0)
+		goto error;
+
+	/* IQM setup */
+	/* synchronize on ofdstate->m_festart */
+	status = write16(state, IQM_AF_UPD_SEL__A, 1);
+	if (status < 0)
+		goto error;
+	/* window size for clipping ADC detection */
+	status = write16(state, IQM_AF_CLP_LEN__A, 0);
+	if (status < 0)
+		goto error;
+	/* window size for for sense pre-SAW detection */
+	status = write16(state, IQM_AF_SNS_LEN__A, 0);
+	if (status < 0)
+		goto error;
+	/* sense threshold for sense pre-SAW detection */
+	status = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);
+	if (status < 0)
+		goto error;
+	status = SetIqmAf(state, true);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_AF_AGC_RF__A, 0);
+	if (status < 0)
+		goto error;
+
+	/* Impulse noise cruncher setup */
+	status = write16(state, IQM_AF_INC_LCT__A, 0);	/* crunch in IQM_CF */
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_DET_LCT__A, 0);	/* detect in IQM_CF */
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_WND_LEN__A, 3);	/* peak detector window length */
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_RC_STRETCH__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_OUT_ENA__A, 0x4);	/* enable output 2 */
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_DS_ENA__A, 0x4);	/* decimate output 2 */
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_SCALE__A, 1600);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_SCALE_SH__A, 0);
+	if (status < 0)
+		goto error;
+
+	/* virtual clipping threshold for clipping ADC detection */
+	status = write16(state, IQM_AF_CLP_TH__A, 448);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_DATATH__A, 495);	/* crunching threshold */
+	if (status < 0)
+		goto error;
+
+	status = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_DVBT, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_CF_PKDTH__A, 2);	/* peak detector threshold */
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_POW_MEAS_LEN__A, 2);
+	if (status < 0)
+		goto error;
+	/* enable power measurement interrupt */
+	status = write16(state, IQM_CF_COMM_INT_MSK__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);
+	if (status < 0)
+		goto error;
+
+	/* IQM will not be reset from here, sync ADC and update/init AGC */
+	status = ADCSynchronization(state);
+	if (status < 0)
+		goto error;
+	status = SetPreSaw(state, &state->m_dvbtPreSawCfg);
+	if (status < 0)
+		goto error;
+
+	/* Halt SCU to enable safe non-atomic accesses */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
+	if (status < 0)
+		goto error;
+
+	status = SetAgcRf(state, &state->m_dvbtRfAgcCfg, true);
+	if (status < 0)
+		goto error;
+	status = SetAgcIf(state, &state->m_dvbtIfAgcCfg, true);
+	if (status < 0)
+		goto error;
+
+	/* Set Noise Estimation notch width and enable DC fix */
+	status = read16(state, OFDM_SC_RA_RAM_CONFIG__A, &data);
+	if (status < 0)
+		goto error;
+	data |= OFDM_SC_RA_RAM_CONFIG_NE_FIX_ENABLE__M;
+	status = write16(state, OFDM_SC_RA_RAM_CONFIG__A, data);
+	if (status < 0)
+		goto error;
+
+	/* Activate SCU to enable SCU commands */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+
+	if (!state->m_DRXK_A3_ROM_CODE) {
+		/* AGCInit() is not done for DVBT, so set agcFastClipCtrlDelay  */
+		status = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, state->m_dvbtIfAgcCfg.FastClipCtrlDelay);
+		if (status < 0)
+			goto error;
+	}
+
+	/* OFDM_SC setup */
+#ifdef COMPILE_FOR_NONRT
+	status = write16(state, OFDM_SC_RA_RAM_BE_OPT_DELAY__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, OFDM_SC_RA_RAM_BE_OPT_INIT_DELAY__A, 2);
+	if (status < 0)
+		goto error;
+#endif
+
+	/* FEC setup */
+	status = write16(state, FEC_DI_INPUT_CTL__A, 1);	/* OFDM input */
+	if (status < 0)
+		goto error;
+
+
+#ifdef COMPILE_FOR_NONRT
+	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x400);
+	if (status < 0)
+		goto error;
+#else
+	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x1000);
+	if (status < 0)
+		goto error;
+#endif
+	status = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, 0x0001);
+	if (status < 0)
+		goto error;
+
+	/* Setup MPEG bus */
+	status = MPEGTSDtoSetup(state, OM_DVBT);
+	if (status < 0)
+		goto error;
+	/* Set DVBT Presets */
+	status = DVBTActivatePresets(state);
+	if (status < 0)
+		goto error;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+/**
+* \brief Start dvbt demodulating for channel.
+* \param demod instance of demodulator.
+* \return DRXStatus_t.
+*/
+static int DVBTStart(struct drxk_state *state)
+{
+	u16 param1;
+	int status;
+	/* DRXKOfdmScCmd_t scCmd; */
+
+	dprintk(1, "\n");
+	/* Start correct processes to get in lock */
+	/* DRXK: OFDM_SC_RA_RAM_PROC_LOCKTRACK is no longer in mapfile! */
+	param1 = OFDM_SC_RA_RAM_LOCKTRACK_MIN;
+	status = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_PROC_START, 0, OFDM_SC_RA_RAM_SW_EVENT_RUN_NMASK__M, param1, 0, 0, 0);
+	if (status < 0)
+		goto error;
+	/* Start FEC OC */
+	status = MPEGTSStart(state);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+
+/*============================================================================*/
+
+/**
+* \brief Set up dvbt demodulator for channel.
+* \param demod instance of demodulator.
+* \return DRXStatus_t.
+* // original DVBTSetChannel()
+*/
+static int SetDVBT(struct drxk_state *state, u16 IntermediateFreqkHz,
+		   s32 tunerFreqOffset)
+{
+	u16 cmdResult = 0;
+	u16 transmissionParams = 0;
+	u16 operationMode = 0;
+	u32 iqmRcRateOfs = 0;
+	u32 bandwidth = 0;
+	u16 param1;
+	int status;
+
+	dprintk(1, "IF =%d, TFO = %d\n", IntermediateFreqkHz, tunerFreqOffset);
+
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
+	if (status < 0)
+		goto error;
+
+	/* Halt SCU to enable safe non-atomic accesses */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
+	if (status < 0)
+		goto error;
+
+	/* Stop processors */
+	status = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+
+	/* Mandatory fix, always stop CP, required to set spl offset back to
+		hardware default (is set to 0 by ucode during pilot detection */
+	status = write16(state, OFDM_CP_COMM_EXEC__A, OFDM_CP_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+
+	/*== Write channel settings to device =====================================*/
+
+	/* mode */
+	switch (state->props.transmission_mode) {
+	case TRANSMISSION_MODE_AUTO:
+	default:
+		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_MODE__M;
+		/* fall through , try first guess DRX_FFTMODE_8K */
+	case TRANSMISSION_MODE_8K:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_8K;
+		break;
+	case TRANSMISSION_MODE_2K:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_2K;
+		break;
+	}
+
+	/* guard */
+	switch (state->props.guard_interval) {
+	default:
+	case GUARD_INTERVAL_AUTO:
+		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_GUARD__M;
+		/* fall through , try first guess DRX_GUARD_1DIV4 */
+	case GUARD_INTERVAL_1_4:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_4;
+		break;
+	case GUARD_INTERVAL_1_32:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_32;
+		break;
+	case GUARD_INTERVAL_1_16:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_16;
+		break;
+	case GUARD_INTERVAL_1_8:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_8;
+		break;
+	}
+
+	/* hierarchy */
+	switch (state->props.hierarchy) {
+	case HIERARCHY_AUTO:
+	case HIERARCHY_NONE:
+	default:
+		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_HIER__M;
+		/* fall through , try first guess SC_RA_RAM_OP_PARAM_HIER_NO */
+		/* transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_NO; */
+		/* break; */
+	case HIERARCHY_1:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A1;
+		break;
+	case HIERARCHY_2:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A2;
+		break;
+	case HIERARCHY_4:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A4;
+		break;
+	}
+
+
+	/* modulation */
+	switch (state->props.modulation) {
+	case QAM_AUTO:
+	default:
+		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_CONST__M;
+		/* fall through , try first guess DRX_CONSTELLATION_QAM64 */
+	case QAM_64:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM64;
+		break;
+	case QPSK:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QPSK;
+		break;
+	case QAM_16:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM16;
+		break;
+	}
+#if 0
+	/* No hierachical channels support in BDA */
+	/* Priority (only for hierarchical channels) */
+	switch (channel->priority) {
+	case DRX_PRIORITY_LOW:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_LO;
+		WR16(devAddr, OFDM_EC_SB_PRIOR__A,
+			OFDM_EC_SB_PRIOR_LO);
+		break;
+	case DRX_PRIORITY_HIGH:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;
+		WR16(devAddr, OFDM_EC_SB_PRIOR__A,
+			OFDM_EC_SB_PRIOR_HI));
+		break;
+	case DRX_PRIORITY_UNKNOWN:	/* fall through */
+	default:
+		status = -EINVAL;
+		goto error;
+	}
+#else
+	/* Set Priorty high */
+	transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;
+	status = write16(state, OFDM_EC_SB_PRIOR__A, OFDM_EC_SB_PRIOR_HI);
+	if (status < 0)
+		goto error;
+#endif
+
+	/* coderate */
+	switch (state->props.code_rate_HP) {
+	case FEC_AUTO:
+	default:
+		operationMode |= OFDM_SC_RA_RAM_OP_AUTO_RATE__M;
+		/* fall through , try first guess DRX_CODERATE_2DIV3 */
+	case FEC_2_3:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_2_3;
+		break;
+	case FEC_1_2:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_1_2;
+		break;
+	case FEC_3_4:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_3_4;
+		break;
+	case FEC_5_6:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_5_6;
+		break;
+	case FEC_7_8:
+		transmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_7_8;
+		break;
+	}
+
+	/* SAW filter selection: normaly not necesarry, but if wanted
+		the application can select a SAW filter via the driver by using UIOs */
+	/* First determine real bandwidth (Hz) */
+	/* Also set delay for impulse noise cruncher */
+	/* Also set parameters for EC_OC fix, note EC_OC_REG_TMD_HIL_MAR is changed
+		by SC for fix for some 8K,1/8 guard but is restored by InitEC and ResetEC
+		functions */
+	switch (state->props.bandwidth_hz) {
+	case 0:
+		state->props.bandwidth_hz = 8000000;
+		/* fall though */
+	case 8000000:
+		bandwidth = DRXK_BANDWIDTH_8MHZ_IN_HZ;
+		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3052);
+		if (status < 0)
+			goto error;
+		/* cochannel protection for PAL 8 MHz */
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 7);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 7);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 7);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
+		if (status < 0)
+			goto error;
+		break;
+	case 7000000:
+		bandwidth = DRXK_BANDWIDTH_7MHZ_IN_HZ;
+		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3491);
+		if (status < 0)
+			goto error;
+		/* cochannel protection for PAL 7 MHz */
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 8);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 8);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 4);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
+		if (status < 0)
+			goto error;
+		break;
+	case 6000000:
+		bandwidth = DRXK_BANDWIDTH_6MHZ_IN_HZ;
+		status = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 4073);
+		if (status < 0)
+			goto error;
+		/* cochannel protection for NTSC 6 MHz */
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 19);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 19);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 14);
+		if (status < 0)
+			goto error;
+		status = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);
+		if (status < 0)
+			goto error;
+		break;
+	default:
+		status = -EINVAL;
+		goto error;
+	}
+
+	if (iqmRcRateOfs == 0) {
+		/* Now compute IQM_RC_RATE_OFS
+			(((SysFreq/BandWidth)/2)/2) -1) * 2^23)
+			=>
+			((SysFreq / BandWidth) * (2^21)) - (2^23)
+			*/
+		/* (SysFreq / BandWidth) * (2^28)  */
+		/* assert (MAX(sysClk)/MIN(bandwidth) < 16)
+			=> assert(MAX(sysClk) < 16*MIN(bandwidth))
+			=> assert(109714272 > 48000000) = true so Frac 28 can be used  */
+		iqmRcRateOfs = Frac28a((u32)
+					((state->m_sysClockFreq *
+						1000) / 3), bandwidth);
+		/* (SysFreq / BandWidth) * (2^21), rounding before truncating  */
+		if ((iqmRcRateOfs & 0x7fL) >= 0x40)
+			iqmRcRateOfs += 0x80L;
+		iqmRcRateOfs = iqmRcRateOfs >> 7;
+		/* ((SysFreq / BandWidth) * (2^21)) - (2^23)  */
+		iqmRcRateOfs = iqmRcRateOfs - (1 << 23);
+	}
+
+	iqmRcRateOfs &=
+		((((u32) IQM_RC_RATE_OFS_HI__M) <<
+		IQM_RC_RATE_OFS_LO__W) | IQM_RC_RATE_OFS_LO__M);
+	status = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRateOfs);
+	if (status < 0)
+		goto error;
+
+	/* Bandwidth setting done */
+
+#if 0
+	status = DVBTSetFrequencyShift(demod, channel, tunerOffset);
+	if (status < 0)
+		goto error;
+#endif
+	status = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);
+	if (status < 0)
+		goto error;
+
+	/*== Start SC, write channel settings to SC ===============================*/
+
+	/* Activate SCU to enable SCU commands */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+
+	/* Enable SC after setting all other parameters */
+	status = write16(state, OFDM_SC_COMM_STATE__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, OFDM_SC_COMM_EXEC__A, 1);
+	if (status < 0)
+		goto error;
+
+
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);
+	if (status < 0)
+		goto error;
+
+	/* Write SC parameter registers, set all AUTO flags in operation mode */
+	param1 = (OFDM_SC_RA_RAM_OP_AUTO_MODE__M |
+			OFDM_SC_RA_RAM_OP_AUTO_GUARD__M |
+			OFDM_SC_RA_RAM_OP_AUTO_CONST__M |
+			OFDM_SC_RA_RAM_OP_AUTO_HIER__M |
+			OFDM_SC_RA_RAM_OP_AUTO_RATE__M);
+	status = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM,
+				0, transmissionParams, param1, 0, 0, 0);
+	if (status < 0)
+		goto error;
+
+	if (!state->m_DRXK_A3_ROM_CODE)
+		status = DVBTCtrlSetSqiSpeed(state, &state->m_sqiSpeed);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+
+/*============================================================================*/
+
+/**
+* \brief Retreive lock status .
+* \param demod    Pointer to demodulator instance.
+* \param lockStat Pointer to lock status structure.
+* \return DRXStatus_t.
+*
+*/
+static int GetDVBTLockStatus(struct drxk_state *state, u32 *pLockStatus)
+{
+	int status;
+	const u16 mpeg_lock_mask = (OFDM_SC_RA_RAM_LOCK_MPEG__M |
+				    OFDM_SC_RA_RAM_LOCK_FEC__M);
+	const u16 fec_lock_mask = (OFDM_SC_RA_RAM_LOCK_FEC__M);
+	const u16 demod_lock_mask = OFDM_SC_RA_RAM_LOCK_DEMOD__M;
+
+	u16 ScRaRamLock = 0;
+	u16 ScCommExec = 0;
+
+	dprintk(1, "\n");
+
+	*pLockStatus = NOT_LOCKED;
+	/* driver 0.9.0 */
+	/* Check if SC is running */
+	status = read16(state, OFDM_SC_COMM_EXEC__A, &ScCommExec);
+	if (status < 0)
+		goto end;
+	if (ScCommExec == OFDM_SC_COMM_EXEC_STOP)
+		goto end;
+
+	status = read16(state, OFDM_SC_RA_RAM_LOCK__A, &ScRaRamLock);
+	if (status < 0)
+		goto end;
+
+	if ((ScRaRamLock & mpeg_lock_mask) == mpeg_lock_mask)
+		*pLockStatus = MPEG_LOCK;
+	else if ((ScRaRamLock & fec_lock_mask) == fec_lock_mask)
+		*pLockStatus = FEC_LOCK;
+	else if ((ScRaRamLock & demod_lock_mask) == demod_lock_mask)
+		*pLockStatus = DEMOD_LOCK;
+	else if (ScRaRamLock & OFDM_SC_RA_RAM_LOCK_NODVBT__M)
+		*pLockStatus = NEVER_LOCK;
+end:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int PowerUpQAM(struct drxk_state *state)
+{
+	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
+	int status;
+
+	dprintk(1, "\n");
+	status = CtrlPowerMode(state, &powerMode);
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+
+/** Power Down QAM */
+static int PowerDownQAM(struct drxk_state *state)
+{
+	u16 data = 0;
+	u16 cmdResult;
+	int status = 0;
+
+	dprintk(1, "\n");
+	status = read16(state, SCU_COMM_EXEC__A, &data);
+	if (status < 0)
+		goto error;
+	if (data == SCU_COMM_EXEC_ACTIVE) {
+		/*
+			STOP demodulator
+			QAM and HW blocks
+			*/
+		/* stop all comstate->m_exec */
+		status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);
+		if (status < 0)
+			goto error;
+		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);
+		if (status < 0)
+			goto error;
+	}
+	/* powerdown AFE                   */
+	status = SetIqmAf(state, false);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief Setup of the QAM Measurement intervals for signal quality
+* \param demod instance of demod.
+* \param modulation current modulation.
+* \return DRXStatus_t.
+*
+*  NOTE:
+*  Take into account that for certain settings the errorcounters can overflow.
+*  The implementation does not check this.
+*
+*/
+static int SetQAMMeasurement(struct drxk_state *state,
+			     enum EDrxkConstellation modulation,
+			     u32 symbolRate)
+{
+	u32 fecBitsDesired = 0;	/* BER accounting period */
+	u32 fecRsPeriodTotal = 0;	/* Total period */
+	u16 fecRsPrescale = 0;	/* ReedSolomon Measurement Prescale */
+	u16 fecRsPeriod = 0;	/* Value for corresponding I2C register */
+	int status = 0;
+
+	dprintk(1, "\n");
+
+	fecRsPrescale = 1;
+	/* fecBitsDesired = symbolRate [kHz] *
+		FrameLenght [ms] *
+		(modulation + 1) *
+		SyncLoss (== 1) *
+		ViterbiLoss (==1)
+		*/
+	switch (modulation) {
+	case DRX_CONSTELLATION_QAM16:
+		fecBitsDesired = 4 * symbolRate;
+		break;
+	case DRX_CONSTELLATION_QAM32:
+		fecBitsDesired = 5 * symbolRate;
+		break;
+	case DRX_CONSTELLATION_QAM64:
+		fecBitsDesired = 6 * symbolRate;
+		break;
+	case DRX_CONSTELLATION_QAM128:
+		fecBitsDesired = 7 * symbolRate;
+		break;
+	case DRX_CONSTELLATION_QAM256:
+		fecBitsDesired = 8 * symbolRate;
+		break;
+	default:
+		status = -EINVAL;
+	}
+	if (status < 0)
+		goto error;
+
+	fecBitsDesired /= 1000;	/* symbolRate [Hz] -> symbolRate [kHz]  */
+	fecBitsDesired *= 500;	/* meas. period [ms] */
+
+	/* Annex A/C: bits/RsPeriod = 204 * 8 = 1632 */
+	/* fecRsPeriodTotal = fecBitsDesired / 1632 */
+	fecRsPeriodTotal = (fecBitsDesired / 1632UL) + 1;	/* roughly ceil */
+
+	/* fecRsPeriodTotal =  fecRsPrescale * fecRsPeriod  */
+	fecRsPrescale = 1 + (u16) (fecRsPeriodTotal >> 16);
+	if (fecRsPrescale == 0) {
+		/* Divide by zero (though impossible) */
+		status = -EINVAL;
+		if (status < 0)
+			goto error;
+	}
+	fecRsPeriod =
+		((u16) fecRsPeriodTotal +
+		(fecRsPrescale >> 1)) / fecRsPrescale;
+
+	/* write corresponding registers */
+	status = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, fecRsPeriod);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, fecRsPrescale);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_OC_SNC_FAIL_PERIOD__A, fecRsPeriod);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SetQAM16(struct drxk_state *state)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+	/* QAM Equalizer Setup */
+	/* Equalizer */
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13517);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 13517);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 13517);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13517);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13517);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 13517);
+	if (status < 0)
+		goto error;
+	/* Decision Feedback Equalizer */
+	status = write16(state, QAM_DQ_QUAL_FUN0__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN1__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN2__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN3__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN4__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
+	if (status < 0)
+		goto error;
+
+	/* QAM Slicer Settings */
+	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM16);
+	if (status < 0)
+		goto error;
+
+	/* QAM Loop Controller Coeficients */
+	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 32);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM State Machine (FSM) Thresholds */
+
+	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 140);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 95);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 120);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 230);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 105);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 24);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM FSM Tracking Parameters */
+
+	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 220);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 25);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -65);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -127);
+	if (status < 0)
+		goto error;
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief QAM32 specific setup
+* \param demod instance of demod.
+* \return DRXStatus_t.
+*/
+static int SetQAM32(struct drxk_state *state)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+
+	/* QAM Equalizer Setup */
+	/* Equalizer */
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6707);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6707);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6707);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6707);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6707);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 6707);
+	if (status < 0)
+		goto error;
+
+	/* Decision Feedback Equalizer */
+	status = write16(state, QAM_DQ_QUAL_FUN0__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN1__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN2__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN3__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN4__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_SY_SYNC_HWM__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_AWM__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
+	if (status < 0)
+		goto error;
+
+	/* QAM Slicer Settings */
+
+	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM32);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM Loop Controller Coeficients */
+
+	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM State Machine (FSM) Thresholds */
+
+	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 90);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 170);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 10);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM FSM Tracking Parameters */
+
+	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 140);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) -8);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) -16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -26);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -56);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -86);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief QAM64 specific setup
+* \param demod instance of demod.
+* \return DRXStatus_t.
+*/
+static int SetQAM64(struct drxk_state *state)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+	/* QAM Equalizer Setup */
+	/* Equalizer */
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13336);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12618);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 11988);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13809);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13809);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15609);
+	if (status < 0)
+		goto error;
+
+	/* Decision Feedback Equalizer */
+	status = write16(state, QAM_DQ_QUAL_FUN0__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN1__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN2__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN3__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN4__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
+	if (status < 0)
+		goto error;
+
+	/* QAM Slicer Settings */
+	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM64);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM Loop Controller Coeficients */
+
+	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 30);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 100);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 30);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM State Machine (FSM) Thresholds */
+
+	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 100);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 110);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 200);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 95);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 15);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM FSM Tracking Parameters */
+
+	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 141);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 7);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -45);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -80);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief QAM128 specific setup
+* \param demod: instance of demod.
+* \return DRXStatus_t.
+*/
+static int SetQAM128(struct drxk_state *state)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+	/* QAM Equalizer Setup */
+	/* Equalizer */
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6564);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6598);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6394);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6409);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6656);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 7238);
+	if (status < 0)
+		goto error;
+
+	/* Decision Feedback Equalizer */
+	status = write16(state, QAM_DQ_QUAL_FUN0__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN1__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN2__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN3__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN4__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_SY_SYNC_HWM__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_AWM__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM Slicer Settings */
+
+	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM128);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM Loop Controller Coeficients */
+
+	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 120);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 60);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 64);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM State Machine (FSM) Thresholds */
+
+	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 140);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 5);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);
+	if (status < 0)
+		goto error;
+
+	/* QAM FSM Tracking Parameters */
+
+	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 65);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -1);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -23);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief QAM256 specific setup
+* \param demod: instance of demod.
+* \return DRXStatus_t.
+*/
+static int SetQAM256(struct drxk_state *state)
+{
+	int status = 0;
+
+	dprintk(1, "\n");
+	/* QAM Equalizer Setup */
+	/* Equalizer */
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 11502);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12084);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 12543);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 12931);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13629);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15385);
+	if (status < 0)
+		goto error;
+
+	/* Decision Feedback Equalizer */
+	status = write16(state, QAM_DQ_QUAL_FUN0__A, 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN1__A, 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN2__A, 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN3__A, 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN4__A, 6);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_DQ_QUAL_FUN5__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_SY_SYNC_HWM__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_AWM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_SYNC_LWM__A, 3);
+	if (status < 0)
+		goto error;
+
+	/* QAM Slicer Settings */
+
+	status = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM256);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM Loop Controller Coeficients */
+
+	status = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 250);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 125);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM State Machine (FSM) Thresholds */
+
+	status = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_QTH__A, 150);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_MTH__A, 110);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);
+	if (status < 0)
+		goto error;
+
+
+	/* QAM FSM Tracking Parameters */
+
+	status = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 74);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 18);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 13);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) 7);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -8);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+
+/*============================================================================*/
+/**
+* \brief Reset QAM block.
+* \param demod:   instance of demod.
+* \param channel: pointer to channel data.
+* \return DRXStatus_t.
+*/
+static int QAMResetQAM(struct drxk_state *state)
+{
+	int status;
+	u16 cmdResult;
+
+	dprintk(1, "\n");
+	/* Stop QAM comstate->m_exec */
+	status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief Set QAM symbolrate.
+* \param demod:   instance of demod.
+* \param channel: pointer to channel data.
+* \return DRXStatus_t.
+*/
+static int QAMSetSymbolrate(struct drxk_state *state)
+{
+	u32 adcFrequency = 0;
+	u32 symbFreq = 0;
+	u32 iqmRcRate = 0;
+	u16 ratesel = 0;
+	u32 lcSymbRate = 0;
+	int status;
+
+	dprintk(1, "\n");
+	/* Select & calculate correct IQM rate */
+	adcFrequency = (state->m_sysClockFreq * 1000) / 3;
+	ratesel = 0;
+	/* printk(KERN_DEBUG "drxk: SR %d\n", state->props.symbol_rate); */
+	if (state->props.symbol_rate <= 1188750)
+		ratesel = 3;
+	else if (state->props.symbol_rate <= 2377500)
+		ratesel = 2;
+	else if (state->props.symbol_rate <= 4755000)
+		ratesel = 1;
+	status = write16(state, IQM_FD_RATESEL__A, ratesel);
+	if (status < 0)
+		goto error;
+
+	/*
+		IqmRcRate = ((Fadc / (symbolrate * (4<<ratesel))) - 1) * (1<<23)
+		*/
+	symbFreq = state->props.symbol_rate * (1 << ratesel);
+	if (symbFreq == 0) {
+		/* Divide by zero */
+		status = -EINVAL;
+		goto error;
+	}
+	iqmRcRate = (adcFrequency / symbFreq) * (1 << 21) +
+		(Frac28a((adcFrequency % symbFreq), symbFreq) >> 7) -
+		(1 << 23);
+	status = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRate);
+	if (status < 0)
+		goto error;
+	state->m_iqmRcRate = iqmRcRate;
+	/*
+		LcSymbFreq = round (.125 *  symbolrate / adcFreq * (1<<15))
+		*/
+	symbFreq = state->props.symbol_rate;
+	if (adcFrequency == 0) {
+		/* Divide by zero */
+		status = -EINVAL;
+		goto error;
+	}
+	lcSymbRate = (symbFreq / adcFrequency) * (1 << 12) +
+		(Frac28a((symbFreq % adcFrequency), adcFrequency) >>
+		16);
+	if (lcSymbRate > 511)
+		lcSymbRate = 511;
+	status = write16(state, QAM_LC_SYMBOL_FREQ__A, (u16) lcSymbRate);
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+/*============================================================================*/
+
+/**
+* \brief Get QAM lock status.
+* \param demod:   instance of demod.
+* \param channel: pointer to channel data.
+* \return DRXStatus_t.
+*/
+
+static int GetQAMLockStatus(struct drxk_state *state, u32 *pLockStatus)
+{
+	int status;
+	u16 Result[2] = { 0, 0 };
+
+	dprintk(1, "\n");
+	*pLockStatus = NOT_LOCKED;
+	status = scu_command(state,
+			SCU_RAM_COMMAND_STANDARD_QAM |
+			SCU_RAM_COMMAND_CMD_DEMOD_GET_LOCK, 0, NULL, 2,
+			Result);
+	if (status < 0)
+		printk(KERN_ERR "drxk: %s status = %08x\n", __func__, status);
+
+	if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_DEMOD_LOCKED) {
+		/* 0x0000 NOT LOCKED */
+	} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_LOCKED) {
+		/* 0x4000 DEMOD LOCKED */
+		*pLockStatus = DEMOD_LOCK;
+	} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_NEVER_LOCK) {
+		/* 0x8000 DEMOD + FEC LOCKED (system lock) */
+		*pLockStatus = MPEG_LOCK;
+	} else {
+		/* 0xC000 NEVER LOCKED */
+		/* (system will never be able to lock to the signal) */
+		/* TODO: check this, intermediate & standard specific lock states are not
+		   taken into account here */
+		*pLockStatus = NEVER_LOCK;
+	}
+	return status;
+}
+
+#define QAM_MIRROR__M         0x03
+#define QAM_MIRROR_NORMAL     0x00
+#define QAM_MIRRORED          0x01
+#define QAM_MIRROR_AUTO_ON    0x02
+#define QAM_LOCKRANGE__M      0x10
+#define QAM_LOCKRANGE_NORMAL  0x10
+
+static int SetQAM(struct drxk_state *state, u16 IntermediateFreqkHz,
+		  s32 tunerFreqOffset)
+{
+	int status;
+	u16 setParamParameters[4] = { 0, 0, 0, 0 };
+	u16 cmdResult;
+
+	dprintk(1, "\n");
+	/*
+	 * STEP 1: reset demodulator
+	 *	resets FEC DI and FEC RS
+	 *	resets QAM block
+	 *	resets SCU variables
+	 */
+	status = write16(state, FEC_DI_COMM_EXEC__A, FEC_DI_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_RS_COMM_EXEC__A, FEC_RS_COMM_EXEC_STOP);
+	if (status < 0)
+		goto error;
+	status = QAMResetQAM(state);
+	if (status < 0)
+		goto error;
+
+	/*
+	 * STEP 2: configure demodulator
+	 *	-set params; resets IQM,QAM,FEC HW; initializes some
+	 *       SCU variables
+	 */
+	status = QAMSetSymbolrate(state);
+	if (status < 0)
+		goto error;
+
+	/* Set params */
+	switch (state->props.modulation) {
+	case QAM_256:
+		state->m_Constellation = DRX_CONSTELLATION_QAM256;
+		break;
+	case QAM_AUTO:
+	case QAM_64:
+		state->m_Constellation = DRX_CONSTELLATION_QAM64;
+		break;
+	case QAM_16:
+		state->m_Constellation = DRX_CONSTELLATION_QAM16;
+		break;
+	case QAM_32:
+		state->m_Constellation = DRX_CONSTELLATION_QAM32;
+		break;
+	case QAM_128:
+		state->m_Constellation = DRX_CONSTELLATION_QAM128;
+		break;
+	default:
+		status = -EINVAL;
+		break;
+	}
+	if (status < 0)
+		goto error;
+	setParamParameters[0] = state->m_Constellation;	/* modulation     */
+	setParamParameters[1] = DRXK_QAM_I12_J17;	/* interleave mode   */
+	if (state->m_OperationMode == OM_QAM_ITU_C)
+		setParamParameters[2] = QAM_TOP_ANNEX_C;
+	else
+		setParamParameters[2] = QAM_TOP_ANNEX_A;
+	setParamParameters[3] |= (QAM_MIRROR_AUTO_ON);
+	/* Env parameters */
+	/* check for LOCKRANGE Extented */
+	/* setParamParameters[3] |= QAM_LOCKRANGE_NORMAL; */
+
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM, 4, setParamParameters, 1, &cmdResult);
+	if (status < 0) {
+		/* Fall-back to the simpler call */
+		if (state->m_OperationMode == OM_QAM_ITU_C)
+			setParamParameters[0] = QAM_TOP_ANNEX_C;
+		else
+			setParamParameters[0] = QAM_TOP_ANNEX_A;
+		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV, 1, setParamParameters, 1, &cmdResult);
+		if (status < 0)
+			goto error;
+
+		setParamParameters[0] = state->m_Constellation; /* modulation     */
+		setParamParameters[1] = DRXK_QAM_I12_J17;       /* interleave mode   */
+		status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM, 2, setParamParameters, 1, &cmdResult);
+	}
+	if (status < 0)
+		goto error;
+
+	/*
+	 * STEP 3: enable the system in a mode where the ADC provides valid
+	 * signal setup modulation independent registers
+	 */
+#if 0
+	status = SetFrequency(channel, tunerFreqOffset));
+	if (status < 0)
+		goto error;
+#endif
+	status = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);
+	if (status < 0)
+		goto error;
+
+	/* Setup BER measurement */
+	status = SetQAMMeasurement(state, state->m_Constellation, state->props.symbol_rate);
+	if (status < 0)
+		goto error;
+
+	/* Reset default values */
+	status = write16(state, IQM_CF_SCALE_SH__A, IQM_CF_SCALE_SH__PRE);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_SY_TIMEOUT__A, QAM_SY_TIMEOUT__PRE);
+	if (status < 0)
+		goto error;
+
+	/* Reset default LC values */
+	status = write16(state, QAM_LC_RATE_LIMIT__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_LPF_FACTORP__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_LPF_FACTORI__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_MODE__A, 7);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, QAM_LC_QUAL_TAB0__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB1__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB2__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB3__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB4__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB5__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB6__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB8__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB9__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB10__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB12__A, 2);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB15__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB16__A, 3);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB20__A, 4);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_LC_QUAL_TAB25__A, 4);
+	if (status < 0)
+		goto error;
+
+	/* Mirroring, QAM-block starting point not inverted */
+	status = write16(state, QAM_SY_SP_INV__A, QAM_SY_SP_INV_SPECTRUM_INV_DIS);
+	if (status < 0)
+		goto error;
+
+	/* Halt SCU to enable safe non-atomic accesses */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
+	if (status < 0)
+		goto error;
+
+	/* STEP 4: modulation specific setup */
+	switch (state->props.modulation) {
+	case QAM_16:
+		status = SetQAM16(state);
+		break;
+	case QAM_32:
+		status = SetQAM32(state);
+		break;
+	case QAM_AUTO:
+	case QAM_64:
+		status = SetQAM64(state);
+		break;
+	case QAM_128:
+		status = SetQAM128(state);
+		break;
+	case QAM_256:
+		status = SetQAM256(state);
+		break;
+	default:
+		status = -EINVAL;
+		break;
+	}
+	if (status < 0)
+		goto error;
+
+	/* Activate SCU to enable SCU commands */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+
+	/* Re-configure MPEG output, requires knowledge of channel bitrate */
+	/* extAttr->currentChannel.modulation = channel->modulation; */
+	/* extAttr->currentChannel.symbolrate    = channel->symbolrate; */
+	status = MPEGTSDtoSetup(state, state->m_OperationMode);
+	if (status < 0)
+		goto error;
+
+	/* Start processes */
+	status = MPEGTSStart(state);
+	if (status < 0)
+		goto error;
+	status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+	status = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_ACTIVE);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);
+	if (status < 0)
+		goto error;
+
+	/* STEP 5: start QAM demodulator (starts FEC, QAM and IQM HW) */
+	status = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);
+	if (status < 0)
+		goto error;
+
+	/* update global DRXK data container */
+/*?     extAttr->qamInterleaveMode = DRXK_QAM_I12_J17; */
+
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SetQAMStandard(struct drxk_state *state,
+			  enum OperationMode oMode)
+{
+	int status;
+#ifdef DRXK_QAM_TAPS
+#define DRXK_QAMA_TAPS_SELECT
+#include "drxk_filters.h"
+#undef DRXK_QAMA_TAPS_SELECT
+#endif
+
+	dprintk(1, "\n");
+
+	/* added antenna switch */
+	SwitchAntennaToQAM(state);
+
+	/* Ensure correct power-up mode */
+	status = PowerUpQAM(state);
+	if (status < 0)
+		goto error;
+	/* Reset QAM block */
+	status = QAMResetQAM(state);
+	if (status < 0)
+		goto error;
+
+	/* Setup IQM */
+
+	status = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);
+	if (status < 0)
+		goto error;
+
+	/* Upload IQM Channel Filter settings by
+		boot loader from ROM table */
+	switch (oMode) {
+	case OM_QAM_ITU_A:
+		status = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_ITU_A, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
+		break;
+	case OM_QAM_ITU_C:
+		status = BLDirectCmd(state, IQM_CF_TAP_RE0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
+		if (status < 0)
+			goto error;
+		status = BLDirectCmd(state, IQM_CF_TAP_IM0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);
+		break;
+	default:
+		status = -EINVAL;
+	}
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_CF_OUT_ENA__A, (1 << IQM_CF_OUT_ENA_QAM__B));
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_SYMMETRIC__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_MIDTAP__A, ((1 << IQM_CF_MIDTAP_RE__B) | (1 << IQM_CF_MIDTAP_IM__B)));
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_RC_STRETCH__A, 21);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_CLP_LEN__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_CLP_TH__A, 448);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_SNS_LEN__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_POW_MEAS_LEN__A, 0);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, IQM_FS_ADJ_SEL__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_RC_ADJ_SEL__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_ADJ_SEL__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_UPD_SEL__A, 0);
+	if (status < 0)
+		goto error;
+
+	/* IQM Impulse Noise Processing Unit */
+	status = write16(state, IQM_CF_CLP_VAL__A, 500);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_DATATH__A, 1000);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_BYPASSDET__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_DET_LCT__A, 0);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_WND_LEN__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_CF_PKDTH__A, 1);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_INC_BYPASS__A, 1);
+	if (status < 0)
+		goto error;
+
+	/* turn on IQMAF. Must be done before setAgc**() */
+	status = SetIqmAf(state, true);
+	if (status < 0)
+		goto error;
+	status = write16(state, IQM_AF_START_LOCK__A, 0x01);
+	if (status < 0)
+		goto error;
+
+	/* IQM will not be reset from here, sync ADC and update/init AGC */
+	status = ADCSynchronization(state);
+	if (status < 0)
+		goto error;
+
+	/* Set the FSM step period */
+	status = write16(state, SCU_RAM_QAM_FSM_STEP_PERIOD__A, 2000);
+	if (status < 0)
+		goto error;
+
+	/* Halt SCU to enable safe non-atomic accesses */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);
+	if (status < 0)
+		goto error;
+
+	/* No more resets of the IQM, current standard correctly set =>
+		now AGCs can be configured. */
+
+	status = InitAGC(state, true);
+	if (status < 0)
+		goto error;
+	status = SetPreSaw(state, &(state->m_qamPreSawCfg));
+	if (status < 0)
+		goto error;
+
+	/* Configure AGC's */
+	status = SetAgcRf(state, &(state->m_qamRfAgcCfg), true);
+	if (status < 0)
+		goto error;
+	status = SetAgcIf(state, &(state->m_qamIfAgcCfg), true);
+	if (status < 0)
+		goto error;
+
+	/* Activate SCU to enable SCU commands */
+	status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int WriteGPIO(struct drxk_state *state)
+{
+	int status;
+	u16 value = 0;
+
+	dprintk(1, "\n");
+	/* stop lock indicator process */
+	status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+	if (status < 0)
+		goto error;
+
+	/*  Write magic word to enable pdr reg write               */
+	status = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);
+	if (status < 0)
+		goto error;
+
+	if (state->m_hasSAWSW) {
+		if (state->UIO_mask & 0x0001) { /* UIO-1 */
+			/* write to io pad configuration register - output mode */
+			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
+			if (status < 0)
+				goto error;
+
+			/* use corresponding bit in io data output registar */
+			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
+			if (status < 0)
+				goto error;
+			if ((state->m_GPIO & 0x0001) == 0)
+				value &= 0x7FFF;	/* write zero to 15th bit - 1st UIO */
+			else
+				value |= 0x8000;	/* write one to 15th bit - 1st UIO */
+			/* write back to io data output register */
+			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
+			if (status < 0)
+				goto error;
+		}
+		if (state->UIO_mask & 0x0002) { /* UIO-2 */
+			/* write to io pad configuration register - output mode */
+			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
+			if (status < 0)
+				goto error;
+
+			/* use corresponding bit in io data output registar */
+			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
+			if (status < 0)
+				goto error;
+			if ((state->m_GPIO & 0x0002) == 0)
+				value &= 0xBFFF;	/* write zero to 14th bit - 2st UIO */
+			else
+				value |= 0x4000;	/* write one to 14th bit - 2st UIO */
+			/* write back to io data output register */
+			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
+			if (status < 0)
+				goto error;
+		}
+		if (state->UIO_mask & 0x0004) { /* UIO-3 */
+			/* write to io pad configuration register - output mode */
+			status = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);
+			if (status < 0)
+				goto error;
+
+			/* use corresponding bit in io data output registar */
+			status = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);
+			if (status < 0)
+				goto error;
+			if ((state->m_GPIO & 0x0004) == 0)
+				value &= 0xFFFB;            /* write zero to 2nd bit - 3rd UIO */
+			else
+				value |= 0x0004;            /* write one to 2nd bit - 3rd UIO */
+			/* write back to io data output register */
+			status = write16(state, SIO_PDR_UIO_OUT_LO__A, value);
+			if (status < 0)
+				goto error;
+		}
+	}
+	/*  Write magic word to disable pdr reg write               */
+	status = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SwitchAntennaToQAM(struct drxk_state *state)
+{
+	int status = 0;
+	bool gpio_state;
+
+	dprintk(1, "\n");
+
+	if (!state->antenna_gpio)
+		return 0;
+
+	gpio_state = state->m_GPIO & state->antenna_gpio;
+
+	if (state->antenna_dvbt ^ gpio_state) {
+		/* Antenna is on DVB-T mode. Switch */
+		if (state->antenna_dvbt)
+			state->m_GPIO &= ~state->antenna_gpio;
+		else
+			state->m_GPIO |= state->antenna_gpio;
+		status = WriteGPIO(state);
+	}
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+static int SwitchAntennaToDVBT(struct drxk_state *state)
+{
+	int status = 0;
+	bool gpio_state;
+
+	dprintk(1, "\n");
+
+	if (!state->antenna_gpio)
+		return 0;
+
+	gpio_state = state->m_GPIO & state->antenna_gpio;
+
+	if (!(state->antenna_dvbt ^ gpio_state)) {
+		/* Antenna is on DVB-C mode. Switch */
+		if (state->antenna_dvbt)
+			state->m_GPIO |= state->antenna_gpio;
+		else
+			state->m_GPIO &= ~state->antenna_gpio;
+		status = WriteGPIO(state);
+	}
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+	return status;
+}
+
+
+static int PowerDownDevice(struct drxk_state *state)
+{
+	/* Power down to requested mode */
+	/* Backup some register settings */
+	/* Set pins with possible pull-ups connected to them in input mode */
+	/* Analog power down */
+	/* ADC power down */
+	/* Power down device */
+	int status;
+
+	dprintk(1, "\n");
+	if (state->m_bPDownOpenBridge) {
+		/* Open I2C bridge before power down of DRXK */
+		status = ConfigureI2CBridge(state, true);
+		if (status < 0)
+			goto error;
+	}
+	/* driver 0.9.0 */
+	status = DVBTEnableOFDMTokenRing(state, false);
+	if (status < 0)
+		goto error;
+
+	status = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_CLOCK);
+	if (status < 0)
+		goto error;
+	status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
+	if (status < 0)
+		goto error;
+	state->m_HICfgCtrl |= SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;
+	status = HI_CfgCommand(state);
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static int load_microcode(struct drxk_state *state, const char *mc_name)
+{
+	const struct firmware *fw = NULL;
+	int err = 0;
+
+	dprintk(1, "\n");
+
+	err = request_firmware(&fw, mc_name, state->i2c->dev.parent);
+	if (err < 0) {
+		printk(KERN_ERR
+		       "drxk: Could not load firmware file %s.\n", mc_name);
+		printk(KERN_INFO
+		       "drxk: Copy %s to your hotplug directory!\n", mc_name);
+		return err;
+	}
+	err = DownloadMicrocode(state, fw->data, fw->size);
+	release_firmware(fw);
+	return err;
+}
+
+static int init_drxk(struct drxk_state *state)
+{
+	int status = 0;
+	enum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;
+	u16 driverVersion;
+
+	dprintk(1, "\n");
+	if ((state->m_DrxkState == DRXK_UNINITIALIZED)) {
+		status = PowerUpDevice(state);
+		if (status < 0)
+			goto error;
+		status = DRXX_Open(state);
+		if (status < 0)
+			goto error;
+		/* Soft reset of OFDM-, sys- and osc-clockdomain */
+		status = write16(state, SIO_CC_SOFT_RST__A, SIO_CC_SOFT_RST_OFDM__M | SIO_CC_SOFT_RST_SYS__M | SIO_CC_SOFT_RST_OSC__M);
+		if (status < 0)
+			goto error;
+		status = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);
+		if (status < 0)
+			goto error;
+		/* TODO is this needed, if yes how much delay in worst case scenario */
+		msleep(1);
+		state->m_DRXK_A3_PATCH_CODE = true;
+		status = GetDeviceCapabilities(state);
+		if (status < 0)
+			goto error;
+
+		/* Bridge delay, uses oscilator clock */
+		/* Delay = (delay (nano seconds) * oscclk (kHz))/ 1000 */
+		/* SDA brdige delay */
+		state->m_HICfgBridgeDelay =
+			(u16) ((state->m_oscClockFreq / 1000) *
+				HI_I2C_BRIDGE_DELAY) / 1000;
+		/* Clipping */
+		if (state->m_HICfgBridgeDelay >
+			SIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M) {
+			state->m_HICfgBridgeDelay =
+				SIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M;
+		}
+		/* SCL bridge delay, same as SDA for now */
+		state->m_HICfgBridgeDelay +=
+			state->m_HICfgBridgeDelay <<
+			SIO_HI_RA_RAM_PAR_3_CFG_DBL_SCL__B;
+
+		status = InitHI(state);
+		if (status < 0)
+			goto error;
+		/* disable various processes */
+#if NOA1ROM
+		if (!(state->m_DRXK_A1_ROM_CODE)
+			&& !(state->m_DRXK_A2_ROM_CODE))
+#endif
+		{
+			status = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);
+			if (status < 0)
+				goto error;
+		}
+
+		/* disable MPEG port */
+		status = MPEGTSDisable(state);
+		if (status < 0)
+			goto error;
+
+		/* Stop AUD and SCU */
+		status = write16(state, AUD_COMM_EXEC__A, AUD_COMM_EXEC_STOP);
+		if (status < 0)
+			goto error;
+		status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_STOP);
+		if (status < 0)
+			goto error;
+
+		/* enable token-ring bus through OFDM block for possible ucode upload */
+		status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_ON);
+		if (status < 0)
+			goto error;
+
+		/* include boot loader section */
+		status = write16(state, SIO_BL_COMM_EXEC__A, SIO_BL_COMM_EXEC_ACTIVE);
+		if (status < 0)
+			goto error;
+		status = BLChainCmd(state, 0, 6, 100);
+		if (status < 0)
+			goto error;
+
+		if (state->microcode_name)
+			load_microcode(state, state->microcode_name);
+
+		/* disable token-ring bus through OFDM block for possible ucode upload */
+		status = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_OFF);
+		if (status < 0)
+			goto error;
+
+		/* Run SCU for a little while to initialize microcode version numbers */
+		status = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);
+		if (status < 0)
+			goto error;
+		status = DRXX_Open(state);
+		if (status < 0)
+			goto error;
+		/* added for test */
+		msleep(30);
+
+		powerMode = DRXK_POWER_DOWN_OFDM;
+		status = CtrlPowerMode(state, &powerMode);
+		if (status < 0)
+			goto error;
+
+		/* Stamp driver version number in SCU data RAM in BCD code
+			Done to enable field application engineers to retreive drxdriver version
+			via I2C from SCU RAM.
+			Not using SCU command interface for SCU register access since no
+			microcode may be present.
+			*/
+		driverVersion =
+			(((DRXK_VERSION_MAJOR / 100) % 10) << 12) +
+			(((DRXK_VERSION_MAJOR / 10) % 10) << 8) +
+			((DRXK_VERSION_MAJOR % 10) << 4) +
+			(DRXK_VERSION_MINOR % 10);
+		status = write16(state, SCU_RAM_DRIVER_VER_HI__A, driverVersion);
+		if (status < 0)
+			goto error;
+		driverVersion =
+			(((DRXK_VERSION_PATCH / 1000) % 10) << 12) +
+			(((DRXK_VERSION_PATCH / 100) % 10) << 8) +
+			(((DRXK_VERSION_PATCH / 10) % 10) << 4) +
+			(DRXK_VERSION_PATCH % 10);
+		status = write16(state, SCU_RAM_DRIVER_VER_LO__A, driverVersion);
+		if (status < 0)
+			goto error;
+
+		printk(KERN_INFO "DRXK driver version %d.%d.%d\n",
+			DRXK_VERSION_MAJOR, DRXK_VERSION_MINOR,
+			DRXK_VERSION_PATCH);
+
+		/* Dirty fix of default values for ROM/PATCH microcode
+			Dirty because this fix makes it impossible to setup suitable values
+			before calling DRX_Open. This solution requires changes to RF AGC speed
+			to be done via the CTRL function after calling DRX_Open */
+
+		/* m_dvbtRfAgcCfg.speed = 3; */
+
+		/* Reset driver debug flags to 0 */
+		status = write16(state, SCU_RAM_DRIVER_DEBUG__A, 0);
+		if (status < 0)
+			goto error;
+		/* driver 0.9.0 */
+		/* Setup FEC OC:
+			NOTE: No more full FEC resets allowed afterwards!! */
+		status = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_STOP);
+		if (status < 0)
+			goto error;
+		/* MPEGTS functions are still the same */
+		status = MPEGTSDtoInit(state);
+		if (status < 0)
+			goto error;
+		status = MPEGTSStop(state);
+		if (status < 0)
+			goto error;
+		status = MPEGTSConfigurePolarity(state);
+		if (status < 0)
+			goto error;
+		status = MPEGTSConfigurePins(state, state->m_enableMPEGOutput);
+		if (status < 0)
+			goto error;
+		/* added: configure GPIO */
+		status = WriteGPIO(state);
+		if (status < 0)
+			goto error;
+
+		state->m_DrxkState = DRXK_STOPPED;
+
+		if (state->m_bPowerDown) {
+			status = PowerDownDevice(state);
+			if (status < 0)
+				goto error;
+			state->m_DrxkState = DRXK_POWERED_DOWN;
+		} else
+			state->m_DrxkState = DRXK_STOPPED;
+	}
+error:
+	if (status < 0)
+		printk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);
+
+	return status;
+}
+
+static void drxk_release(struct dvb_frontend *fe)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+
+	dprintk(1, "\n");
+	kfree(state);
+}
+
+static int drxk_sleep(struct dvb_frontend *fe)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+
+	dprintk(1, "\n");
+	ShutDown(state);
+	return 0;
+}
+
+static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+
+	dprintk(1, "%s\n", enable ? "enable" : "disable");
+	return ConfigureI2CBridge(state, enable ? true : false);
+}
+
+static int drxk_set_parameters(struct dvb_frontend *fe)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u32 delsys  = p->delivery_system, old_delsys;
+	struct drxk_state *state = fe->demodulator_priv;
+	u32 IF;
+
+	dprintk(1, "\n");
+
+	if (!fe->ops.tuner_ops.get_if_frequency) {
+		printk(KERN_ERR
+		       "drxk: Error: get_if_frequency() not defined at tuner. Can't work without it!\n");
+		return -EINVAL;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	old_delsys = state->props.delivery_system;
+	state->props = *p;
+
+	if (old_delsys != delsys) {
+		ShutDown(state);
+		switch (delsys) {
+		case SYS_DVBC_ANNEX_A:
+		case SYS_DVBC_ANNEX_C:
+			if (!state->m_hasDVBC)
+				return -EINVAL;
+			state->m_itut_annex_c = (delsys == SYS_DVBC_ANNEX_C) ? true : false;
+			if (state->m_itut_annex_c)
+				SetOperationMode(state, OM_QAM_ITU_C);
+			else
+				SetOperationMode(state, OM_QAM_ITU_A);
+			break;
+		case SYS_DVBT:
+			if (!state->m_hasDVBT)
+				return -EINVAL;
+			SetOperationMode(state, OM_DVBT);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+	Start(state, 0, IF);
+
+	/* printk(KERN_DEBUG "drxk: %s IF=%d done\n", __func__, IF); */
+
+	return 0;
+}
+
+static int drxk_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+	u32 stat;
+
+	dprintk(1, "\n");
+	*status = 0;
+	GetLockStatus(state, &stat, 0);
+	if (stat == MPEG_LOCK)
+		*status |= 0x1f;
+	if (stat == FEC_LOCK)
+		*status |= 0x0f;
+	if (stat == DEMOD_LOCK)
+		*status |= 0x07;
+	return 0;
+}
+
+static int drxk_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	dprintk(1, "\n");
+
+	*ber = 0;
+	return 0;
+}
+
+static int drxk_read_signal_strength(struct dvb_frontend *fe,
+				     u16 *strength)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+	u32 val = 0;
+
+	dprintk(1, "\n");
+	ReadIFAgc(state, &val);
+	*strength = val & 0xffff;
+	return 0;
+}
+
+static int drxk_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+	s32 snr2;
+
+	dprintk(1, "\n");
+	GetSignalToNoise(state, &snr2);
+	*snr = snr2 & 0xffff;
+	return 0;
+}
+
+static int drxk_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct drxk_state *state = fe->demodulator_priv;
+	u16 err;
+
+	dprintk(1, "\n");
+	DVBTQAMGetAccPktErr(state, &err);
+	*ucblocks = (u32) err;
+	return 0;
+}
+
+static int drxk_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings
+				    *sets)
+{
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+
+	dprintk(1, "\n");
+	switch (p->delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+	case SYS_DVBT:
+		sets->min_delay_ms = 3000;
+		sets->max_drift = 0;
+		sets->step_size = 0;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static struct dvb_frontend_ops drxk_ops = {
+	/* .delsys will be filled dynamically */
+	.info = {
+		.name = "DRXK",
+		.frequency_min = 47000000,
+		.frequency_max = 865000000,
+		 /* For DVB-C */
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		/* For DVB-T */
+		.frequency_stepsize = 166667,
+
+		.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_MUTE_TS |
+			FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_RECOVER |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO
+	},
+
+	.release = drxk_release,
+	.sleep = drxk_sleep,
+	.i2c_gate_ctrl = drxk_gate_ctrl,
+
+	.set_frontend = drxk_set_parameters,
+	.get_tune_settings = drxk_get_tune_settings,
+
+	.read_status = drxk_read_status,
+	.read_ber = drxk_read_ber,
+	.read_signal_strength = drxk_read_signal_strength,
+	.read_snr = drxk_read_snr,
+	.read_ucblocks = drxk_read_ucblocks,
+};
+
+struct dvb_frontend *drxk_attach(const struct drxk_config *config,
+				 struct i2c_adapter *i2c)
+{
+	int n;
+
+	struct drxk_state *state = NULL;
+	u8 adr = config->adr;
+
+	dprintk(1, "\n");
+	state = kzalloc(sizeof(struct drxk_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->i2c = i2c;
+	state->demod_address = adr;
+	state->single_master = config->single_master;
+	state->microcode_name = config->microcode_name;
+	state->no_i2c_bridge = config->no_i2c_bridge;
+	state->antenna_gpio = config->antenna_gpio;
+	state->antenna_dvbt = config->antenna_dvbt;
+	state->m_ChunkSize = config->chunk_size;
+	state->enable_merr_cfg = config->enable_merr_cfg;
+
+	if (config->dynamic_clk) {
+		state->m_DVBTStaticCLK = 0;
+		state->m_DVBCStaticCLK = 0;
+	} else {
+		state->m_DVBTStaticCLK = 1;
+		state->m_DVBCStaticCLK = 1;
+	}
+
+
+	if (config->mpeg_out_clk_strength)
+		state->m_TSClockkStrength = config->mpeg_out_clk_strength & 0x07;
+	else
+		state->m_TSClockkStrength = 0x06;
+
+	if (config->parallel_ts)
+		state->m_enableParallel = true;
+	else
+		state->m_enableParallel = false;
+
+	/* NOTE: as more UIO bits will be used, add them to the mask */
+	state->UIO_mask = config->antenna_gpio;
+
+	/* Default gpio to DVB-C */
+	if (!state->antenna_dvbt && state->antenna_gpio)
+		state->m_GPIO |= state->antenna_gpio;
+	else
+		state->m_GPIO &= ~state->antenna_gpio;
+
+	mutex_init(&state->mutex);
+
+	memcpy(&state->frontend.ops, &drxk_ops, sizeof(drxk_ops));
+	state->frontend.demodulator_priv = state;
+
+	init_state(state);
+	if (init_drxk(state) < 0)
+		goto error;
+
+	/* Initialize the supported delivery systems */
+	n = 0;
+	if (state->m_hasDVBC) {
+		state->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_A;
+		state->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_C;
+		strlcat(state->frontend.ops.info.name, " DVB-C",
+			sizeof(state->frontend.ops.info.name));
+	}
+	if (state->m_hasDVBT) {
+		state->frontend.ops.delsys[n++] = SYS_DVBT;
+		strlcat(state->frontend.ops.info.name, " DVB-T",
+			sizeof(state->frontend.ops.info.name));
+	}
+
+	printk(KERN_INFO "drxk: frontend initialized.\n");
+	return &state->frontend;
+
+error:
+	printk(KERN_ERR "drxk: not found\n");
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(drxk_attach);
+
+MODULE_DESCRIPTION("DRX-K driver");
+MODULE_AUTHOR("Ralph Metzler");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/dvb/frontends/Kconfig linux-3.4.3.dd/drivers/media/dvb/frontends/Kconfig
--- linux-3.4.3/drivers/media/dvb/frontends/Kconfig	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/Kconfig	2012-06-18 22:32:50.644032228 +0200
@@ -70,6 +70,24 @@
 
 	  Say Y when you want to support this tuner.
 
+config DVB_STV0367DD
+	tristate "STV 0367 (DD)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  STV 0367 DVB-C/T demodulator (Digital Devices driver).
+
+	  Say Y when you want to support this frontend.
+
+config DVB_TDA18212DD
+	tristate "NXP TDA18212 silicon tuner (DD)"
+	depends on DVB_CORE && I2C
+	default m if DVB_FE_CUSTOMISE
+	help
+	  NXP TDA18212 silicon tuner (Digital Devices driver).
+
+	  Say Y when you want to support this tuner.
+
 comment "DVB-S (satellite) frontends"
 	depends on DVB_CORE
 
diff -urN linux-3.4.3/drivers/media/dvb/frontends/Makefile linux-3.4.3.dd/drivers/media/dvb/frontends/Makefile
--- linux-3.4.3/drivers/media/dvb/frontends/Makefile	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/Makefile	2012-06-18 22:33:01.414032234 +0200
@@ -93,6 +93,8 @@
 obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
 obj-$(CONFIG_DVB_DRXK) += drxk.o
 obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
+obj-$(CONFIG_DVB_STV0367DD) += stv0367dd.o
+obj-$(CONFIG_DVB_TDA18212DD) += tda18212dd.o
 obj-$(CONFIG_DVB_IT913X_FE) += it913x-fe.o
 obj-$(CONFIG_DVB_A8293) += a8293.o
 obj-$(CONFIG_DVB_TDA10071) += tda10071.o
diff -urN linux-3.4.3/drivers/media/dvb/frontends/Makefile.orig linux-3.4.3.dd/drivers/media/dvb/frontends/Makefile.orig
--- linux-3.4.3/drivers/media/dvb/frontends/Makefile.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/Makefile.orig	2012-06-17 20:21:44.000000000 +0200
@@ -0,0 +1,101 @@
+#
+# Makefile for the kernel DVB frontend device drivers.
+#
+
+ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core/
+ccflags-y += -I$(srctree)/drivers/media/common/tuners/
+
+stb0899-objs = stb0899_drv.o stb0899_algo.o
+stv0900-objs = stv0900_core.o stv0900_sw.o
+au8522-objs = au8522_dig.o au8522_decoder.o
+drxd-objs = drxd_firm.o drxd_hard.o
+cxd2820r-objs = cxd2820r_core.o cxd2820r_c.o cxd2820r_t.o cxd2820r_t2.o
+drxk-objs := drxk_hard.o
+
+obj-$(CONFIG_DVB_PLL) += dvb-pll.o
+obj-$(CONFIG_DVB_STV0299) += stv0299.o
+obj-$(CONFIG_DVB_STB0899) += stb0899.o
+obj-$(CONFIG_DVB_STB6100) += stb6100.o
+obj-$(CONFIG_DVB_SP8870) += sp8870.o
+obj-$(CONFIG_DVB_CX22700) += cx22700.o
+obj-$(CONFIG_DVB_S5H1432) += s5h1432.o
+obj-$(CONFIG_DVB_CX24110) += cx24110.o
+obj-$(CONFIG_DVB_TDA8083) += tda8083.o
+obj-$(CONFIG_DVB_L64781) += l64781.o
+obj-$(CONFIG_DVB_DIB3000MB) += dib3000mb.o
+obj-$(CONFIG_DVB_DIB3000MC) += dib3000mc.o dibx000_common.o
+obj-$(CONFIG_DVB_DIB7000M) += dib7000m.o dibx000_common.o
+obj-$(CONFIG_DVB_DIB7000P) += dib7000p.o dibx000_common.o
+obj-$(CONFIG_DVB_DIB8000) += dib8000.o dibx000_common.o
+obj-$(CONFIG_DVB_DIB9000) += dib9000.o dibx000_common.o
+obj-$(CONFIG_DVB_MT312) += mt312.o
+obj-$(CONFIG_DVB_VES1820) += ves1820.o
+obj-$(CONFIG_DVB_VES1X93) += ves1x93.o
+obj-$(CONFIG_DVB_TDA1004X) += tda1004x.o
+obj-$(CONFIG_DVB_SP887X) += sp887x.o
+obj-$(CONFIG_DVB_NXT6000) += nxt6000.o
+obj-$(CONFIG_DVB_MT352) += mt352.o
+obj-$(CONFIG_DVB_ZL10036) += zl10036.o
+obj-$(CONFIG_DVB_ZL10039) += zl10039.o
+obj-$(CONFIG_DVB_ZL10353) += zl10353.o
+obj-$(CONFIG_DVB_CX22702) += cx22702.o
+obj-$(CONFIG_DVB_DRXD) += drxd.o
+obj-$(CONFIG_DVB_TDA10021) += tda10021.o
+obj-$(CONFIG_DVB_TDA10023) += tda10023.o
+obj-$(CONFIG_DVB_STV0297) += stv0297.o
+obj-$(CONFIG_DVB_NXT200X) += nxt200x.o
+obj-$(CONFIG_DVB_OR51211) += or51211.o
+obj-$(CONFIG_DVB_OR51132) += or51132.o
+obj-$(CONFIG_DVB_BCM3510) += bcm3510.o
+obj-$(CONFIG_DVB_S5H1420) += s5h1420.o
+obj-$(CONFIG_DVB_LGDT330X) += lgdt330x.o
+obj-$(CONFIG_DVB_LGDT3305) += lgdt3305.o
+obj-$(CONFIG_DVB_CX24123) += cx24123.o
+obj-$(CONFIG_DVB_LNBP21) += lnbp21.o
+obj-$(CONFIG_DVB_LNBP22) += lnbp22.o
+obj-$(CONFIG_DVB_ISL6405) += isl6405.o
+obj-$(CONFIG_DVB_ISL6421) += isl6421.o
+obj-$(CONFIG_DVB_TDA10086) += tda10086.o
+obj-$(CONFIG_DVB_TDA826X) += tda826x.o
+obj-$(CONFIG_DVB_TDA8261) += tda8261.o
+obj-$(CONFIG_DVB_TUNER_DIB0070) += dib0070.o
+obj-$(CONFIG_DVB_TUNER_DIB0090) += dib0090.o
+obj-$(CONFIG_DVB_TUA6100) += tua6100.o
+obj-$(CONFIG_DVB_S5H1409) += s5h1409.o
+obj-$(CONFIG_DVB_TUNER_ITD1000) += itd1000.o
+obj-$(CONFIG_DVB_AU8522) += au8522.o
+obj-$(CONFIG_DVB_TDA10048) += tda10048.o
+obj-$(CONFIG_DVB_TUNER_CX24113) += cx24113.o
+obj-$(CONFIG_DVB_S5H1411) += s5h1411.o
+obj-$(CONFIG_DVB_LGS8GL5) += lgs8gl5.o
+obj-$(CONFIG_DVB_TDA665x) += tda665x.o
+obj-$(CONFIG_DVB_LGS8GXX) += lgs8gxx.o
+obj-$(CONFIG_DVB_ATBM8830) += atbm8830.o
+obj-$(CONFIG_DVB_DUMMY_FE) += dvb_dummy_fe.o
+obj-$(CONFIG_DVB_AF9013) += af9013.o
+obj-$(CONFIG_DVB_CX24116) += cx24116.o
+obj-$(CONFIG_DVB_SI21XX) += si21xx.o
+obj-$(CONFIG_DVB_STV0288) += stv0288.o
+obj-$(CONFIG_DVB_STB6000) += stb6000.o
+obj-$(CONFIG_DVB_S921) += s921.o
+obj-$(CONFIG_DVB_STV6110) += stv6110.o
+obj-$(CONFIG_DVB_STV0900) += stv0900.o
+obj-$(CONFIG_DVB_STV090x) += stv090x.o
+obj-$(CONFIG_DVB_STV6110x) += stv6110x.o
+obj-$(CONFIG_DVB_ISL6423) += isl6423.o
+obj-$(CONFIG_DVB_EC100) += ec100.o
+obj-$(CONFIG_DVB_HD29L2) += hd29l2.o
+obj-$(CONFIG_DVB_DS3000) += ds3000.o
+obj-$(CONFIG_DVB_MB86A16) += mb86a16.o
+obj-$(CONFIG_DVB_MB86A20S) += mb86a20s.o
+obj-$(CONFIG_DVB_IX2505V) += ix2505v.o
+obj-$(CONFIG_DVB_STV0367) += stv0367.o
+obj-$(CONFIG_DVB_CXD2820R) += cxd2820r.o
+obj-$(CONFIG_DVB_DRXK) += drxk.o
+obj-$(CONFIG_DVB_TDA18271C2DD) += tda18271c2dd.o
+obj-$(CONFIG_DVB_IT913X_FE) += it913x-fe.o
+obj-$(CONFIG_DVB_A8293) += a8293.o
+obj-$(CONFIG_DVB_TDA10071) += tda10071.o
+obj-$(CONFIG_DVB_RTL2830) += rtl2830.o
+obj-$(CONFIG_DVB_M88RS2000) += m88rs2000.o
+
diff -urN linux-3.4.3/drivers/media/dvb/frontends/stv0367dd.c linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd.c
--- linux-3.4.3/drivers/media/dvb/frontends/stv0367dd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd.c	2012-06-18 23:25:56.774033861 +0200
@@ -0,0 +1,2265 @@
+/*
+ * stv0367dd: STV0367 DVB-C/T demodulator driver
+ *
+ * Copyright (C) 2011 Digital Devices GmbH
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <asm/div64.h>
+
+#include "linux/compat.h"
+#include "dvb_frontend.h"
+#include "stv0367dd.h"
+#include "stv0367dd_regs.h"
+
+enum omode { OM_NONE, OM_DVBT, OM_DVBC, OM_QAM_ITU_C };
+enum {  QAM_MOD_QAM4 = 0,
+	QAM_MOD_QAM16,
+	QAM_MOD_QAM32,
+	QAM_MOD_QAM64,
+	QAM_MOD_QAM128,
+	QAM_MOD_QAM256,
+	QAM_MOD_QAM512,
+	QAM_MOD_QAM1024
+};
+
+enum {QAM_SPECT_NORMAL, QAM_SPECT_INVERTED };
+
+enum {
+	QAM_FEC_A = 1,					/* J83 Annex A */
+	QAM_FEC_B = (1<<1),				/* J83 Annex B */
+	QAM_FEC_C = (1<<2)				/* J83 Annex C */
+};
+
+enum EDemodState { Off, QAMSet, OFDMSet, QAMStarted, OFDMStarted };
+
+struct stv_state {
+#ifdef USE_API3
+	struct dvb_frontend c_frontend;
+	struct dvb_frontend t_frontend;
+#else
+	struct dvb_frontend frontend;
+#endif
+	fe_modulation_t modulation;
+	u32 symbol_rate;
+	u32 bandwidth;
+	struct device *dev;
+
+	struct i2c_adapter *i2c;
+	u8     adr;
+	void  *priv;
+
+	struct mutex mutex;
+	struct mutex ctlock;
+
+	u32 master_clock;
+	u32 adc_clock;
+	u8 ID;
+	u8 I2CRPT;
+	u32 omode;
+	u8  qam_inversion;
+
+	s32 IF;
+
+	s32    m_FECTimeOut;
+	s32    m_DemodTimeOut;
+	s32    m_SignalTimeOut;
+	s32    m_DemodLockTime;
+	s32    m_FFTTimeOut;
+	s32    m_TSTimeOut;
+
+	bool    m_bFirstTimeLock;
+
+	u8    m_Save_QAM_AGC_CTL;
+
+	enum EDemodState demod_state;
+
+	u8    m_OFDM_FFTMode;          // 0 = 2k, 1 = 8k, 2 = 4k
+	u8    m_OFDM_Modulation;   //
+	u8    m_OFDM_FEC;          //
+	u8    m_OFDM_Guard;
+
+	u32   ucblocks;
+};
+
+struct init_table {
+	u16  adr;
+	u8   data;
+};
+
+struct init_table base_init[] = {
+	{ R367_IOCFG0,     0x80 },
+	{ R367_DAC0R,      0x00 },
+	{ R367_IOCFG1,     0x00 },
+	{ R367_DAC1R,      0x00 },
+	{ R367_IOCFG2,     0x00 },
+	{ R367_SDFR,       0x00 },
+	{ R367_AUX_CLK,    0x00 },
+	{ R367_FREESYS1,   0x00 },
+	{ R367_FREESYS2,   0x00 },
+	{ R367_FREESYS3,   0x00 },
+	{ R367_GPIO_CFG,   0x55 },
+	{ R367_GPIO_CMD,   0x01 },
+	{ R367_TSTRES,     0x00 },
+	{ R367_ANACTRL,    0x00 },
+	{ R367_TSTBUS,     0x00 },
+	{ R367_RF_AGC2,    0x20 },
+	{ R367_ANADIGCTRL, 0x0b },
+	{ R367_PLLMDIV,    0x01 },
+	{ R367_PLLNDIV,    0x08 },
+	{ R367_PLLSETUP,   0x18 },
+	{ R367_DUAL_AD12,  0x04 },
+	{ R367_TSTBIST,    0x00 },
+	{ 0x0000,          0x00 }
+};
+
+struct init_table qam_init[] = {
+	{ R367_QAM_CTRL_1,                  0x06 },// Orginal 0x04
+	{ R367_QAM_CTRL_2,                  0x03 },
+	{ R367_QAM_IT_STATUS1,              0x2b },
+	{ R367_QAM_IT_STATUS2,              0x08 },
+	{ R367_QAM_IT_EN1,                  0x00 },
+	{ R367_QAM_IT_EN2,                  0x00 },
+	{ R367_QAM_CTRL_STATUS,             0x04 },
+	{ R367_QAM_TEST_CTL,                0x00 },
+	{ R367_QAM_AGC_CTL,                 0x73 },
+	{ R367_QAM_AGC_IF_CFG,              0x50 },
+	{ R367_QAM_AGC_RF_CFG,              0x02 },// RF Freeze
+	{ R367_QAM_AGC_PWM_CFG,             0x03 },
+	{ R367_QAM_AGC_PWR_REF_L,           0x5a },
+	{ R367_QAM_AGC_PWR_REF_H,           0x00 },
+	{ R367_QAM_AGC_RF_TH_L,             0xff },
+	{ R367_QAM_AGC_RF_TH_H,             0x07 },
+	{ R367_QAM_AGC_IF_LTH_L,            0x00 },
+	{ R367_QAM_AGC_IF_LTH_H,            0x08 },
+	{ R367_QAM_AGC_IF_HTH_L,            0xff },
+	{ R367_QAM_AGC_IF_HTH_H,            0x07 },
+	{ R367_QAM_AGC_PWR_RD_L,            0xa0 },
+	{ R367_QAM_AGC_PWR_RD_M,            0xe9 },
+	{ R367_QAM_AGC_PWR_RD_H,            0x03 },
+	{ R367_QAM_AGC_PWM_IFCMD_L,         0xe4 },
+	{ R367_QAM_AGC_PWM_IFCMD_H,         0x00 },
+	{ R367_QAM_AGC_PWM_RFCMD_L,         0xff },
+	{ R367_QAM_AGC_PWM_RFCMD_H,         0x07 },
+	{ R367_QAM_IQDEM_CFG,               0x01 },
+	{ R367_QAM_MIX_NCO_LL,              0x22 },
+	{ R367_QAM_MIX_NCO_HL,              0x96 },
+	{ R367_QAM_MIX_NCO_HH,              0x55 },
+	{ R367_QAM_SRC_NCO_LL,              0xff },
+	{ R367_QAM_SRC_NCO_LH,              0x0c },
+	{ R367_QAM_SRC_NCO_HL,              0xf5 },
+	{ R367_QAM_SRC_NCO_HH,              0x20 },
+	{ R367_QAM_IQDEM_GAIN_SRC_L,        0x06 },
+	{ R367_QAM_IQDEM_GAIN_SRC_H,        0x01 },
+	{ R367_QAM_IQDEM_DCRM_CFG_LL,       0xfe },
+	{ R367_QAM_IQDEM_DCRM_CFG_LH,       0xff },
+	{ R367_QAM_IQDEM_DCRM_CFG_HL,       0x0f },
+	{ R367_QAM_IQDEM_DCRM_CFG_HH,       0x00 },
+	{ R367_QAM_IQDEM_ADJ_COEFF0,        0x34 },
+	{ R367_QAM_IQDEM_ADJ_COEFF1,        0xae },
+	{ R367_QAM_IQDEM_ADJ_COEFF2,        0x46 },
+	{ R367_QAM_IQDEM_ADJ_COEFF3,        0x77 },
+	{ R367_QAM_IQDEM_ADJ_COEFF4,        0x96 },
+	{ R367_QAM_IQDEM_ADJ_COEFF5,        0x69 },
+	{ R367_QAM_IQDEM_ADJ_COEFF6,        0xc7 },
+	{ R367_QAM_IQDEM_ADJ_COEFF7,        0x01 },
+	{ R367_QAM_IQDEM_ADJ_EN,            0x04 },
+	{ R367_QAM_IQDEM_ADJ_AGC_REF,       0x94 },
+	{ R367_QAM_ALLPASSFILT1,            0xc9 },
+	{ R367_QAM_ALLPASSFILT2,            0x2d },
+	{ R367_QAM_ALLPASSFILT3,            0xa3 },
+	{ R367_QAM_ALLPASSFILT4,            0xfb },
+	{ R367_QAM_ALLPASSFILT5,            0xf6 },
+	{ R367_QAM_ALLPASSFILT6,            0x45 },
+	{ R367_QAM_ALLPASSFILT7,            0x6f },
+	{ R367_QAM_ALLPASSFILT8,            0x7e },
+	{ R367_QAM_ALLPASSFILT9,            0x05 },
+	{ R367_QAM_ALLPASSFILT10,           0x0a },
+	{ R367_QAM_ALLPASSFILT11,           0x51 },
+	{ R367_QAM_TRL_AGC_CFG,             0x20 },
+	{ R367_QAM_TRL_LPF_CFG,             0x28 },
+	{ R367_QAM_TRL_LPF_ACQ_GAIN,        0x44 },
+	{ R367_QAM_TRL_LPF_TRK_GAIN,        0x22 },
+	{ R367_QAM_TRL_LPF_OUT_GAIN,        0x03 },
+	{ R367_QAM_TRL_LOCKDET_LTH,         0x04 },
+	{ R367_QAM_TRL_LOCKDET_HTH,         0x11 },
+	{ R367_QAM_TRL_LOCKDET_TRGVAL,      0x20 },
+	{ R367_QAM_IQ_QAM,			0x01 },
+	{ R367_QAM_FSM_STATE,               0xa0 },
+	{ R367_QAM_FSM_CTL,                 0x08 },
+	{ R367_QAM_FSM_STS,                 0x0c },
+	{ R367_QAM_FSM_SNR0_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR1_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR2_HTH,            0x00 },
+	{ R367_QAM_FSM_SNR0_LTH,            0x00 },
+	{ R367_QAM_FSM_SNR1_LTH,            0x00 },
+	{ R367_QAM_FSM_EQA1_HTH,            0x00 },
+	{ R367_QAM_FSM_TEMPO,               0x32 },
+	{ R367_QAM_FSM_CONFIG,              0x03 },
+	{ R367_QAM_EQU_I_TESTTAP_L,         0x11 },
+	{ R367_QAM_EQU_I_TESTTAP_M,         0x00 },
+	{ R367_QAM_EQU_I_TESTTAP_H,         0x00 },
+	{ R367_QAM_EQU_TESTAP_CFG,          0x00 },
+	{ R367_QAM_EQU_Q_TESTTAP_L,         0xff },
+	{ R367_QAM_EQU_Q_TESTTAP_M,         0x00 },
+	{ R367_QAM_EQU_Q_TESTTAP_H,         0x00 },
+	{ R367_QAM_EQU_TAP_CTRL,            0x00 },
+	{ R367_QAM_EQU_CTR_CRL_CONTROL_L,   0x11 },
+	{ R367_QAM_EQU_CTR_CRL_CONTROL_H,   0x05 },
+	{ R367_QAM_EQU_CTR_HIPOW_L,         0x00 },
+	{ R367_QAM_EQU_CTR_HIPOW_H,         0x00 },
+	{ R367_QAM_EQU_I_EQU_LO,            0xef },
+	{ R367_QAM_EQU_I_EQU_HI,            0x00 },
+	{ R367_QAM_EQU_Q_EQU_LO,            0xee },
+	{ R367_QAM_EQU_Q_EQU_HI,            0x00 },
+	{ R367_QAM_EQU_MAPPER,              0xc5 },
+	{ R367_QAM_EQU_SWEEP_RATE,          0x80 },
+	{ R367_QAM_EQU_SNR_LO,              0x64 },
+	{ R367_QAM_EQU_SNR_HI,              0x03 },
+	{ R367_QAM_EQU_GAMMA_LO,            0x00 },
+	{ R367_QAM_EQU_GAMMA_HI,            0x00 },
+	{ R367_QAM_EQU_ERR_GAIN,            0x36 },
+	{ R367_QAM_EQU_RADIUS,              0xaa },
+	{ R367_QAM_EQU_FFE_MAINTAP,         0x00 },
+	{ R367_QAM_EQU_FFE_LEAKAGE,         0x63 },
+	{ R367_QAM_EQU_FFE_MAINTAP_POS,     0xdf },
+	{ R367_QAM_EQU_GAIN_WIDE,           0x88 },
+	{ R367_QAM_EQU_GAIN_NARROW,         0x41 },
+	{ R367_QAM_EQU_CTR_LPF_GAIN,        0xd1 },
+	{ R367_QAM_EQU_CRL_LPF_GAIN,        0xa7 },
+	{ R367_QAM_EQU_GLOBAL_GAIN,         0x06 },
+	{ R367_QAM_EQU_CRL_LD_SEN,          0x85 },
+	{ R367_QAM_EQU_CRL_LD_VAL,          0xe2 },
+	{ R367_QAM_EQU_CRL_TFR,             0x20 },
+	{ R367_QAM_EQU_CRL_BISTH_LO,        0x00 },
+	{ R367_QAM_EQU_CRL_BISTH_HI,        0x00 },
+	{ R367_QAM_EQU_SWEEP_RANGE_LO,      0x00 },
+	{ R367_QAM_EQU_SWEEP_RANGE_HI,      0x00 },
+	{ R367_QAM_EQU_CRL_LIMITER,         0x40 },
+	{ R367_QAM_EQU_MODULUS_MAP,         0x90 },
+	{ R367_QAM_EQU_PNT_GAIN,            0xa7 },
+	{ R367_QAM_FEC_AC_CTR_0,            0x16 },
+	{ R367_QAM_FEC_AC_CTR_1,            0x0b },
+	{ R367_QAM_FEC_AC_CTR_2,            0x88 },
+	{ R367_QAM_FEC_AC_CTR_3,            0x02 },
+	{ R367_QAM_FEC_STATUS,              0x12 },
+	{ R367_QAM_RS_COUNTER_0,            0x7d },
+	{ R367_QAM_RS_COUNTER_1,            0xd0 },
+	{ R367_QAM_RS_COUNTER_2,            0x19 },
+	{ R367_QAM_RS_COUNTER_3,            0x0b },
+	{ R367_QAM_RS_COUNTER_4,            0xa3 },
+	{ R367_QAM_RS_COUNTER_5,            0x00 },
+	{ R367_QAM_BERT_0,                  0x01 },
+	{ R367_QAM_BERT_1,                  0x25 },
+	{ R367_QAM_BERT_2,                  0x41 },
+	{ R367_QAM_BERT_3,                  0x39 },
+	{ R367_QAM_OUTFORMAT_0,             0xc2 },
+	{ R367_QAM_OUTFORMAT_1,             0x22 },
+	{ R367_QAM_SMOOTHER_2,              0x28 },
+	{ R367_QAM_TSMF_CTRL_0,             0x01 },
+	{ R367_QAM_TSMF_CTRL_1,             0xc6 },
+	{ R367_QAM_TSMF_CTRL_3,             0x43 },
+	{ R367_QAM_TS_ON_ID_0,              0x00 },
+	{ R367_QAM_TS_ON_ID_1,              0x00 },
+	{ R367_QAM_TS_ON_ID_2,              0x00 },
+	{ R367_QAM_TS_ON_ID_3,              0x00 },
+	{ R367_QAM_RE_STATUS_0,             0x00 },
+	{ R367_QAM_RE_STATUS_1,             0x00 },
+	{ R367_QAM_RE_STATUS_2,             0x00 },
+	{ R367_QAM_RE_STATUS_3,             0x00 },
+	{ R367_QAM_TS_STATUS_0,             0x00 },
+	{ R367_QAM_TS_STATUS_1,             0x00 },
+	{ R367_QAM_TS_STATUS_2,             0xa0 },
+	{ R367_QAM_TS_STATUS_3,             0x00 },
+	{ R367_QAM_T_O_ID_0,                0x00 },
+	{ R367_QAM_T_O_ID_1,                0x00 },
+	{ R367_QAM_T_O_ID_2,                0x00 },
+	{ R367_QAM_T_O_ID_3,                0x00 },
+	{ 0x0000, 0x00 } // EOT
+};
+
+struct init_table ofdm_init[] = {
+	//{R367_OFDM_ID                   ,0x60},
+	//{R367_OFDM_I2CRPT 				,0x22},
+	//{R367_OFDM_TOPCTRL				,0x02},
+	//{R367_OFDM_IOCFG0				,0x40},
+	//{R367_OFDM_DAC0R				,0x00},
+	//{R367_OFDM_IOCFG1				,0x00},
+	//{R367_OFDM_DAC1R				,0x00},
+	//{R367_OFDM_IOCFG2				,0x62},
+	//{R367_OFDM_SDFR 				,0x00},
+	//{R367_OFDM_STATUS				,0xf8},
+	//{R367_OFDM_AUX_CLK				,0x0a},
+	//{R367_OFDM_FREESYS1			,0x00},
+	//{R367_OFDM_FREESYS2			,0x00},
+	//{R367_OFDM_FREESYS3			,0x00},
+	//{R367_OFDM_GPIO_CFG			,0x55},
+	//{R367_OFDM_GPIO_CMD			,0x00},
+	{R367_OFDM_AGC2MAX				,0xff},
+	{R367_OFDM_AGC2MIN				,0x00},
+	{R367_OFDM_AGC1MAX				,0xff},
+	{R367_OFDM_AGC1MIN				,0x00},
+	{R367_OFDM_AGCR					,0xbc},
+	{R367_OFDM_AGC2TH				,0x00},
+	//{R367_OFDM_AGC12C				,0x01}, //Note: This defines AGC pins, also needed for QAM
+	{R367_OFDM_AGCCTRL1			,0x85},
+	{R367_OFDM_AGCCTRL2			,0x1f},
+	{R367_OFDM_AGC1VAL1			,0x00},
+	{R367_OFDM_AGC1VAL2			,0x00},
+	{R367_OFDM_AGC2VAL1			,0x6f},
+	{R367_OFDM_AGC2VAL2			,0x05},
+	{R367_OFDM_AGC2PGA				,0x00},
+	{R367_OFDM_OVF_RATE1			,0x00},
+	{R367_OFDM_OVF_RATE2			,0x00},
+	{R367_OFDM_GAIN_SRC1			,0x2b},
+	{R367_OFDM_GAIN_SRC2			,0x04},
+	{R367_OFDM_INC_DEROT1			,0x55},
+	{R367_OFDM_INC_DEROT2			,0x55},
+	{R367_OFDM_PPM_CPAMP_DIR		,0x2c},
+	{R367_OFDM_PPM_CPAMP_INV		,0x00},
+	{R367_OFDM_FREESTFE_1			,0x00},
+	{R367_OFDM_FREESTFE_2			,0x1c},
+	{R367_OFDM_DCOFFSET			,0x00},
+	{R367_OFDM_EN_PROCESS			,0x05},
+	{R367_OFDM_SDI_SMOOTHER		,0x80},
+	{R367_OFDM_FE_LOOP_OPEN		,0x1c},
+	{R367_OFDM_FREQOFF1			,0x00},
+	{R367_OFDM_FREQOFF2			,0x00},
+	{R367_OFDM_FREQOFF3			,0x00},
+	{R367_OFDM_TIMOFF1				,0x00},
+	{R367_OFDM_TIMOFF2				,0x00},
+	{R367_OFDM_EPQ					,0x02},
+	{R367_OFDM_EPQAUTO				,0x01},
+	{R367_OFDM_SYR_UPDATE			,0xf5},
+	{R367_OFDM_CHPFREE						,0x00},
+	{R367_OFDM_PPM_STATE_MAC		      ,0x23},
+	{R367_OFDM_INR_THRESHOLD		      ,0xff},
+	{R367_OFDM_EPQ_TPS_ID_CELL	      ,0xf9},
+	{R367_OFDM_EPQ_CFG				      ,0x00},
+	{R367_OFDM_EPQ_STATUS			      ,0x01},
+	{R367_OFDM_AUTORELOCK			      ,0x81},
+	{R367_OFDM_BER_THR_VMSB		      ,0x00},
+	{R367_OFDM_BER_THR_MSB		      ,0x00},
+	{R367_OFDM_BER_THR_LSB		      ,0x00},
+	{R367_OFDM_CCD					      ,0x83},
+	{R367_OFDM_SPECTR_CFG			      ,0x00},
+	{R367_OFDM_CHC_DUMMY			      ,0x18},
+	{R367_OFDM_INC_CTL				      ,0x88},
+	{R367_OFDM_INCTHRES_COR1		      ,0xb4},
+	{R367_OFDM_INCTHRES_COR2		      ,0x96},
+	{R367_OFDM_INCTHRES_DET1		      ,0x0e},
+	{R367_OFDM_INCTHRES_DET2		      ,0x11},
+	{R367_OFDM_IIR_CELLNB				   ,0x8d},
+	{R367_OFDM_IIRCX_COEFF1_MSB	      ,0x00},
+	{R367_OFDM_IIRCX_COEFF1_LSB	      ,0x00},
+	{R367_OFDM_IIRCX_COEFF2_MSB	      ,0x09},
+	{R367_OFDM_IIRCX_COEFF2_LSB	      ,0x18},
+	{R367_OFDM_IIRCX_COEFF3_MSB	      ,0x14},
+	{R367_OFDM_IIRCX_COEFF3_LSB	      ,0x9c},
+	{R367_OFDM_IIRCX_COEFF4_MSB	      ,0x00},
+	{R367_OFDM_IIRCX_COEFF4_LSB	      ,0x00},
+	{R367_OFDM_IIRCX_COEFF5_MSB	      ,0x36},
+	{R367_OFDM_IIRCX_COEFF5_LSB			,0x42},
+	{R367_OFDM_FEPATH_CFG			      ,0x00},
+	{R367_OFDM_PMC1_FUNC			      ,0x65},
+	{R367_OFDM_PMC1_FOR			      ,0x00},
+	{R367_OFDM_PMC2_FUNC			      ,0x00},
+	{R367_OFDM_STATUS_ERR_DA		      ,0xe0},
+	{R367_OFDM_DIG_AGC_R			      ,0xfe},
+	{R367_OFDM_COMAGC_TARMSB		      ,0x0b},
+	{R367_OFDM_COM_AGC_TAR_ENMODE     ,0x41},
+	{R367_OFDM_COM_AGC_CFG			   ,0x3e},
+	{R367_OFDM_COM_AGC_GAIN1				,0x39},
+	{R367_OFDM_AUT_AGC_TARGETMSB	   ,0x0b},
+	{R367_OFDM_LOCK_DET_MSB			   ,0x01},
+	{R367_OFDM_AGCTAR_LOCK_LSBS		   ,0x40},
+	{R367_OFDM_AUT_GAIN_EN		      ,0xf4},
+	{R367_OFDM_AUT_CFG				      ,0xf0},
+	{R367_OFDM_LOCKN				      ,0x23},
+	{R367_OFDM_INT_X_3				      ,0x00},
+	{R367_OFDM_INT_X_2				      ,0x03},
+	{R367_OFDM_INT_X_1				      ,0x8d},
+	{R367_OFDM_INT_X_0				      ,0xa0},
+	{R367_OFDM_MIN_ERRX_MSB		      ,0x00},
+	{R367_OFDM_COR_CTL				      ,0x00},
+	{R367_OFDM_COR_STAT			      ,0xf6},
+	{R367_OFDM_COR_INTEN			      ,0x00},
+	{R367_OFDM_COR_INTSTAT		      ,0x3f},
+	{R367_OFDM_COR_MODEGUARD		      ,0x03},
+	{R367_OFDM_AGC_CTL				      ,0x08},
+	{R367_OFDM_AGC_MANUAL1		      ,0x00},
+	{R367_OFDM_AGC_MANUAL2		      ,0x00},
+	{R367_OFDM_AGC_TARG			      ,0x16},
+	{R367_OFDM_AGC_GAIN1			      ,0x53},
+	{R367_OFDM_AGC_GAIN2			      ,0x1d},
+	{R367_OFDM_RESERVED_1			      ,0x00},
+	{R367_OFDM_RESERVED_2			      ,0x00},
+	{R367_OFDM_RESERVED_3			      ,0x00},
+	{R367_OFDM_CAS_CTL				      ,0x44},
+	{R367_OFDM_CAS_FREQ			      ,0xb3},
+	{R367_OFDM_CAS_DAGCGAIN		      ,0x12},
+	{R367_OFDM_SYR_CTL				      ,0x04},
+	{R367_OFDM_SYR_STAT			      ,0x10},
+	{R367_OFDM_SYR_NCO1			      ,0x00},
+	{R367_OFDM_SYR_NCO2			      ,0x00},
+	{R367_OFDM_SYR_OFFSET1		      ,0x00},
+	{R367_OFDM_SYR_OFFSET2		      ,0x00},
+	{R367_OFDM_FFT_CTL				      ,0x00},
+	{R367_OFDM_SCR_CTL				      ,0x70},
+	{R367_OFDM_PPM_CTL1			      ,0xf8},
+	{R367_OFDM_TRL_CTL				      ,0xac},
+	{R367_OFDM_TRL_NOMRATE1		      ,0x1e},
+	{R367_OFDM_TRL_NOMRATE2		      ,0x58},
+	{R367_OFDM_TRL_TIME1			      ,0x1d},
+	{R367_OFDM_TRL_TIME2			      ,0xfc},
+	{R367_OFDM_CRL_CTL				      ,0x24},
+	{R367_OFDM_CRL_FREQ1			      ,0xad},
+	{R367_OFDM_CRL_FREQ2			      ,0x9d},
+	{R367_OFDM_CRL_FREQ3			      ,0xff},
+	{R367_OFDM_CHC_CTL		       ,0x01},
+	{R367_OFDM_CHC_SNR				      ,0xf0},
+	{R367_OFDM_BDI_CTL				      ,0x00},
+	{R367_OFDM_DMP_CTL				      ,0x00},
+	{R367_OFDM_TPS_RCVD1			      ,0x30},
+	{R367_OFDM_TPS_RCVD2			      ,0x02},
+	{R367_OFDM_TPS_RCVD3			      ,0x01},
+	{R367_OFDM_TPS_RCVD4			      ,0x00},
+	{R367_OFDM_TPS_ID_CELL1		      ,0x00},
+	{R367_OFDM_TPS_ID_CELL2		      ,0x00},
+	{R367_OFDM_TPS_RCVD5_SET1	      ,0x02},
+	{R367_OFDM_TPS_SET2			      ,0x02},
+	{R367_OFDM_TPS_SET3			      ,0x01},
+	{R367_OFDM_TPS_CTL				      ,0x00},
+	{R367_OFDM_CTL_FFTOSNUM		      ,0x34},
+	{R367_OFDM_TESTSELECT			      ,0x09},
+	{R367_OFDM_MSC_REV 			      ,0x0a},
+	{R367_OFDM_PIR_CTL 			      ,0x00},
+	{R367_OFDM_SNR_CARRIER1 		      ,0xa1},
+	{R367_OFDM_SNR_CARRIER2		      ,0x9a},
+	{R367_OFDM_PPM_CPAMP			      ,0x2c},
+	{R367_OFDM_TSM_AP0				      ,0x00},
+	{R367_OFDM_TSM_AP1				      ,0x00},
+	{R367_OFDM_TSM_AP2 			      ,0x00},
+	{R367_OFDM_TSM_AP3				      ,0x00},
+	{R367_OFDM_TSM_AP4				      ,0x00},
+	{R367_OFDM_TSM_AP5				      ,0x00},
+	{R367_OFDM_TSM_AP6				      ,0x00},
+	{R367_OFDM_TSM_AP7				      ,0x00},
+	//{R367_OFDM_TSTRES				 ,0x00},
+	//{R367_OFDM_ANACTRL				 ,0x0D},/*caution PLL stopped, to be restarted at init!!!*/
+	//{R367_OFDM_TSTBUS				      ,0x00},
+	//{R367_OFDM_TSTRATE				      ,0x00},
+	{R367_OFDM_CONSTMODE			      ,0x01},
+	{R367_OFDM_CONSTCARR1			      ,0x00},
+	{R367_OFDM_CONSTCARR2			      ,0x00},
+	{R367_OFDM_ICONSTEL			      ,0x0a},
+	{R367_OFDM_QCONSTEL			      ,0x15},
+	{R367_OFDM_TSTBISTRES0		      ,0x00},
+	{R367_OFDM_TSTBISTRES1		      ,0x00},
+	{R367_OFDM_TSTBISTRES2		      ,0x28},
+	{R367_OFDM_TSTBISTRES3		      ,0x00},
+	//{R367_OFDM_RF_AGC1				      ,0xff},
+	//{R367_OFDM_RF_AGC2				      ,0x83},
+	//{R367_OFDM_ANADIGCTRL			      ,0x19},
+	//{R367_OFDM_PLLMDIV				      ,0x0c},
+	//{R367_OFDM_PLLNDIV				      ,0x55},
+	//{R367_OFDM_PLLSETUP			      ,0x18},
+	//{R367_OFDM_DUAL_AD12			      ,0x00},
+	//{R367_OFDM_TSTBIST				      ,0x00},
+	//{R367_OFDM_PAD_COMP_CTRL		      ,0x00},
+	//{R367_OFDM_PAD_COMP_WR		      ,0x00},
+	//{R367_OFDM_PAD_COMP_RD		      ,0xe0},
+	{R367_OFDM_SYR_TARGET_FFTADJT_MSB	,0x00},
+	{R367_OFDM_SYR_TARGET_FFTADJT_LSB ,0x00},
+	{R367_OFDM_SYR_TARGET_CHCADJT_MSB ,0x00},
+	{R367_OFDM_SYR_TARGET_CHCADJT_LSB ,0x00},
+	{R367_OFDM_SYR_FLAG			 ,0x00},
+	{R367_OFDM_CRL_TARGET1		 ,0x00},
+	{R367_OFDM_CRL_TARGET2		 ,0x00},
+	{R367_OFDM_CRL_TARGET3		 ,0x00},
+	{R367_OFDM_CRL_TARGET4		 ,0x00},
+	{R367_OFDM_CRL_FLAG			 ,0x00},
+	{R367_OFDM_TRL_TARGET1		 ,0x00},
+	{R367_OFDM_TRL_TARGET2		 ,0x00},
+	{R367_OFDM_TRL_CHC				 ,0x00},
+	{R367_OFDM_CHC_SNR_TARG		 ,0x00},
+	{R367_OFDM_TOP_TRACK			      ,0x00},
+	{R367_OFDM_TRACKER_FREE1		 ,0x00},
+	{R367_OFDM_ERROR_CRL1			 ,0x00},
+	{R367_OFDM_ERROR_CRL2			 ,0x00},
+	{R367_OFDM_ERROR_CRL3			 ,0x00},
+	{R367_OFDM_ERROR_CRL4			 ,0x00},
+	{R367_OFDM_DEC_NCO1			 ,0x2c},
+	{R367_OFDM_DEC_NCO2			 ,0x0f},
+	{R367_OFDM_DEC_NCO3			 ,0x20},
+	{R367_OFDM_SNR					 ,0xf1},
+	{R367_OFDM_SYR_FFTADJ1		      ,0x00},
+	{R367_OFDM_SYR_FFTADJ2		 ,0x00},
+	{R367_OFDM_SYR_CHCADJ1		 ,0x00},
+	{R367_OFDM_SYR_CHCADJ2		 ,0x00},
+	{R367_OFDM_SYR_OFF				 ,0x00},
+	{R367_OFDM_PPM_OFFSET1		      ,0x00},
+	{R367_OFDM_PPM_OFFSET2		 ,0x03},
+	{R367_OFDM_TRACKER_FREE2		 ,0x00},
+	{R367_OFDM_DEBG_LT10			 ,0x00},
+	{R367_OFDM_DEBG_LT11			 ,0x00},
+	{R367_OFDM_DEBG_LT12			      ,0x00},
+	{R367_OFDM_DEBG_LT13			 ,0x00},
+	{R367_OFDM_DEBG_LT14			 ,0x00},
+	{R367_OFDM_DEBG_LT15			 ,0x00},
+	{R367_OFDM_DEBG_LT16			 ,0x00},
+	{R367_OFDM_DEBG_LT17			 ,0x00},
+	{R367_OFDM_DEBG_LT18			 ,0x00},
+	{R367_OFDM_DEBG_LT19			 ,0x00},
+	{R367_OFDM_DEBG_LT1A			 ,0x00},
+	{R367_OFDM_DEBG_LT1B			 ,0x00},
+	{R367_OFDM_DEBG_LT1C 			 ,0x00},
+	{R367_OFDM_DEBG_LT1D 			 ,0x00},
+	{R367_OFDM_DEBG_LT1E			 ,0x00},
+	{R367_OFDM_DEBG_LT1F			 ,0x00},
+	{R367_OFDM_RCCFGH				 ,0x00},
+	{R367_OFDM_RCCFGM						,0x00},
+	{R367_OFDM_RCCFGL						,0x00},
+	{R367_OFDM_RCINSDELH					,0x00},
+	{R367_OFDM_RCINSDELM			 ,0x00},
+	{R367_OFDM_RCINSDELL			 ,0x00},
+	{R367_OFDM_RCSTATUS			 ,0x00},
+	{R367_OFDM_RCSPEED 			 ,0x6f},
+	{R367_OFDM_RCDEBUGM			 ,0xe7},
+	{R367_OFDM_RCDEBUGL			 ,0x9b},
+	{R367_OFDM_RCOBSCFG			 ,0x00},
+	{R367_OFDM_RCOBSM 				 ,0x00},
+	{R367_OFDM_RCOBSL 				 ,0x00},
+	{R367_OFDM_RCFECSPY			 ,0x00},
+	{R367_OFDM_RCFSPYCFG 			 ,0x00},
+	{R367_OFDM_RCFSPYDATA			 ,0x00},
+	{R367_OFDM_RCFSPYOUT 			 ,0x00},
+	{R367_OFDM_RCFSTATUS 			 ,0x00},
+	{R367_OFDM_RCFGOODPACK		 ,0x00},
+	{R367_OFDM_RCFPACKCNT 		 ,0x00},
+	{R367_OFDM_RCFSPYMISC 		 ,0x00},
+	{R367_OFDM_RCFBERCPT4 		 ,0x00},
+	{R367_OFDM_RCFBERCPT3 		 ,0x00},
+	{R367_OFDM_RCFBERCPT2 		 ,0x00},
+	{R367_OFDM_RCFBERCPT1 		 ,0x00},
+	{R367_OFDM_RCFBERCPT0 		 ,0x00},
+	{R367_OFDM_RCFBERERR2 		 ,0x00},
+	{R367_OFDM_RCFBERERR1 		 ,0x00},
+	{R367_OFDM_RCFBERERR0 		 ,0x00},
+	{R367_OFDM_RCFSTATESM 		 ,0x00},
+	{R367_OFDM_RCFSTATESL 		 ,0x00},
+	{R367_OFDM_RCFSPYBER  		 ,0x00},
+	{R367_OFDM_RCFSPYDISTM		 ,0x00},
+	{R367_OFDM_RCFSPYDISTL		 ,0x00},
+	{R367_OFDM_RCFSPYOBS7 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS6 		      ,0x00},
+	{R367_OFDM_RCFSPYOBS5 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS4 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS3 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS2 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS1 		 ,0x00},
+	{R367_OFDM_RCFSPYOBS0			 ,0x00},
+	//{R367_OFDM_TSGENERAL 			 ,0x00},
+	//{R367_OFDM_RC1SPEED  			 ,0x6f},
+	//{R367_OFDM_TSGSTATUS			 ,0x18},
+	{R367_OFDM_FECM					 ,0x01},
+	{R367_OFDM_VTH12				 ,0xff},
+	{R367_OFDM_VTH23				 ,0xa1},
+	{R367_OFDM_VTH34				 ,0x64},
+	{R367_OFDM_VTH56				 ,0x40},
+	{R367_OFDM_VTH67				 ,0x00},
+	{R367_OFDM_VTH78				 ,0x2c},
+	{R367_OFDM_VITCURPUN			 ,0x12},
+	{R367_OFDM_VERROR				 ,0x01},
+	{R367_OFDM_PRVIT				 ,0x3f},
+	{R367_OFDM_VAVSRVIT			 ,0x00},
+	{R367_OFDM_VSTATUSVIT			 ,0xbd},
+	{R367_OFDM_VTHINUSE 			 ,0xa1},
+	{R367_OFDM_KDIV12				 ,0x20},
+	{R367_OFDM_KDIV23				 ,0x40},
+	{R367_OFDM_KDIV34				 ,0x20},
+	{R367_OFDM_KDIV56				 ,0x30},
+	{R367_OFDM_KDIV67				 ,0x00},
+	{R367_OFDM_KDIV78				 ,0x30},
+	{R367_OFDM_SIGPOWER 			 ,0x54},
+	{R367_OFDM_DEMAPVIT 			 ,0x40},
+	{R367_OFDM_VITSCALE 			 ,0x00},
+	{R367_OFDM_FFEC1PRG 			 ,0x00},
+	{R367_OFDM_FVITCURPUN 		 ,0x12},
+	{R367_OFDM_FVERROR 			 ,0x01},
+	{R367_OFDM_FVSTATUSVIT		 ,0xbd},
+	{R367_OFDM_DEBUG_LT1			 ,0x00},
+	{R367_OFDM_DEBUG_LT2			 ,0x00},
+	{R367_OFDM_DEBUG_LT3			 ,0x00},
+	{R367_OFDM_TSTSFMET  			 ,0x00},
+	{R367_OFDM_SELOUT				 ,0x00},
+	{R367_OFDM_TSYNC				 ,0x00},
+	{R367_OFDM_TSTERR				 ,0x00},
+	{R367_OFDM_TSFSYNC   			 ,0x00},
+	{R367_OFDM_TSTSFERR  			 ,0x00},
+	{R367_OFDM_TSTTSSF1  			 ,0x01},
+	{R367_OFDM_TSTTSSF2  			 ,0x1f},
+	{R367_OFDM_TSTTSSF3  			 ,0x00},
+	{R367_OFDM_TSTTS1   			 ,0x00},
+	{R367_OFDM_TSTTS2   			      ,0x1f},
+	{R367_OFDM_TSTTS3   			 ,0x01},
+	{R367_OFDM_TSTTS4   			 ,0x00},
+	{R367_OFDM_TSTTSRC  			 ,0x00},
+	{R367_OFDM_TSTTSRS  			 ,0x00},
+	{R367_OFDM_TSSTATEM			 ,0xb0},
+	{R367_OFDM_TSSTATEL			 ,0x40},
+	{R367_OFDM_TSCFGH  			 ,0x80},
+	{R367_OFDM_TSCFGM  			 ,0x00},
+	{R367_OFDM_TSCFGL  			 ,0x20},
+	{R367_OFDM_TSSYNC  			 ,0x00},
+	{R367_OFDM_TSINSDELH			 ,0x00},
+	{R367_OFDM_TSINSDELM 			 ,0x00},
+	{R367_OFDM_TSINSDELL			 ,0x00},
+	{R367_OFDM_TSDIVN				 ,0x03},
+	{R367_OFDM_TSDIVPM				 ,0x00},
+	{R367_OFDM_TSDIVPL				 ,0x00},
+	{R367_OFDM_TSDIVQM 			 ,0x00},
+	{R367_OFDM_TSDIVQL				 ,0x00},
+	{R367_OFDM_TSDILSTKM			 ,0x00},
+	{R367_OFDM_TSDILSTKL			 ,0x00},
+	{R367_OFDM_TSSPEED				 ,0x6f},
+	{R367_OFDM_TSSTATUS			 ,0x81},
+	{R367_OFDM_TSSTATUS2			 ,0x6a},
+	{R367_OFDM_TSBITRATEM			 ,0x0f},
+	{R367_OFDM_TSBITRATEL			 ,0xc6},
+	{R367_OFDM_TSPACKLENM			 ,0x00},
+	{R367_OFDM_TSPACKLENL			 ,0xfc},
+	{R367_OFDM_TSBLOCLENM			 ,0x0a},
+	{R367_OFDM_TSBLOCLENL			 ,0x80},
+	{R367_OFDM_TSDLYH 				 ,0x90},
+	{R367_OFDM_TSDLYM				 ,0x68},
+	{R367_OFDM_TSDLYL				 ,0x01},
+	{R367_OFDM_TSNPDAV				 ,0x00},
+	{R367_OFDM_TSBUFSTATH 		 ,0x00},
+	{R367_OFDM_TSBUFSTATM 		 ,0x00},
+	{R367_OFDM_TSBUFSTATL			 ,0x00},
+	{R367_OFDM_TSDEBUGM			 ,0xcf},
+	{R367_OFDM_TSDEBUGL			 ,0x1e},
+	{R367_OFDM_TSDLYSETH 			 ,0x00},
+	{R367_OFDM_TSDLYSETM			 ,0x68},
+	{R367_OFDM_TSDLYSETL			 ,0x00},
+	{R367_OFDM_TSOBSCFG			 ,0x00},
+	{R367_OFDM_TSOBSM 				 ,0x47},
+	{R367_OFDM_TSOBSL				 ,0x1f},
+	{R367_OFDM_ERRCTRL1			 ,0x95},
+	{R367_OFDM_ERRCNT1H 			 ,0x80},
+	{R367_OFDM_ERRCNT1M 			 ,0x00},
+	{R367_OFDM_ERRCNT1L 			 ,0x00},
+	{R367_OFDM_ERRCTRL2			 ,0x95},
+	{R367_OFDM_ERRCNT2H			 ,0x00},
+	{R367_OFDM_ERRCNT2M			 ,0x00},
+	{R367_OFDM_ERRCNT2L			 ,0x00},
+	{R367_OFDM_FECSPY 				 ,0x88},
+	{R367_OFDM_FSPYCFG				 ,0x2c},
+	{R367_OFDM_FSPYDATA			 ,0x3a},
+	{R367_OFDM_FSPYOUT				 ,0x06},
+	{R367_OFDM_FSTATUS				 ,0x61},
+	{R367_OFDM_FGOODPACK			 ,0xff},
+	{R367_OFDM_FPACKCNT			 ,0xff},
+	{R367_OFDM_FSPYMISC 			 ,0x66},
+	{R367_OFDM_FBERCPT4 			 ,0x00},
+	{R367_OFDM_FBERCPT3			 ,0x00},
+	{R367_OFDM_FBERCPT2			 ,0x36},
+	{R367_OFDM_FBERCPT1			 ,0x36},
+	{R367_OFDM_FBERCPT0 			 ,0x14},
+	{R367_OFDM_FBERERR2			 ,0x00},
+	{R367_OFDM_FBERERR1			 ,0x03},
+	{R367_OFDM_FBERERR0			 ,0x28},
+	{R367_OFDM_FSTATESM			 ,0x00},
+	{R367_OFDM_FSTATESL			 ,0x02},
+	{R367_OFDM_FSPYBER 			 ,0x00},
+	{R367_OFDM_FSPYDISTM			 ,0x01},
+	{R367_OFDM_FSPYDISTL			 ,0x9f},
+	{R367_OFDM_FSPYOBS7 			 ,0xc9},
+	{R367_OFDM_FSPYOBS6 			 ,0x99},
+	{R367_OFDM_FSPYOBS5			 ,0x08},
+	{R367_OFDM_FSPYOBS4			 ,0xec},
+	{R367_OFDM_FSPYOBS3			 ,0x01},
+	{R367_OFDM_FSPYOBS2			 ,0x0f},
+	{R367_OFDM_FSPYOBS1			 ,0xf5},
+	{R367_OFDM_FSPYOBS0			 ,0x08},
+	{R367_OFDM_SFDEMAP 			 ,0x40},
+	{R367_OFDM_SFERROR 			 ,0x00},
+	{R367_OFDM_SFAVSR  			 ,0x30},
+	{R367_OFDM_SFECSTATUS			 ,0xcc},
+	{R367_OFDM_SFKDIV12			 ,0x20},
+	{R367_OFDM_SFKDIV23			 ,0x40},
+	{R367_OFDM_SFKDIV34			 ,0x20},
+	{R367_OFDM_SFKDIV56			 ,0x20},
+	{R367_OFDM_SFKDIV67			 ,0x00},
+	{R367_OFDM_SFKDIV78			 ,0x20},
+	{R367_OFDM_SFDILSTKM			 ,0x00},
+	{R367_OFDM_SFDILSTKL 			 ,0x00},
+	{R367_OFDM_SFSTATUS			 ,0xb5},
+	{R367_OFDM_SFDLYH				 ,0x90},
+	{R367_OFDM_SFDLYM				 ,0x60},
+	{R367_OFDM_SFDLYL				 ,0x01},
+	{R367_OFDM_SFDLYSETH			 ,0xc0},
+	{R367_OFDM_SFDLYSETM			 ,0x60},
+	{R367_OFDM_SFDLYSETL			 ,0x00},
+	{R367_OFDM_SFOBSCFG 			 ,0x00},
+	{R367_OFDM_SFOBSM 				 ,0x47},
+	{R367_OFDM_SFOBSL				 ,0x05},
+	{R367_OFDM_SFECINFO 			 ,0x40},
+	{R367_OFDM_SFERRCTRL 			 ,0x74},
+	{R367_OFDM_SFERRCNTH			 ,0x80},
+	{R367_OFDM_SFERRCNTM 			 ,0x00},
+	{R367_OFDM_SFERRCNTL			 ,0x00},
+	{R367_OFDM_SYMBRATEM			 ,0x2f},
+	{R367_OFDM_SYMBRATEL			      ,0x50},
+	{R367_OFDM_SYMBSTATUS			 ,0x7f},
+	{R367_OFDM_SYMBCFG 			 ,0x00},
+	{R367_OFDM_SYMBFIFOM 			 ,0xf4},
+	{R367_OFDM_SYMBFIFOL 			 ,0x0d},
+	{R367_OFDM_SYMBOFFSM 			 ,0xf0},
+	{R367_OFDM_SYMBOFFSL 			 ,0x2d},
+	//{R367_OFDM_DEBUG_LT4			 ,0x00},
+	//{R367_OFDM_DEBUG_LT5			 ,0x00},
+	//{R367_OFDM_DEBUG_LT6			 ,0x00},
+	//{R367_OFDM_DEBUG_LT7			 ,0x00},
+	//{R367_OFDM_DEBUG_LT8			 ,0x00},
+	//{R367_OFDM_DEBUG_LT9			 ,0x00},
+	{ 0x0000, 0x00 } // EOT
+};
+
+inline u32 MulDiv32(u32 a, u32 b, u32 c)
+{
+	u64 tmp64;
+
+	tmp64 = (u64)a * (u64)b;
+	do_div(tmp64, c);
+
+	return (u32) tmp64;
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg =
+		{.addr = adr, .flags = 0, .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		printk("stv0367: i2c_write error\n");
+		return -1;
+	}
+	return 0;
+}
+
+#if 0
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
+				     .buf = msg, .len = len},
+				   { .addr = adr, .flags = I2C_M_RD,
+				     .buf = answ, .len = alen } };
+	if (i2c_transfer(adap, msgs, 2) != 2) {
+		printk("stv0367: i2c_read error\n");
+		return -1;
+	}
+	return 0;
+}
+#endif
+
+static int writereg(struct stv_state *state, u16 reg, u8 dat)
+{
+	u8 mm[3] = { (reg >> 8), reg & 0xff, dat };
+
+	return i2c_write(state->i2c, state->adr, mm, 3);
+}
+
+static int readreg(struct stv_state *state, u16 reg, u8 *val)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = state->adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = state->adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = 1}};
+	return (i2c_transfer(state->i2c, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int readregs(struct stv_state *state, u16 reg, u8 *val, int count)
+{
+	u8 msg[2] = {reg >> 8, reg & 0xff};
+	struct i2c_msg msgs[2] = {{.addr = state->adr, .flags = 0,
+				   .buf  = msg, .len   = 2},
+				  {.addr = state->adr, .flags = I2C_M_RD,
+				   .buf  = val, .len   = count}};
+	return (i2c_transfer(state->i2c, msgs, 2) == 2) ? 0 : -1;
+}
+
+static int write_init_table(struct stv_state *state, struct init_table *tab)
+{
+	while (1) {
+		if (!tab->adr)
+			break;
+		if (writereg(state, tab->adr, tab->data) < 0)
+			return -1;
+		tab++;
+	}
+	return 0;
+}
+
+static int qam_set_modulation(struct stv_state *state)
+{
+	int stat = 0;
+
+	switch(state->modulation) {
+	case QAM_16:
+		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM16 );
+		writereg(state, R367_QAM_AGC_PWR_REF_L,0x64);       /* Set analog AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);   /* Set digital AGC reference */
+		writereg(state, R367_QAM_FSM_STATE,0x90);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x95);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN,0x8a);
+		break;
+	case QAM_32:
+		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM32 );
+		writereg(state, R367_QAM_AGC_PWR_REF_L,0x6e);       /* Set analog AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);   /* Set digital AGC reference */
+		writereg(state, R367_QAM_FSM_STATE,0xb0);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xb7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x9d);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x7f);
+		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
+		break;
+	case QAM_64:
+		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM64 );
+		writereg(state, R367_QAM_AGC_PWR_REF_L,0x5a);       /* Set analog AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x82);   /* Set digital AGC reference */
+		if(state->symbol_rate>4500000)
+		{
+			writereg(state, R367_QAM_FSM_STATE,0xb0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa5);
+		}
+		else if(state->symbol_rate>2500000) // 25000000
+		{
+			writereg(state, R367_QAM_FSM_STATE,0xa0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa6);
+		}
+		else
+		{
+			writereg(state, R367_QAM_FSM_STATE,0xa0);
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xd1);
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x95);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN,0x99);
+		break;
+	case QAM_128:
+		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM128 );
+		writereg(state, R367_QAM_AGC_PWR_REF_L,0x76);       /* Set analog AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x00);	/* Set digital AGC reference */
+		writereg(state, R367_QAM_FSM_STATE,0x90);
+		writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xb1);
+		if(state->symbol_rate>4500000) // 45000000
+		{
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
+		}
+		else if(state->symbol_rate>2500000) // 25000000
+		{
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa6);
+		}
+		else
+		{
+			writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0x97);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x8e);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x7f);
+		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
+		break;
+	case QAM_256:
+		writereg(state, R367_QAM_EQU_MAPPER,state->qam_inversion | QAM_MOD_QAM256 );
+		writereg(state, R367_QAM_AGC_PWR_REF_L,0x5a);     /* Set analog AGC reference */
+		writereg(state, R367_QAM_IQDEM_ADJ_AGC_REF,0x94); /* Set digital AGC reference */
+		writereg(state, R367_QAM_FSM_STATE,0xa0);
+		if(state->symbol_rate>4500000) // 45000000
+		{
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+		}
+		else if(state->symbol_rate>2500000) // 25000000
+		{
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xc1);
+		}
+		else
+		{
+			writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,0xd1);
+		}
+		writereg(state, R367_QAM_EQU_CRL_LPF_GAIN,0xa7);
+		writereg(state, R367_QAM_EQU_CRL_LD_SEN,0x85);
+		writereg(state, R367_QAM_EQU_CRL_LIMITER,0x40);
+		writereg(state, R367_QAM_EQU_PNT_GAIN,0xa7);
+		break;
+	default:
+		stat = -EINVAL;
+		break;
+	}
+	return stat;
+}
+
+
+static int QAM_SetSymbolRate(struct stv_state *state)
+{
+	int status = 0;
+	u32 sr = state->symbol_rate;
+	u32 Corr = 0;
+	u32 Temp, Temp1, AdpClk;
+
+	switch(state->modulation) {
+	default:
+	case QAM_16:   Corr = 1032; break;
+	case QAM_32:   Corr =  954; break;
+	case QAM_64:   Corr =  983; break;
+	case QAM_128:  Corr =  957; break;
+	case QAM_256:  Corr =  948; break;
+	}
+
+	// Transfer ration
+	Temp = (256*sr) / state->adc_clock;
+	writereg(state, R367_QAM_EQU_CRL_TFR,(Temp));
+
+	/* Symbol rate and SRC gain calculation */
+	AdpClk = (state->master_clock)/2000; /* TRL works at half the system clock */
+
+	Temp = state->symbol_rate;
+	Temp1 = sr;
+
+	if(sr < 2097152)				/* 2097152 = 2^21 */
+	{
+		Temp  = ((((sr * 2048) / AdpClk) * 16384 ) / 125 ) * 8;
+		Temp1 = (((((sr * 2048) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 10000000;
+	}
+	else if(sr < 4194304)			/* 4194304 = 2**22 */
+	{
+		Temp  = ((((sr * 1024) / AdpClk) * 16384 ) / 125 ) * 16;
+		Temp1 = (((((sr * 1024) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 5000000;
+	}
+	else if(sr < 8388608)			/* 8388608 = 2**23 */
+	{
+		Temp  = ((((sr * 512) / AdpClk) * 16384 ) / 125 ) * 32;
+		Temp1 = (((((sr * 512) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 2500000;
+	}
+	else
+	{
+		Temp  = ((((sr * 256) / AdpClk) * 16384 ) / 125 ) * 64;
+		Temp1 = (((((sr * 256) / 439 ) * 256 ) / AdpClk ) * Corr * 9 ) / 1250000;
+	}
+
+	///* Filters' coefficients are calculated and written into registers only if the filters are enabled */
+	//if (ChipGetField(hChip,F367qam_ADJ_EN)) // Is disabled from init!
+	//{
+	//    FE_367qam_SetIirAdjacentcoefficient(hChip, MasterClk_Hz, SymbolRate);
+	//}
+	///* AllPass filter is never used on this IC */
+	//ChipSetField(hChip,F367qam_ALLPASSFILT_EN,0); // should be disabled from init!
+
+	writereg(state, R367_QAM_SRC_NCO_LL,(Temp));
+	writereg(state, R367_QAM_SRC_NCO_LH,(Temp>>8));
+	writereg(state, R367_QAM_SRC_NCO_HL,(Temp>>16));
+	writereg(state, R367_QAM_SRC_NCO_HH,(Temp>>24));
+
+	writereg(state, R367_QAM_IQDEM_GAIN_SRC_L,(Temp1));
+	writereg(state, R367_QAM_IQDEM_GAIN_SRC_H,(Temp1>>8));
+	return status;
+}
+
+
+static int QAM_SetDerotFrequency(struct stv_state *state, u32 DerotFrequency)
+{
+	int status = 0;
+	u32 Sampled_IF;
+
+	do {
+		//if (DerotFrequency < 1000000)
+		//    DerotFrequency = state->adc_clock/4; /* ZIF operation */
+		if (DerotFrequency > state->adc_clock)
+			DerotFrequency = DerotFrequency - state->adc_clock;	// User Alias
+
+		Sampled_IF = ((32768 * (DerotFrequency/1000)) / (state->adc_clock/1000)) * 256;
+		if(Sampled_IF > 8388607)
+			Sampled_IF = 8388607;
+
+		writereg(state, R367_QAM_MIX_NCO_LL, (Sampled_IF));
+		writereg(state, R367_QAM_MIX_NCO_HL, (Sampled_IF>>8));
+		writereg(state, R367_QAM_MIX_NCO_HH, (Sampled_IF>>16));
+	} while(0);
+
+	return status;
+}
+
+
+
+static int QAM_Start(struct stv_state *state, s32 offsetFreq,s32 IntermediateFrequency)
+{
+	int status = 0;
+	u32 AGCTimeOut = 25;
+	u32 TRLTimeOut = 100000000 / state->symbol_rate;
+	u32 CRLSymbols = 0;
+	u32 EQLTimeOut = 100;
+	u32 SearchRange = state->symbol_rate / 25;
+	u32 CRLTimeOut;
+	u8 Temp;
+
+	if( state->demod_state != QAMSet ) {
+		writereg(state, R367_DEBUG_LT4,0x00);
+		writereg(state, R367_DEBUG_LT5,0x01);
+		writereg(state, R367_DEBUG_LT6,0x06);// R367_QAM_CTRL_1
+		writereg(state, R367_DEBUG_LT7,0x03);// R367_QAM_CTRL_2
+		writereg(state, R367_DEBUG_LT8,0x00);
+		writereg(state, R367_DEBUG_LT9,0x00);
+
+		// Tuner Setup
+		writereg(state, R367_ANADIGCTRL,0x8B); /* Buffer Q disabled, I Enabled, signed ADC */
+		writereg(state, R367_DUAL_AD12,0x04); /* ADCQ disabled */
+
+		// Clock setup
+		writereg(state, R367_ANACTRL,0x0D); /* PLL bypassed and disabled */
+		writereg(state, R367_TOPCTRL,0x10); // Set QAM
+
+		writereg(state, R367_PLLMDIV,27); /* IC runs at 58 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLNDIV,232);
+		writereg(state, R367_PLLSETUP,0x18);  /* ADC clock is equal to system clock */
+
+		msleep(50);
+		writereg(state, R367_ANACTRL,0x00); /* PLL enabled and used */
+
+		state->master_clock = 58000000;
+		state->adc_clock = 58000000;
+
+		state->demod_state = QAMSet;
+	}
+
+	state->m_bFirstTimeLock = true;
+	state->m_DemodLockTime  = -1;
+
+	qam_set_modulation(state);
+	QAM_SetSymbolRate(state);
+
+	// Will make problems on low symbol rates ( < 2500000 )
+
+	switch(state->modulation) {
+	default:
+	case QAM_16:   CRLSymbols = 150000; break;
+	case QAM_32:   CRLSymbols = 250000; break;
+	case QAM_64:   CRLSymbols = 200000; break;
+	case QAM_128:  CRLSymbols = 250000; break;
+	case QAM_256:  CRLSymbols = 250000; break;
+	}
+
+	CRLTimeOut = (25 * CRLSymbols * (SearchRange/1000)) / (state->symbol_rate/1000);
+	CRLTimeOut = (1000 * CRLTimeOut) / state->symbol_rate;
+	if( CRLTimeOut < 50 ) CRLTimeOut = 50;
+
+	state->m_FECTimeOut = 20;
+	state->m_DemodTimeOut = AGCTimeOut + TRLTimeOut + CRLTimeOut + EQLTimeOut;
+	state->m_SignalTimeOut = AGCTimeOut + TRLTimeOut;
+
+	// QAM_AGC_ACCUMRSTSEL = 0;
+	readreg(state, R367_QAM_AGC_CTL,&state->m_Save_QAM_AGC_CTL);
+	writereg(state, R367_QAM_AGC_CTL,state->m_Save_QAM_AGC_CTL & ~0x0F);
+
+	// QAM_MODULUSMAP_EN = 0
+	readreg(state, R367_QAM_EQU_PNT_GAIN,&Temp);
+	writereg(state, R367_QAM_EQU_PNT_GAIN,Temp & ~0x40);
+
+	// QAM_SWEEP_EN = 0
+	readreg(state, R367_QAM_EQU_CTR_LPF_GAIN,&Temp);
+	writereg(state, R367_QAM_EQU_CTR_LPF_GAIN,Temp & ~0x08);
+
+	QAM_SetDerotFrequency(state, IntermediateFrequency);
+
+	// Release TRL
+	writereg(state, R367_QAM_CTRL_1,0x00);
+
+	state->IF = IntermediateFrequency;
+	state->demod_state = QAMStarted;
+
+	return status;
+}
+
+static int OFDM_Start(struct stv_state *state, s32 offsetFreq,s32 IntermediateFrequency)
+{
+	int status = 0;
+	u8 GAIN_SRC1;
+	u32 Derot;
+	u8 SYR_CTL;
+	u8 tmp1;
+	u8 tmp2;
+
+	if ( state->demod_state != OFDMSet ) {
+		// QAM Disable
+		writereg(state, R367_DEBUG_LT4, 0x00);
+		writereg(state, R367_DEBUG_LT5, 0x00);
+		writereg(state, R367_DEBUG_LT6, 0x00);// R367_QAM_CTRL_1
+		writereg(state, R367_DEBUG_LT7, 0x00);// R367_QAM_CTRL_2
+		writereg(state, R367_DEBUG_LT8, 0x00);
+		writereg(state, R367_DEBUG_LT9, 0x00);
+
+		// Tuner Setup
+		writereg(state, R367_ANADIGCTRL, 0x89); /* Buffer Q disabled, I Enabled, unsigned ADC */
+		writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
+
+		// Clock setup
+		writereg(state, R367_ANACTRL, 0x0D); /* PLL bypassed and disabled */
+		writereg(state, R367_TOPCTRL, 0x00); // Set OFDM
+
+		writereg(state, R367_PLLMDIV, 1); /* IC runs at 54 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLNDIV, 8);
+		writereg(state, R367_PLLSETUP, 0x18);  /* ADC clock is equal to system clock */
+
+		msleep(50);
+		writereg(state, R367_ANACTRL, 0x00); /* PLL enabled and used */
+
+		state->master_clock = 54000000;
+		state->adc_clock    = 54000000;
+
+		state->demod_state = OFDMSet;
+	}
+
+	state->m_bFirstTimeLock = true;
+	state->m_DemodLockTime  = -1;
+
+	// Set inversion in GAIN_SRC1 (fixed from init)
+	//  is in GAIN_SRC1, see below
+
+	GAIN_SRC1 = 0xA0;
+	// Bandwidth
+
+	// Fixed values for 54 MHz
+	switch(state->bandwidth) {
+	case 0:
+	case 8000000:
+		// Normrate = 44384;
+		writereg(state, R367_OFDM_TRL_CTL,0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1,0xB0);
+		writereg(state, R367_OFDM_TRL_NOMRATE2,0x56);
+		// Gain SRC = 2774
+		writereg(state, R367_OFDM_GAIN_SRC1,0x0A | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2,0xD6);
+		break;
+	case 7000000:
+		// Normrate = 38836;
+		writereg(state, R367_OFDM_TRL_CTL,0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1,0xDA);
+		writereg(state, R367_OFDM_TRL_NOMRATE2,0x4B);
+		// Gain SRC = 2427
+		writereg(state, R367_OFDM_GAIN_SRC1,0x09 | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2,0x7B);
+		break;
+	case 6000000:
+		// Normrate = 33288;
+		writereg(state, R367_OFDM_TRL_CTL,0x14);
+		writereg(state, R367_OFDM_TRL_NOMRATE1,0x04);
+		writereg(state, R367_OFDM_TRL_NOMRATE2,0x41);
+		// Gain SRC = 2080
+		writereg(state, R367_OFDM_GAIN_SRC1,0x08 | GAIN_SRC1);
+		writereg(state, R367_OFDM_GAIN_SRC2,0x20);
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	Derot = ((IntermediateFrequency/1000) * 65536) / (state->master_clock / 1000);
+
+	writereg(state, R367_OFDM_INC_DEROT1,(Derot>>8));
+	writereg(state, R367_OFDM_INC_DEROT2,(Derot));
+
+	readreg(state, R367_OFDM_SYR_CTL,&SYR_CTL);
+	SYR_CTL  &= ~0x78;
+	writereg(state, R367_OFDM_SYR_CTL,SYR_CTL);    // EchoPos = 0
+
+
+	writereg(state, R367_OFDM_COR_MODEGUARD,0x03); // Force = 0, Mode = 0, Guard = 3
+	SYR_CTL &= 0x01;
+	writereg(state, R367_OFDM_SYR_CTL,SYR_CTL);    // SYR_TR_DIS = 0
+
+	msleep(5);
+
+	writereg(state, R367_OFDM_COR_CTL,0x20);    // Start core
+
+	// -- Begin M.V.
+	// Reset FEC and Read Solomon
+	readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
+	readreg(state, R367_TSGENERAL,&tmp2);
+	writereg(state, R367_OFDM_SFDLYSETH,tmp1 | 0x08);
+	writereg(state, R367_TSGENERAL,tmp2 | 0x01);
+	// -- End M.V.
+
+	state->m_SignalTimeOut = 200;
+	state->IF = IntermediateFrequency;
+	state->demod_state = OFDMStarted;
+	state->m_DemodTimeOut = 0;
+	state->m_FECTimeOut = 0;
+	state->m_TSTimeOut = 0;
+
+	return status;
+}
+
+#if 0
+static int Stop(struct stv_state *state)
+{
+	int status = 0;
+
+	switch(state->demod_state)
+	{
+	case QAMStarted:
+		status = writereg(state, R367_QAM_CTRL_1,0x06);
+		state->demod_state = QAMSet;
+		break;
+	case OFDMStarted:
+		status = writereg(state, R367_OFDM_COR_CTL,0x00);
+		state->demod_state = OFDMSet;
+		break;
+	default:
+		break;
+	}
+	return status;
+}
+#endif
+
+static s32 Log10x100(u32 x)
+{
+	static u32 LookupTable[100] = {
+		101157945, 103514217, 105925373, 108392691, 110917482,
+		113501082, 116144861, 118850223, 121618600, 124451461, // 800.5 - 809.5
+		127350308, 130316678, 133352143, 136458314, 139636836,
+		142889396, 146217717, 149623566, 153108746, 156675107, // 810.5 - 819.5
+		160324539, 164058977, 167880402, 171790839, 175792361,
+		179887092, 184077200, 188364909, 192752491, 197242274, // 820.5 - 829.5
+		201836636, 206538016, 211348904, 216271852, 221309471,
+		226464431, 231739465, 237137371, 242661010, 248313311, // 830.5 - 839.5
+		254097271, 260015956, 266072506, 272270131, 278612117,
+		285101827, 291742701, 298538262, 305492111, 312607937, // 840.5 - 849.5
+		319889511, 327340695, 334965439, 342767787, 350751874,
+		358921935, 367282300, 375837404, 384591782, 393550075, // 850.5 - 859.5
+		402717034, 412097519, 421696503, 431519077, 441570447,
+		451855944, 462381021, 473151259, 484172368, 495450191, // 860.5 - 869.5
+		506990708, 518800039, 530884444, 543250331, 555904257,
+		568852931, 582103218, 595662144, 609536897, 623734835, // 870.5 - 879.5
+		638263486, 653130553, 668343918, 683911647, 699841996,
+		716143410, 732824533, 749894209, 767361489, 785235635, // 880.5 - 889.5
+		803526122, 822242650, 841395142, 860993752, 881048873,
+		901571138, 922571427, 944060876, 966050879, 988553095, // 890.5 - 899.5
+	};
+	s32 y;
+	int i;
+
+	if (x == 0)
+		return 0;
+	y = 800;
+	if (x >= 1000000000) {
+		x /= 10;
+		y += 100;
+	}
+
+	while (x < 100000000) {
+		x *= 10;
+		y -= 100;
+	}
+	i = 0;
+	while (i < 100 && x > LookupTable[i])
+		i += 1;
+	y += i;
+	return y;
+}
+
+static int QAM_GetSignalToNoise(struct stv_state *state, s32 *pSignalToNoise)
+{
+	u32 RegValAvg = 0;
+	u8 RegVal[2];
+	int status = 0, i;
+
+	*pSignalToNoise = 0;
+	for (i = 0; i < 10; i += 1 ) {
+		readregs(state, R367_QAM_EQU_SNR_LO, RegVal, 2);
+		RegValAvg += RegVal[0] + 256 * RegVal[1];
+	}
+	if (RegValAvg != 0) {
+		s32 Power = 1;
+		switch(state->modulation) {
+		case QAM_16:
+			Power = 20480;
+			break;
+		case QAM_32:
+			Power = 23040;
+			break;
+		case QAM_64:
+			Power = 21504;
+			break;
+		case QAM_128:
+			Power = 23616; break;
+		case QAM_256:
+			Power = 21760; break;
+		default:
+			break;
+		}
+		*pSignalToNoise = Log10x100((Power * 320) / RegValAvg);
+	} else {
+		*pSignalToNoise = 380;
+	}
+	return status;
+}
+
+static int OFDM_GetSignalToNoise(struct stv_state *state, s32 *pSignalToNoise)
+{
+	u8 CHC_SNR = 0;
+
+	int status = readreg(state, R367_OFDM_CHC_SNR, &CHC_SNR);
+	if (status >= 0) {
+		// Note: very unclear documentation on this.
+		//   Datasheet states snr = CHC_SNR/4 dB  -> way to high values!
+		//   Software  snr = ( 1000 * CHC_SNR ) / 8 / 32 / 10; -> to low values
+		//   Comment in SW states this should be ( 1000 * CHC_SNR ) / 4 / 32 / 10; for the 367
+		//   361/362 Datasheet: snr = CHC_SNR/8 dB -> this looks best
+		*pSignalToNoise = ( (s32)CHC_SNR * 10) / 8;
+	}
+	//printk("SNR %d\n", *pSignalToNoise);
+	return status;
+}
+
+#if 0
+static int DVBC_GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
+{
+	*pQuality = 100;
+	return 0;
+};
+
+static int DVBT_GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
+{
+	static s32 QE_SN[] = {
+		51, // QPSK 1/2
+		69, // QPSK 2/3
+		79, // QPSK 3/4
+		89, // QPSK 5/6
+		97, // QPSK 7/8
+		108, // 16-QAM 1/2
+		131, // 16-QAM 2/3
+		146, // 16-QAM 3/4
+		156, // 16-QAM 5/6
+		160, // 16-QAM 7/8
+		165, // 64-QAM 1/2
+		187, // 64-QAM 2/3
+		202, // 64-QAM 3/4
+		216, // 64-QAM 5/6
+		225, // 64-QAM 7/8
+	};
+	u8 TPS_Received[2];
+	int Constellation;
+	int CodeRate;
+	s32 SignalToNoiseRel, BERQuality;
+
+	*pQuality = 0;
+	readregs(state, R367_OFDM_TPS_RCVD2, TPS_Received, sizeof(TPS_Received));
+	Constellation = TPS_Received[0] & 0x03;
+	CodeRate = TPS_Received[1] & 0x07;
+
+	if( Constellation > 2 || CodeRate > 5 )
+		return -1;
+	SignalToNoiseRel = SignalToNoise - QE_SN[Constellation * 5 + CodeRate];
+	BERQuality = 100;
+
+	if( SignalToNoiseRel < -70 )
+		*pQuality = 0;
+	else if( SignalToNoiseRel < 30 ) {
+		*pQuality = ((SignalToNoiseRel + 70) * BERQuality)/100;
+	} else
+		*pQuality = BERQuality;
+	return 0;
+};
+
+static s32 DVBCQuality(struct stv_state *state, s32 SignalToNoise)
+{
+	s32 SignalToNoiseRel = 0;
+	s32 Quality = 0;
+	s32 BERQuality = 100;
+
+	switch(state->modulation) {
+	case QAM_16:  SignalToNoiseRel = SignalToNoise - 200 ; break;
+	case QAM_32:  SignalToNoiseRel = SignalToNoise - 230 ; break; // Not in NorDig
+	case QAM_64:  SignalToNoiseRel = SignalToNoise - 260 ; break;
+	case QAM_128: SignalToNoiseRel = SignalToNoise - 290 ; break;
+	case QAM_256: SignalToNoiseRel = SignalToNoise - 320 ; break;
+	}
+
+	if( SignalToNoiseRel < -70 ) Quality = 0;
+	else if( SignalToNoiseRel < 30 )
+	{
+		Quality = ((SignalToNoiseRel + 70) * BERQuality)/100;
+	}
+	else
+	Quality = BERQuality;
+
+	return Quality;
+}
+
+static int GetQuality(struct stv_state *state, s32 SignalToNoise, s32 *pQuality)
+{
+	*pQuality = 0;
+	switch(state->demod_state)
+	{
+	case QAMStarted:
+		*pQuality = DVBCQuality(state, SignalToNoise);
+		break;
+	case OFDMStarted:
+		return DVBT_GetQuality(state, SignalToNoise, pQuality);
+	}
+	return 0;
+};
+#endif
+
+static int attach_init(struct stv_state *state)
+{
+	int stat = 0;
+
+	stat = readreg(state, R367_ID, &state->ID);
+	if ( stat < 0 || state->ID != 0x60 )
+		return -ENODEV;
+	printk("stv0367 found\n");
+
+	writereg(state, R367_TOPCTRL, 0x10);
+	write_init_table(state, base_init);
+	write_init_table(state, qam_init);
+
+	writereg(state, R367_TOPCTRL, 0x00);
+	write_init_table(state, ofdm_init);
+
+	writereg(state, R367_OFDM_GAIN_SRC1, 0x2A);
+	writereg(state, R367_OFDM_GAIN_SRC2, 0xD6);
+	writereg(state, R367_OFDM_INC_DEROT1, 0x55);
+	writereg(state, R367_OFDM_INC_DEROT2, 0x55);
+	writereg(state, R367_OFDM_TRL_CTL, 0x14);
+	writereg(state, R367_OFDM_TRL_NOMRATE1, 0xAE);
+	writereg(state, R367_OFDM_TRL_NOMRATE2, 0x56);
+	writereg(state, R367_OFDM_FEPATH_CFG, 0x0);
+
+	// OFDM TS Setup
+
+	writereg(state, R367_OFDM_TSCFGH, 0x70);
+	writereg(state, R367_OFDM_TSCFGM, 0xC0);
+	writereg(state, R367_OFDM_TSCFGL, 0x20);
+	writereg(state, R367_OFDM_TSSPEED, 0x40);        // Fixed at 54 MHz
+	//writereg(state, R367_TSTBUS, 0x80);      // Invert CLK
+
+	writereg(state, R367_OFDM_TSCFGH, 0x71);
+	writereg(state, R367_OFDM_TSCFGH, 0x70);
+
+	writereg(state, R367_TOPCTRL, 0x10);
+
+	// Also needed for QAM
+	writereg(state, R367_OFDM_AGC12C, 0x01); // AGC Pin setup
+
+	writereg(state, R367_OFDM_AGCCTRL1, 0x8A); //
+
+	// QAM TS setup, note exact format also depends on descrambler settings
+	writereg(state, R367_QAM_OUTFORMAT_0, 0x85); // Inverted Clock, Swap, serial
+	// writereg(state, R367_QAM_OUTFORMAT_1, 0x00); //
+
+	// Clock setup
+	writereg(state, R367_ANACTRL, 0x0D); /* PLL bypassed and disabled */
+
+	if( state->master_clock == 58000000 ) {
+		writereg(state, R367_PLLMDIV,27); /* IC runs at 58 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLNDIV,232);
+	} else {
+		writereg(state, R367_PLLMDIV,1); /* IC runs at 54 MHz with a 27 MHz crystal */
+		writereg(state, R367_PLLNDIV,8);
+	}
+	writereg(state, R367_PLLSETUP, 0x18);  /* ADC clock is equal to system clock */
+
+	// Tuner setup
+	writereg(state, R367_ANADIGCTRL, 0x8b); /* Buffer Q disabled, I Enabled, signed ADC */
+	writereg(state, R367_DUAL_AD12, 0x04); /* ADCQ disabled */
+
+	writereg(state, R367_QAM_FSM_SNR2_HTH, 0x23); /* Improves the C/N lock limit */
+	writereg(state, R367_QAM_IQ_QAM, 0x01); /* ZIF/IF Automatic mode */
+	writereg(state, R367_QAM_EQU_FFE_LEAKAGE, 0x83); /* Improving burst noise performances */
+	writereg(state, R367_QAM_IQDEM_ADJ_EN, 0x05); /* Improving ACI performances */
+
+	writereg(state, R367_ANACTRL, 0x00); /* PLL enabled and used */
+
+	writereg(state, R367_I2CRPT, state->I2CRPT);
+	state->demod_state    = QAMSet;
+	return stat;
+}
+
+#ifdef USE_API3
+static void c_release(struct dvb_frontend* fe)
+#else
+static void release(struct dvb_frontend* fe)
+#endif
+{
+	struct stv_state *state=fe->demodulator_priv;
+	printk("%s\n", __FUNCTION__);
+	kfree(state);
+}
+
+#ifdef USE_API3
+static int c_init (struct dvb_frontend *fe)
+{
+	struct stv_state *state=fe->demodulator_priv;
+
+	if (mutex_trylock(&state->ctlock)==0)
+		return -EBUSY;
+	state->omode = OM_DVBC;
+	return 0;
+}
+
+static int c_sleep(struct dvb_frontend* fe)
+{
+	struct stv_state *state=fe->demodulator_priv;
+
+	mutex_unlock(&state->ctlock);
+	return 0;
+}
+#endif
+
+static int gate_ctrl(struct dvb_frontend* fe, int enable)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u8 i2crpt = state->I2CRPT & ~0x80;
+
+	if (enable)
+		i2crpt |= 0x80;
+	if (writereg(state, R367_I2CRPT, i2crpt) < 0)
+		return -1;
+	state->I2CRPT = i2crpt;
+	return 0;
+}
+
+#if 0
+static int c_track(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	return DVBFE_ALGO_SEARCH_AGAIN;
+}
+#endif
+
+#if 0
+int (*set_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
+int (*get_property)(struct dvb_frontend* fe, struct dtv_property* tvp);
+#endif
+
+static int ofdm_lock(struct stv_state *state)
+{
+	int status = 0;
+	u8 OFDM_Status;
+	s32 DemodTimeOut = 10;
+	s32 FECTimeOut = 0;
+	s32 TSTimeOut = 0;
+	u8 CPAMPMin = 255;
+	u8 CPAMPValue;
+	u8 SYR_STAT;
+	u8 FFTMode;
+	u8 TSStatus;
+
+	msleep(state->m_SignalTimeOut);
+	readreg(state, R367_OFDM_STATUS,&OFDM_Status);
+
+	if (!(OFDM_Status & 0x40))
+		return -1;
+	//printk("lock 1\n");
+
+	readreg(state, R367_OFDM_SYR_STAT,&SYR_STAT);
+	FFTMode = (SYR_STAT & 0x0C) >> 2;
+
+	switch(FFTMode)
+	{
+	    case 0: // 2K
+		DemodTimeOut = 10;
+		FECTimeOut = 150;
+		TSTimeOut = 125;
+		CPAMPMin = 20;
+		break;
+	    case 1: // 8K
+		DemodTimeOut = 55;
+		FECTimeOut = 600;
+		TSTimeOut = 500;
+		CPAMPMin = 80;
+		break;
+	    case 2: // 4K
+		DemodTimeOut = 40;
+		FECTimeOut = 300;
+		TSTimeOut = 250;
+		CPAMPMin = 30;
+		break;
+	}
+	state->m_OFDM_FFTMode = FFTMode;
+	readreg(state, R367_OFDM_PPM_CPAMP_DIR,&CPAMPValue);
+	msleep(DemodTimeOut);
+	{
+	    // Release FEC and Read Solomon Reset
+	    u8 tmp1;
+	    u8 tmp2;
+	    readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
+	    readreg(state, R367_TSGENERAL,&tmp2);
+	    writereg(state, R367_OFDM_SFDLYSETH,tmp1 & ~0x08);
+	    writereg(state, R367_TSGENERAL,tmp2 & ~0x01);
+	}
+	msleep(FECTimeOut);
+	if( (OFDM_Status & 0x98) != 0x98 )
+		;//return -1;
+	//printk("lock 2\n");
+
+	{
+	    u8 Guard = (SYR_STAT & 0x03);
+	    if(Guard < 2)
+	    {
+		u8 tmp;
+		readreg(state, R367_OFDM_SYR_CTL,&tmp);
+		writereg(state, R367_OFDM_SYR_CTL,tmp & ~0x04); // Clear AUTO_LE_EN
+		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
+		writereg(state, R367_OFDM_SYR_UPDATE,tmp & ~0x10); // Clear SYR_FILTER
+	    } else {
+		u8 tmp;
+		readreg(state, R367_OFDM_SYR_CTL,&tmp);
+		writereg(state, R367_OFDM_SYR_CTL,tmp | 0x04); // Set AUTO_LE_EN
+		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
+		writereg(state, R367_OFDM_SYR_UPDATE,tmp | 0x10); // Set SYR_FILTER
+	    }
+
+	    // apply Sfec workaround if 8K 64QAM CR!=1/2
+	    if( FFTMode == 1)
+	    {
+		u8 tmp[2];
+		readregs(state, R367_OFDM_TPS_RCVD2, tmp, 2);
+		if( ((tmp[0] & 0x03) == 0x02) && (( tmp[1] & 0x07 ) != 0) )
+		{
+		    writereg(state, R367_OFDM_SFDLYSETH,0xc0);
+		    writereg(state, R367_OFDM_SFDLYSETM,0x60);
+		    writereg(state, R367_OFDM_SFDLYSETL,0x00);
+		}
+		else
+		{
+		    writereg(state, R367_OFDM_SFDLYSETH,0x00);
+		}
+	    }
+	}
+	msleep(TSTimeOut);
+	readreg(state, R367_OFDM_TSSTATUS,&TSStatus);
+	if( (TSStatus & 0x80) != 0x80 )
+		return -1;
+	//printk("lock 3\n");
+	return status;
+}
+
+
+
+#ifdef USE_API3
+static int set_parameters(struct dvb_frontend *fe,
+			  struct dvb_frontend_parameters *p)
+{
+	int stat;
+	struct stv_state *state = fe->demodulator_priv;
+	u32 OF = 0;
+	u32 IF;
+
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe, p);
+
+	switch (state->omode) {
+	case OM_DVBC:
+	case OM_QAM_ITU_C:
+		state->modulation = p->u.qam.modulation;
+		state->symbol_rate = p->u.qam.symbol_rate;
+		break;
+	case OM_DVBT:
+		switch (p->u.ofdm.bandwidth) {
+		case BANDWIDTH_AUTO:
+		case BANDWIDTH_8_MHZ:
+			state->bandwidth = 8000000;
+			break;
+		case BANDWIDTH_7_MHZ:
+			state->bandwidth = 7000000;
+			break;
+		case BANDWIDTH_6_MHZ:
+			state->bandwidth = 6000000;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+#else
+static int set_parameters(struct dvb_frontend *fe)
+{
+	int stat;
+	struct stv_state *state = fe->demodulator_priv;
+	u32 OF = 0;
+	u32 IF;
+
+	switch (fe->dtv_property_cache.delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+		state->omode = OM_DVBC;
+		break;
+	case SYS_DVBT:
+		state->omode = OM_DVBT;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	state->modulation = fe->dtv_property_cache.modulation;
+	state->symbol_rate = fe->dtv_property_cache.symbol_rate;
+	state->bandwidth = fe->dtv_property_cache.bandwidth_hz;
+#endif
+	fe->ops.tuner_ops.get_if_frequency(fe, &IF);
+	//fe->ops.tuner_ops.get_frequency(fe, &IF);
+
+	switch(state->omode) {
+	case OM_DVBT:
+		stat = OFDM_Start(state, OF, IF);
+		ofdm_lock(state);
+		break;
+	case OM_DVBC:
+	case OM_QAM_ITU_C:
+		stat = QAM_Start(state, OF, IF);
+		break;
+	default:
+		stat = -EINVAL;
+	}
+	//printk("%s IF=%d OF=%d done\n", __FUNCTION__, IF, OF);
+	return stat;
+}
+
+#if 0
+static int c_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	//struct stv_state *state = fe->demodulator_priv;
+	//printk("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static int OFDM_GetLockStatus(struct stv_state *state, LOCK_STATUS* pLockStatus, s32 Time)
+{
+	int status = STATUS_SUCCESS;
+	u8 OFDM_Status;
+	s32 DemodTimeOut = 0;
+	s32 FECTimeOut = 0;
+	s32 TSTimeOut = 0;
+	u8 CPAMPMin = 255;
+	u8 CPAMPValue;
+	bool SYRLock;
+	u8 SYR_STAT;
+	u8 FFTMode;
+	u8 TSStatus;
+
+	readreg(state, R367_OFDM_STATUS,&OFDM_Status);
+
+	SYRLock = (OFDM_Status & 0x40) != 0;
+
+	if( Time > m_SignalTimeOut && !SYRLock )
+	{
+	    *pLockStatus = NEVER_LOCK;
+	    break;
+	}
+
+	if( !SYRLock ) break;
+
+	*pLockStatus = SIGNAL_PRESENT;
+
+	// Check Mode
+
+	readreg(state, R367_OFDM_SYR_STAT,&SYR_STAT);
+	FFTMode = (SYR_STAT & 0x0C) >> 2;
+
+	switch(FFTMode)
+	{
+	    case 0: // 2K
+		DemodTimeOut = 10;
+		FECTimeOut = 150;
+		TSTimeOut = 125;
+		CPAMPMin = 20;
+		break;
+	    case 1: // 8K
+		DemodTimeOut = 55;
+		FECTimeOut = 600;
+		TSTimeOut = 500;
+		CPAMPMin = 80;
+		break;
+	    case 2: // 4K
+		DemodTimeOut = 40;
+		FECTimeOut = 300;
+		TSTimeOut = 250;
+		CPAMPMin = 30;
+		break;
+	}
+
+	m_OFDM_FFTMode = FFTMode;
+
+	if( m_DemodTimeOut == 0 && m_bFirstTimeLock )
+	{
+	    m_DemodTimeOut = Time + DemodTimeOut;
+	    //break;
+	}
+
+	readreg(state, R367_OFDM_PPM_CPAMP_DIR,&CPAMPValue);
+
+	if( Time <= m_DemodTimeOut && CPAMPValue < CPAMPMin )
+	{
+	    break;
+	}
+
+	if( CPAMPValue < CPAMPMin && m_bFirstTimeLock )
+	{
+	    // initiate retry
+	    *pLockStatus = NEVER_LOCK;
+	    break;
+	}
+
+	if( CPAMPValue < CPAMPMin ) break;
+
+	*pLockStatus = DEMOD_LOCK;
+
+	if( m_FECTimeOut == 0 && m_bFirstTimeLock )
+	{
+	    // Release FEC and Read Solomon Reset
+	    u8 tmp1;
+	    u8 tmp2;
+	    readreg(state, R367_OFDM_SFDLYSETH,&tmp1);
+	    readreg(state, R367_TSGENERAL,&tmp2);
+	    writereg(state, R367_OFDM_SFDLYSETH,tmp1 & ~0x08);
+	    writereg(state, R367_TSGENERAL,tmp2 & ~0x01);
+
+	    m_FECTimeOut = Time + FECTimeOut;
+	}
+
+	// Wait for TSP_LOCK, LK, PRF
+	if( (OFDM_Status & 0x98) != 0x98 )
+	{
+	    if( Time > m_FECTimeOut ) *pLockStatus = NEVER_LOCK;
+	    break;
+	}
+
+	if( m_bFirstTimeLock && m_TSTimeOut == 0)
+	{
+	    u8 Guard = (SYR_STAT & 0x03);
+	    if(Guard < 2)
+	    {
+		u8 tmp;
+		readreg(state, R367_OFDM_SYR_CTL,&tmp);
+		writereg(state, R367_OFDM_SYR_CTL,tmp & ~0x04); // Clear AUTO_LE_EN
+		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
+		writereg(state, R367_OFDM_SYR_UPDATE,tmp & ~0x10); // Clear SYR_FILTER
+	    } else {
+		u8 tmp;
+		readreg(state, R367_OFDM_SYR_CTL,&tmp);
+		writereg(state, R367_OFDM_SYR_CTL,tmp | 0x04); // Set AUTO_LE_EN
+		readreg(state, R367_OFDM_SYR_UPDATE,&tmp);
+		writereg(state, R367_OFDM_SYR_UPDATE,tmp | 0x10); // Set SYR_FILTER
+	    }
+
+	    // apply Sfec workaround if 8K 64QAM CR!=1/2
+	    if( FFTMode == 1)
+	    {
+		u8 tmp[2];
+		readreg(state, R367_OFDM_TPS_RCVD2,tmp,2);
+		if( ((tmp[0] & 0x03) == 0x02) && (( tmp[1] & 0x07 ) != 0) )
+		{
+		    writereg(state, R367_OFDM_SFDLYSETH,0xc0);
+		    writereg(state, R367_OFDM_SFDLYSETM,0x60);
+		    writereg(state, R367_OFDM_SFDLYSETL,0x00);
+		}
+		else
+		{
+		    writereg(state, R367_OFDM_SFDLYSETH,0x00);
+		}
+	    }
+
+	    m_TSTimeOut = Time + TSTimeOut;
+	}
+	readreg(state, R367_OFDM_TSSTATUS,&TSStatus);
+	if( (TSStatus & 0x80) != 0x80 )
+	{
+		if( Time > m_TSTimeOut ) *pLockStatus = NEVER_LOCK;
+	    break;
+	}
+	*pLockStatus = MPEG_LOCK;
+	m_bFirstTimeLock = false;
+	return status;
+}
+
+#endif
+
+static int read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	*status=0;
+
+	switch(state->demod_state) {
+	case QAMStarted:
+	{
+		u8 FEC_Lock;
+		u8 QAM_Lock;
+
+		readreg(state, R367_QAM_FSM_STS, &QAM_Lock);
+		QAM_Lock &= 0x0F;
+		if (QAM_Lock >10)
+			*status|=0x07;
+		readreg(state, R367_QAM_FEC_STATUS,&FEC_Lock);
+		if (FEC_Lock&2)
+			*status|=0x1f;
+		if (state->m_bFirstTimeLock) {
+			state->m_bFirstTimeLock = false;
+			// QAM_AGC_ACCUMRSTSEL to Tracking;
+			writereg(state, R367_QAM_AGC_CTL, state->m_Save_QAM_AGC_CTL);
+		}
+		break;
+	}
+	case OFDMStarted:
+	{
+		u8 OFDM_Status;
+		u8 TSStatus;
+
+		readreg(state, R367_OFDM_TSSTATUS, &TSStatus);
+
+		readreg(state, R367_OFDM_STATUS, &OFDM_Status);
+		if (OFDM_Status & 0x40)
+			*status |= FE_HAS_SIGNAL;
+
+		if ((OFDM_Status & 0x98) == 0x98)
+			*status|=0x0f;
+
+		if (TSStatus & 0x80)
+			*status |= 0x1f;
+		break;
+	}
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	//struct stv_state *state = fe->demodulator_priv;
+	*ber=0;
+	return 0;
+}
+
+static int read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	if (fe->ops.tuner_ops.get_rf_strength)
+		fe->ops.tuner_ops.get_rf_strength(fe, strength);
+	else
+		*strength = 0;
+	return 0;
+}
+
+static int read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	s32 snr2 = 0;
+
+	switch(state->demod_state) {
+	case QAMStarted:
+		QAM_GetSignalToNoise(state, &snr2);
+		break;
+	case OFDMStarted:
+		OFDM_GetSignalToNoise(state, &snr2);
+		break;
+	default:
+		break;
+	}
+	*snr = snr2&0xffff;
+	return 0;
+}
+
+static int read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct stv_state *state = fe->demodulator_priv;
+	u8 errl, errm, errh;
+	u8 val;
+
+	switch(state->demod_state) {
+	case QAMStarted:
+		readreg(state, R367_QAM_RS_COUNTER_4, &errl);
+		readreg(state, R367_QAM_RS_COUNTER_5, &errm);
+		*ucblocks = (errm << 8) | errl;
+		break;
+	case OFDMStarted:
+		readreg(state, R367_OFDM_SFERRCNTH, &val);
+		if ((val & 0x80) == 0) {
+			readreg(state, R367_OFDM_ERRCNT1H, &errh);
+			readreg(state, R367_OFDM_ERRCNT1M, &errl);
+			readreg(state, R367_OFDM_ERRCNT1L, &errm);
+			state->ucblocks = (errh <<16) | (errm << 8) | errl;
+		}
+		*ucblocks = state->ucblocks;
+		break;
+	default:
+		*ucblocks = 0;
+		break;
+	}
+	return 0;
+}
+
+static int c_get_tune_settings(struct dvb_frontend *fe,
+				    struct dvb_frontend_tune_settings *sets)
+{
+	sets->min_delay_ms=3000;
+	sets->max_drift=0;
+	sets->step_size=0;
+	return 0;
+}
+
+#ifndef USE_API3
+static int get_tune_settings(struct dvb_frontend *fe,
+			     struct dvb_frontend_tune_settings *sets)
+{
+	switch (fe->dtv_property_cache.delivery_system) {
+	case SYS_DVBC_ANNEX_A:
+	case SYS_DVBC_ANNEX_C:
+		return c_get_tune_settings(fe, sets);
+	default:
+		/* DVB-T: Use info.frequency_stepsize. */
+		return -EINVAL;
+	}
+}
+#endif
+
+#ifdef USE_API3
+static void t_release(struct dvb_frontend* fe)
+{
+	//struct stv_state *state=fe->demodulator_priv;
+	//printk("%s\n", __FUNCTION__);
+	//kfree(state);
+}
+
+static int t_init (struct dvb_frontend *fe)
+{
+	struct stv_state *state=fe->demodulator_priv;
+	if (mutex_trylock(&state->ctlock)==0)
+		return -EBUSY;
+	state->omode = OM_DVBT;
+	return 0;
+}
+
+static int t_sleep(struct dvb_frontend* fe)
+{
+	struct stv_state *state=fe->demodulator_priv;
+	mutex_unlock(&state->ctlock);
+	return 0;
+}
+#endif
+
+#if 0
+static int t_get_frontend(struct dvb_frontend *fe, struct dvb_frontend_parameters *p)
+{
+	//struct stv_state *state = fe->demodulator_priv;
+	//printk("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static enum dvbfe_algo algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_CUSTOM;
+}
+#endif
+
+#ifdef USE_API3
+static struct dvb_frontend_ops c_ops = {
+	.info = {
+		.name = "STV0367 DVB-C",
+		.type = FE_QAM,
+		.frequency_stepsize = 62500,
+		.frequency_min = 47000000,
+		.frequency_max = 862000000,
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 | FE_CAN_QAM_256 | FE_CAN_FEC_AUTO
+	},
+	.release = c_release,
+	.init = c_init,
+	.sleep = c_sleep,
+	.i2c_gate_ctrl = gate_ctrl,
+
+	.get_tune_settings = c_get_tune_settings,
+
+	.read_status = read_status,
+	.read_ber = read_ber,
+	.read_signal_strength = read_signal_strength,
+	.read_snr = read_snr,
+	.read_ucblocks = read_ucblocks,
+
+#if 1
+	.set_frontend = set_parameters,
+#else
+	.get_frontend_algo = algo,
+	.search = search,
+#endif
+};
+
+static struct dvb_frontend_ops t_ops = {
+	.info = {
+		.name			= "STV0367 DVB-T",
+		.type			= FE_OFDM,
+		.frequency_min		= 47125000,
+		.frequency_max		= 865000000,
+		.frequency_stepsize	= 166667,
+		.frequency_tolerance	= 0,
+		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+		FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+		FE_CAN_FEC_AUTO |
+		FE_CAN_QAM_16 | FE_CAN_QAM_64 |
+		FE_CAN_QAM_AUTO |
+		FE_CAN_TRANSMISSION_MODE_AUTO |
+		FE_CAN_GUARD_INTERVAL_AUTO |
+		FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+		FE_CAN_MUTE_TS
+	},
+	.release = t_release,
+	.init = t_init,
+	.sleep = t_sleep,
+	.i2c_gate_ctrl = gate_ctrl,
+
+	.set_frontend = set_parameters,
+
+	.read_status = read_status,
+	.read_ber = read_ber,
+	.read_signal_strength = read_signal_strength,
+	.read_snr = read_snr,
+	.read_ucblocks = read_ucblocks,
+};
+
+#else
+
+static struct dvb_frontend_ops common_ops = {
+	.delsys = { SYS_DVBC_ANNEX_A, SYS_DVBT },
+	.info = {
+		.name = "STV0367 DVB-C DVB-T",
+		.frequency_stepsize = 166667,	/* DVB-T only */
+		.frequency_min = 47000000,	/* DVB-T: 47125000 */
+		.frequency_max = 865000000,	/* DVB-C: 862000000 */
+		.symbol_rate_min = 870000,
+		.symbol_rate_max = 11700000,
+		.caps = /* DVB-C */
+			FE_CAN_QAM_16 | FE_CAN_QAM_32 | FE_CAN_QAM_64 |
+			FE_CAN_QAM_128 | FE_CAN_QAM_256 |
+			FE_CAN_FEC_AUTO |
+			/* DVB-T */
+			FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO |
+			FE_CAN_GUARD_INTERVAL_AUTO | FE_CAN_HIERARCHY_AUTO |
+			FE_CAN_RECOVER | FE_CAN_MUTE_TS
+	},
+	.release = release,
+	.i2c_gate_ctrl = gate_ctrl,
+
+	.get_tune_settings = get_tune_settings,
+
+	.set_frontend = set_parameters,
+
+	.read_status = read_status,
+	.read_ber = read_ber,
+	.read_signal_strength = read_signal_strength,
+	.read_snr = read_snr,
+	.read_ucblocks = read_ucblocks,
+};
+#endif
+
+
+static void init_state(struct stv_state *state, struct stv0367_cfg *cfg)
+{
+	u32 ulENARPTLEVEL = 5;
+	u32 ulQAMInversion = 2;
+	state->omode = OM_NONE;
+	state->adr = cfg->adr;
+
+	mutex_init(&state->mutex);
+	mutex_init(&state->ctlock);
+
+#ifdef USE_API3
+	memcpy(&state->c_frontend.ops, &c_ops, sizeof(struct dvb_frontend_ops));
+	memcpy(&state->t_frontend.ops, &t_ops, sizeof(struct dvb_frontend_ops));
+	state->c_frontend.demodulator_priv = state;
+	state->t_frontend.demodulator_priv = state;
+#else
+	memcpy(&state->frontend.ops, &common_ops, sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+#endif
+
+	state->master_clock = 58000000;
+	state->adc_clock = 58000000;
+	state->I2CRPT = 0x08 | ((ulENARPTLEVEL & 0x07) << 4);
+	state->qam_inversion = ((ulQAMInversion & 3) << 6 );
+	state->demod_state   = Off;
+}
+
+
+struct dvb_frontend *stv0367_attach(struct i2c_adapter *i2c, struct stv0367_cfg *cfg,
+				    struct dvb_frontend **fe_t)
+{
+	struct stv_state *state = NULL;
+
+	state = kzalloc(sizeof(struct stv_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+
+	state->i2c = i2c;
+	init_state(state, cfg);
+
+	if (attach_init(state)<0)
+		goto error;
+#ifdef USE_API3
+	*fe_t = &state->t_frontend;
+	return &state->c_frontend;
+#else
+	return &state->frontend;
+#endif
+
+error:
+	printk("stv0367: not found\n");
+	kfree(state);
+	return NULL;
+}
+
+
+MODULE_DESCRIPTION("STV0367DD driver");
+MODULE_AUTHOR("Ralph Metzler, Manfred Voelkel");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(stv0367_attach);
+
+
+
diff -urN linux-3.4.3/drivers/media/dvb/frontends/stv0367dd.h linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd.h
--- linux-3.4.3/drivers/media/dvb/frontends/stv0367dd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd.h	2012-06-18 22:32:24.664032216 +0200
@@ -0,0 +1,17 @@
+#ifndef _STV0367DD_H_
+#define _STV0367DD_H_
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+
+struct stv0367_cfg {
+	u8  adr;
+	u32 xtal;
+	u32 ts_mode;
+};
+
+
+extern struct dvb_frontend *stv0367_attach(struct i2c_adapter *i2c,
+					   struct stv0367_cfg *cfg,
+					   struct dvb_frontend **fe_t);
+#endif
diff -urN linux-3.4.3/drivers/media/dvb/frontends/stv0367dd_regs.h linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd_regs.h
--- linux-3.4.3/drivers/media/dvb/frontends/stv0367dd_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/stv0367dd_regs.h	2012-06-18 22:32:24.664032216 +0200
@@ -0,0 +1,3431 @@
+// @DVB-C/DVB-T STMicroelectronics STV0367 register defintions
+// Author Manfred Vlkel, Februar 2011
+// (c) 2010 DigitalDevices GmbH Germany.  All rights reserved
+
+// $Id: DD_STV0367Register.h 357 2011-04-27 02:39:13Z manfred $
+
+/*	=======================================================================
+    -- Registers Declaration
+    -- -------------------------
+    -- Each register (R367_XXXXX) is defined by its address (2 bytes).
+    --
+    -- Each field (F367_XXXXX)is defined as follow:
+    -- [register address -- 2bytes][field sign -- 1byte][field mask -- 1byte]
+	    =======================================================================  */
+
+/* ID */
+#define	R367_ID		0xF000
+#define	F367_IDENTIFICATIONREG		0xF00000FF
+
+/* I2CRPT */
+#define	R367_I2CRPT		0xF001
+#define	F367_I2CT_ON		0xF0010080
+#define	F367_ENARPT_LEVEL		0xF0010070
+#define	F367_SCLT_DELAY		0xF0010008
+#define	F367_SCLT_NOD		0xF0010004
+#define	F367_STOP_ENABLE		0xF0010002
+#define	F367_SDAT_NOD		0xF0010001
+
+/* TOPCTRL */
+#define	R367_TOPCTRL		0xF002
+#define	F367_STDBY		0xF0020080
+#define	F367_STDBY_FEC		0xF0020040
+#define	F367_STDBY_CORE		0xF0020020
+#define	F367_QAM_COFDM		0xF0020010
+#define	F367_TS_DIS		0xF0020008
+#define	F367_DIR_CLK_216		0xF0020004
+#define	F367_TUNER_BB		0xF0020002
+#define	F367_DVBT_H		0xF0020001
+
+/* IOCFG0 */
+#define	R367_IOCFG0		0xF003
+#define	F367_OP0_SD		0xF0030080
+#define	F367_OP0_VAL		0xF0030040
+#define	F367_OP0_OD		0xF0030020
+#define	F367_OP0_INV		0xF0030010
+#define	F367_OP0_DACVALUE_HI		0xF003000F
+
+/* DAC0R */
+#define	R367_DAC0R		0xF004
+#define	F367_OP0_DACVALUE_LO		0xF00400FF
+
+/* IOCFG1 */
+#define	R367_IOCFG1		0xF005
+#define	F367_IP0		0xF0050040
+#define	F367_OP1_OD		0xF0050020
+#define	F367_OP1_INV		0xF0050010
+#define	F367_OP1_DACVALUE_HI		0xF005000F
+
+/* DAC1R */
+#define	R367_DAC1R		0xF006
+#define	F367_OP1_DACVALUE_LO		0xF00600FF
+
+/* IOCFG2 */
+#define	R367_IOCFG2		0xF007
+#define	F367_OP2_LOCK_CONF		0xF00700E0
+#define	F367_OP2_OD		0xF0070010
+#define	F367_OP2_VAL		0xF0070008
+#define	F367_OP1_LOCK_CONF		0xF0070007
+
+/* SDFR */
+#define	R367_SDFR		0xF008
+#define	F367_OP0_FREQ		0xF00800F0
+#define	F367_OP1_FREQ		0xF008000F
+
+/* STATUS */
+#define	R367_OFDM_STATUS		0xF009
+#define	F367_TPS_LOCK		0xF0090080
+#define	F367_SYR_LOCK		0xF0090040
+#define	F367_AGC_LOCK		0xF0090020
+#define	F367_PRF		0xF0090010
+#define	F367_LK		0xF0090008
+#define	F367_PR		0xF0090007
+
+/* AUX_CLK */
+#define	R367_AUX_CLK		0xF00A
+#define	F367_AUXFEC_CTL		0xF00A00C0
+#define	F367_DIS_CKX4		0xF00A0020
+#define	F367_CKSEL		0xF00A0018
+#define	F367_CKDIV_PROG		0xF00A0006
+#define	F367_AUXCLK_ENA		0xF00A0001
+
+/* FREESYS1 */
+#define	R367_FREESYS1		0xF00B
+#define	F367_FREE_SYS1		0xF00B00FF
+
+/* FREESYS2 */
+#define	R367_FREESYS2		0xF00C
+#define	F367_FREE_SYS2		0xF00C00FF
+
+/* FREESYS3 */
+#define	R367_FREESYS3		0xF00D
+#define	F367_FREE_SYS3		0xF00D00FF
+
+/* GPIO_CFG */
+#define	R367_GPIO_CFG		0xF00E
+#define	F367_GPIO7_NOD		0xF00E0080
+#define	F367_GPIO7_CFG		0xF00E0040
+#define	F367_GPIO6_NOD		0xF00E0020
+#define	F367_GPIO6_CFG		0xF00E0010
+#define	F367_GPIO5_NOD		0xF00E0008
+#define	F367_GPIO5_CFG		0xF00E0004
+#define	F367_GPIO4_NOD		0xF00E0002
+#define	F367_GPIO4_CFG		0xF00E0001
+
+/* GPIO_CMD */
+#define	R367_GPIO_CMD		0xF00F
+#define	F367_GPIO7_VAL		0xF00F0008
+#define	F367_GPIO6_VAL		0xF00F0004
+#define	F367_GPIO5_VAL		0xF00F0002
+#define	F367_GPIO4_VAL		0xF00F0001
+
+/* AGC2MAX */
+#define	R367_OFDM_AGC2MAX		0xF010
+#define	F367_OFDM_AGC2_MAX		0xF01000FF
+
+/* AGC2MIN */
+#define	R367_OFDM_AGC2MIN		0xF011
+#define	F367_OFDM_AGC2_MIN		0xF01100FF
+
+/* AGC1MAX */
+#define	R367_OFDM_AGC1MAX		0xF012
+#define	F367_OFDM_AGC1_MAX		0xF01200FF
+
+/* AGC1MIN */
+#define	R367_OFDM_AGC1MIN		0xF013
+#define	F367_OFDM_AGC1_MIN		0xF01300FF
+
+/* AGCR */
+#define	R367_OFDM_AGCR		0xF014
+#define	F367_OFDM_RATIO_A		0xF01400E0
+#define	F367_OFDM_RATIO_B		0xF0140018
+#define	F367_OFDM_RATIO_C		0xF0140007
+
+/* AGC2TH */
+#define	R367_OFDM_AGC2TH		0xF015
+#define	F367_OFDM_AGC2_THRES		0xF01500FF
+
+/* AGC12C */
+#define	R367_OFDM_AGC12C		0xF016
+#define	F367_OFDM_AGC1_IV		0xF0160080
+#define	F367_OFDM_AGC1_OD		0xF0160040
+#define	F367_OFDM_AGC1_LOAD		0xF0160020
+#define	F367_OFDM_AGC2_IV		0xF0160010
+#define	F367_OFDM_AGC2_OD		0xF0160008
+#define	F367_OFDM_AGC2_LOAD		0xF0160004
+#define	F367_OFDM_AGC12_MODE		0xF0160003
+
+/* AGCCTRL1 */
+#define	R367_OFDM_AGCCTRL1		0xF017
+#define	F367_OFDM_DAGC_ON		0xF0170080
+#define	F367_OFDM_INVERT_AGC12		0xF0170040
+#define	F367_OFDM_AGC1_MODE		0xF0170008
+#define	F367_OFDM_AGC2_MODE		0xF0170007
+
+/* AGCCTRL2 */
+#define	R367_OFDM_AGCCTRL2		0xF018
+#define	F367_OFDM_FRZ2_CTRL		0xF0180060
+#define	F367_OFDM_FRZ1_CTRL		0xF0180018
+#define	F367_OFDM_TIME_CST		0xF0180007
+
+/* AGC1VAL1 */
+#define	R367_OFDM_AGC1VAL1		0xF019
+#define	F367_OFDM_AGC1_VAL_LO		0xF01900FF
+
+/* AGC1VAL2 */
+#define	R367_OFDM_AGC1VAL2		0xF01A
+#define	F367_OFDM_AGC1_VAL_HI		0xF01A000F
+
+/* AGC2VAL1 */
+#define	R367_OFDM_AGC2VAL1		0xF01B
+#define	F367_OFDM_AGC2_VAL_LO		0xF01B00FF
+
+/* AGC2VAL2 */
+#define	R367_OFDM_AGC2VAL2		0xF01C
+#define	F367_OFDM_AGC2_VAL_HI		0xF01C000F
+
+/* AGC2PGA */
+#define	R367_OFDM_AGC2PGA		0xF01D
+#define	F367_OFDM_AGC2_PGA		0xF01D00FF
+
+/* OVF_RATE1 */
+#define	R367_OFDM_OVF_RATE1		0xF01E
+#define	F367_OFDM_OVF_RATE_HI		0xF01E000F
+
+/* OVF_RATE2 */
+#define	R367_OFDM_OVF_RATE2		0xF01F
+#define	F367_OFDM_OVF_RATE_LO		0xF01F00FF
+
+/* GAIN_SRC1 */
+#define	R367_OFDM_GAIN_SRC1		0xF020
+#define	F367_OFDM_INV_SPECTR		0xF0200080
+#define	F367_OFDM_IQ_INVERT		0xF0200040
+#define	F367_OFDM_INR_BYPASS		0xF0200020
+#define	F367_OFDM_STATUS_INV_SPECRUM		0xF0200010
+#define	F367_OFDM_GAIN_SRC_HI		0xF020000F
+
+/* GAIN_SRC2 */
+#define	R367_OFDM_GAIN_SRC2		0xF021
+#define	F367_OFDM_GAIN_SRC_LO		0xF02100FF
+
+/* INC_DEROT1 */
+#define	R367_OFDM_INC_DEROT1		0xF022
+#define	F367_OFDM_INC_DEROT_HI		0xF02200FF
+
+/* INC_DEROT2 */
+#define	R367_OFDM_INC_DEROT2		0xF023
+#define	F367_OFDM_INC_DEROT_LO		0xF02300FF
+
+/* PPM_CPAMP_DIR */
+#define	R367_OFDM_PPM_CPAMP_DIR		0xF024
+#define	F367_OFDM_PPM_CPAMP_DIRECT		0xF02400FF
+
+/* PPM_CPAMP_INV */
+#define	R367_OFDM_PPM_CPAMP_INV		0xF025
+#define	F367_OFDM_PPM_CPAMP_INVER		0xF02500FF
+
+/* FREESTFE_1 */
+#define	R367_OFDM_FREESTFE_1		0xF026
+#define	F367_OFDM_SYMBOL_NUMBER_INC		0xF02600C0
+#define	F367_OFDM_SEL_LSB		0xF0260004
+#define	F367_OFDM_AVERAGE_ON		0xF0260002
+#define	F367_OFDM_DC_ADJ		0xF0260001
+
+/* FREESTFE_2 */
+#define	R367_OFDM_FREESTFE_2		0xF027
+#define	F367_OFDM_SEL_SRCOUT		0xF02700C0
+#define	F367_OFDM_SEL_SYRTHR		0xF027001F
+
+/* DCOFFSET */
+#define	R367_OFDM_DCOFFSET		0xF028
+#define	F367_OFDM_SELECT_I_Q		0xF0280080
+#define	F367_OFDM_DC_OFFSET		0xF028007F
+
+/* EN_PROCESS */
+#define	R367_OFDM_EN_PROCESS		0xF029
+#define	F367_OFDM_FREE		0xF02900F0
+#define	F367_OFDM_ENAB_MANUAL		0xF0290001
+
+/* SDI_SMOOTHER */
+#define	R367_OFDM_SDI_SMOOTHER		0xF02A
+#define	F367_OFDM_DIS_SMOOTH		0xF02A0080
+#define	F367_OFDM_SDI_INC_SMOOTHER		0xF02A007F
+
+/* FE_LOOP_OPEN */
+#define	R367_OFDM_FE_LOOP_OPEN		0xF02B
+#define	F367_OFDM_TRL_LOOP_OP		0xF02B0002
+#define	F367_OFDM_CRL_LOOP_OP		0xF02B0001
+
+/* FREQOFF1 */
+#define	R367_OFDM_FREQOFF1		0xF02C
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_VHI		0xF02C00FF
+
+/* FREQOFF2 */
+#define	R367_OFDM_FREQOFF2		0xF02D
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_HI		0xF02D00FF
+
+/* FREQOFF3 */
+#define	R367_OFDM_FREQOFF3		0xF02E
+#define	F367_OFDM_FREQ_OFFSET_LOOP_OPEN_LO		0xF02E00FF
+
+/* TIMOFF1 */
+#define	R367_OFDM_TIMOFF1		0xF02F
+#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_HI		0xF02F00FF
+
+/* TIMOFF2 */
+#define	R367_OFDM_TIMOFF2		0xF030
+#define	F367_OFDM_TIM_OFFSET_LOOP_OPEN_LO		0xF03000FF
+
+/* EPQ */
+#define	R367_OFDM_EPQ		0xF031
+#define	F367_OFDM_EPQ1		0xF03100FF
+
+/* EPQAUTO */
+#define	R367_OFDM_EPQAUTO		0xF032
+#define	F367_OFDM_EPQ2		0xF03200FF
+
+/* SYR_UPDATE */
+#define	R367_OFDM_SYR_UPDATE		0xF033
+#define	F367_OFDM_SYR_PROTV		0xF0330080
+#define	F367_OFDM_SYR_PROTV_GAIN		0xF0330060
+#define	F367_OFDM_SYR_FILTER		0xF0330010
+#define	F367_OFDM_SYR_TRACK_THRES		0xF033000C
+
+/* CHPFREE */
+#define	R367_OFDM_CHPFREE		0xF034
+#define	F367_OFDM_CHP_FREE		0xF03400FF
+
+/* PPM_STATE_MAC */
+#define	R367_OFDM_PPM_STATE_MAC		0xF035
+#define	F367_OFDM_PPM_STATE_MACHINE_DECODER		0xF035003F
+
+/* INR_THRESHOLD */
+#define	R367_OFDM_INR_THRESHOLD		0xF036
+#define	F367_OFDM_INR_THRESH		0xF03600FF
+
+/* EPQ_TPS_ID_CELL */
+#define	R367_OFDM_EPQ_TPS_ID_CELL		0xF037
+#define	F367_OFDM_ENABLE_LGTH_TO_CF		0xF0370080
+#define	F367_OFDM_DIS_TPS_RSVD		0xF0370040
+#define	F367_OFDM_DIS_BCH		0xF0370020
+#define	F367_OFDM_DIS_ID_CEL		0xF0370010
+#define	F367_OFDM_TPS_ADJUST_SYM		0xF037000F
+
+/* EPQ_CFG */
+#define	R367_OFDM_EPQ_CFG		0xF038
+#define	F367_OFDM_EPQ_RANGE		0xF0380002
+#define	F367_OFDM_EPQ_SOFT		0xF0380001
+
+/* EPQ_STATUS */
+#define	R367_OFDM_EPQ_STATUS		0xF039
+#define	F367_OFDM_SLOPE_INC		0xF03900FC
+#define	F367_OFDM_TPS_FIELD		0xF0390003
+
+/* AUTORELOCK */
+#define	R367_OFDM_AUTORELOCK		0xF03A
+#define	F367_OFDM_BYPASS_BER_TEMPO		0xF03A0080
+#define	F367_OFDM_BER_TEMPO		0xF03A0070
+#define	F367_OFDM_BYPASS_COFDM_TEMPO		0xF03A0008
+#define	F367_OFDM_COFDM_TEMPO		0xF03A0007
+
+/* BER_THR_VMSB */
+#define	R367_OFDM_BER_THR_VMSB		0xF03B
+#define	F367_OFDM_BER_THRESHOLD_HI		0xF03B00FF
+
+/* BER_THR_MSB */
+#define	R367_OFDM_BER_THR_MSB		0xF03C
+#define	F367_OFDM_BER_THRESHOLD_MID		0xF03C00FF
+
+/* BER_THR_LSB */
+#define	R367_OFDM_BER_THR_LSB		0xF03D
+#define	F367_OFDM_BER_THRESHOLD_LO		0xF03D00FF
+
+/* CCD */
+#define	R367_OFDM_CCD		0xF03E
+#define	F367_OFDM_CCD_DETECTED		0xF03E0080
+#define	F367_OFDM_CCD_RESET		0xF03E0040
+#define	F367_OFDM_CCD_THRESHOLD		0xF03E000F
+
+/* SPECTR_CFG */
+#define	R367_OFDM_SPECTR_CFG		0xF03F
+#define	F367_OFDM_SPECT_CFG		0xF03F0003
+
+/* CONSTMU_MSB */
+#define	R367_OFDM_CONSTMU_MSB		0xF040
+#define	F367_OFDM_CONSTMU_FREEZE		0xF0400080
+#define	F367_OFDM_CONSTNU_FORCE_EN		0xF0400040
+#define	F367_OFDM_CONST_MU_MSB		0xF040003F
+
+/* CONSTMU_LSB */
+#define	R367_OFDM_CONSTMU_LSB		0xF041
+#define	F367_OFDM_CONST_MU_LSB		0xF04100FF
+
+/* CONSTMU_MAX_MSB */
+#define	R367_OFDM_CONSTMU_MAX_MSB		0xF042
+#define	F367_OFDM_CONST_MU_MAX_MSB		0xF042003F
+
+/* CONSTMU_MAX_LSB */
+#define	R367_OFDM_CONSTMU_MAX_LSB		0xF043
+#define	F367_OFDM_CONST_MU_MAX_LSB		0xF04300FF
+
+/* ALPHANOISE */
+#define	R367_OFDM_ALPHANOISE		0xF044
+#define	F367_OFDM_USE_ALLFILTER		0xF0440080
+#define	F367_OFDM_INTER_ON		0xF0440040
+#define	F367_OFDM_ALPHA_NOISE		0xF044001F
+
+/* MAXGP_MSB */
+#define	R367_OFDM_MAXGP_MSB		0xF045
+#define	F367_OFDM_MUFILTER_LENGTH		0xF04500F0
+#define	F367_OFDM_MAX_GP_MSB		0xF045000F
+
+/* MAXGP_LSB */
+#define	R367_OFDM_MAXGP_LSB		0xF046
+#define	F367_OFDM_MAX_GP_LSB		0xF04600FF
+
+/* ALPHAMSB */
+#define	R367_OFDM_ALPHAMSB		0xF047
+#define	F367_OFDM_CHC_DATARATE		0xF04700C0
+#define	F367_OFDM_ALPHA_MSB		0xF047003F
+
+/* ALPHALSB */
+#define	R367_OFDM_ALPHALSB		0xF048
+#define	F367_OFDM_ALPHA_LSB		0xF04800FF
+
+/* PILOT_ACCU */
+#define	R367_OFDM_PILOT_ACCU		0xF049
+#define	F367_OFDM_USE_SCAT4ADDAPT		0xF0490080
+#define	F367_OFDM_PILOT_ACC		0xF049001F
+
+/* PILOTMU_ACCU */
+#define	R367_OFDM_PILOTMU_ACCU		0xF04A
+#define	F367_OFDM_DISCARD_BAD_SP		0xF04A0080
+#define	F367_OFDM_DISCARD_BAD_CP		0xF04A0040
+#define	F367_OFDM_PILOT_MU_ACCU		0xF04A001F
+
+/* FILT_CHANNEL_EST */
+#define	R367_OFDM_FILT_CHANNEL_EST		0xF04B
+#define	F367_OFDM_USE_FILT_PILOT		0xF04B0080
+#define	F367_OFDM_FILT_CHANNEL		0xF04B007F
+
+/* ALPHA_NOPISE_FREQ */
+#define	R367_OFDM_ALPHA_NOPISE_FREQ		0xF04C
+#define	F367_OFDM_NOISE_FREQ_FILT		0xF04C0040
+#define	F367_OFDM_ALPHA_NOISE_FREQ		0xF04C003F
+
+/* RATIO_PILOT */
+#define	R367_OFDM_RATIO_PILOT		0xF04D
+#define	F367_OFDM_RATIO_MEAN_SP		0xF04D00F0
+#define	F367_OFDM_RATIO_MEAN_CP		0xF04D000F
+
+/* CHC_CTL */
+#define	R367_OFDM_CHC_CTL		0xF04E
+#define	F367_OFDM_TRACK_EN		0xF04E0080
+#define	F367_OFDM_NOISE_NORM_EN		0xF04E0040
+#define	F367_OFDM_FORCE_CHC_RESET		0xF04E0020
+#define	F367_OFDM_SHORT_TIME		0xF04E0010
+#define	F367_OFDM_FORCE_STATE_EN		0xF04E0008
+#define	F367_OFDM_FORCE_STATE		0xF04E0007
+
+/* EPQ_ADJUST */
+#define	R367_OFDM_EPQ_ADJUST		0xF04F
+#define	F367_OFDM_ADJUST_SCAT_IND		0xF04F00C0
+#define	F367_OFDM_ONE_SYMBOL		0xF04F0010
+#define	F367_OFDM_EPQ_DECAY		0xF04F000E
+#define	F367_OFDM_HOLD_SLOPE		0xF04F0001
+
+/* EPQ_THRES */
+#define	R367_OFDM_EPQ_THRES		0xF050
+#define	F367_OFDM_EPQ_THR		0xF05000FF
+
+/* OMEGA_CTL */
+#define	R367_OFDM_OMEGA_CTL		0xF051
+#define	F367_OFDM_OMEGA_RST		0xF0510080
+#define	F367_OFDM_FREEZE_OMEGA		0xF0510040
+#define	F367_OFDM_OMEGA_SEL		0xF051003F
+
+/* GP_CTL */
+#define	R367_OFDM_GP_CTL		0xF052
+#define	F367_OFDM_CHC_STATE		0xF05200E0
+#define	F367_OFDM_FREEZE_GP		0xF0520010
+#define	F367_OFDM_GP_SEL		0xF052000F
+
+/* MUMSB */
+#define	R367_OFDM_MUMSB		0xF053
+#define	F367_OFDM_MU_MSB		0xF053007F
+
+/* MULSB */
+#define	R367_OFDM_MULSB		0xF054
+#define	F367_OFDM_MU_LSB		0xF05400FF
+
+/* GPMSB */
+#define	R367_OFDM_GPMSB		0xF055
+#define	F367_OFDM_CSI_THRESHOLD		0xF05500E0
+#define	F367_OFDM_GP_MSB		0xF055000F
+
+/* GPLSB */
+#define	R367_OFDM_GPLSB		0xF056
+#define	F367_OFDM_GP_LSB		0xF05600FF
+
+/* OMEGAMSB */
+#define	R367_OFDM_OMEGAMSB		0xF057
+#define	F367_OFDM_OMEGA_MSB		0xF057007F
+
+/* OMEGALSB */
+#define	R367_OFDM_OMEGALSB		0xF058
+#define	F367_OFDM_OMEGA_LSB		0xF05800FF
+
+/* SCAT_NB */
+#define	R367_OFDM_SCAT_NB		0xF059
+#define	F367_OFDM_CHC_TEST		0xF05900F8
+#define	F367_OFDM_SCAT_NUMB		0xF0590003
+
+/* CHC_DUMMY */
+#define	R367_OFDM_CHC_DUMMY		0xF05A
+#define	F367_OFDM_CHC_DUM		0xF05A00FF
+
+/* INC_CTL */
+#define	R367_OFDM_INC_CTL		0xF05B
+#define	F367_OFDM_INC_BYPASS		0xF05B0080
+#define	F367_OFDM_INC_NDEPTH		0xF05B000C
+#define	F367_OFDM_INC_MADEPTH		0xF05B0003
+
+/* INCTHRES_COR1 */
+#define	R367_OFDM_INCTHRES_COR1		0xF05C
+#define	F367_OFDM_INC_THRES_COR1		0xF05C00FF
+
+/* INCTHRES_COR2 */
+#define	R367_OFDM_INCTHRES_COR2		0xF05D
+#define	F367_OFDM_INC_THRES_COR2		0xF05D00FF
+
+/* INCTHRES_DET1 */
+#define	R367_OFDM_INCTHRES_DET1		0xF05E
+#define	F367_OFDM_INC_THRES_DET1		0xF05E003F
+
+/* INCTHRES_DET2 */
+#define	R367_OFDM_INCTHRES_DET2		0xF05F
+#define	F367_OFDM_INC_THRES_DET2		0xF05F003F
+
+/* IIR_CELLNB */
+#define	R367_OFDM_IIR_CELLNB		0xF060
+#define	F367_OFDM_NRST_IIR		0xF0600080
+#define	F367_OFDM_IIR_CELL_NB		0xF0600007
+
+/* IIRCX_COEFF1_MSB */
+#define	R367_OFDM_IIRCX_COEFF1_MSB		0xF061
+#define	F367_OFDM_IIR_CX_COEFF1_MSB		0xF06100FF
+
+/* IIRCX_COEFF1_LSB */
+#define	R367_OFDM_IIRCX_COEFF1_LSB		0xF062
+#define	F367_OFDM_IIR_CX_COEFF1_LSB		0xF06200FF
+
+/* IIRCX_COEFF2_MSB */
+#define	R367_OFDM_IIRCX_COEFF2_MSB		0xF063
+#define	F367_OFDM_IIR_CX_COEFF2_MSB		0xF06300FF
+
+/* IIRCX_COEFF2_LSB */
+#define	R367_OFDM_IIRCX_COEFF2_LSB		0xF064
+#define	F367_OFDM_IIR_CX_COEFF2_LSB		0xF06400FF
+
+/* IIRCX_COEFF3_MSB */
+#define	R367_OFDM_IIRCX_COEFF3_MSB		0xF065
+#define	F367_OFDM_IIR_CX_COEFF3_MSB		0xF06500FF
+
+/* IIRCX_COEFF3_LSB */
+#define	R367_OFDM_IIRCX_COEFF3_LSB		0xF066
+#define	F367_OFDM_IIR_CX_COEFF3_LSB		0xF06600FF
+
+/* IIRCX_COEFF4_MSB */
+#define	R367_OFDM_IIRCX_COEFF4_MSB		0xF067
+#define	F367_OFDM_IIR_CX_COEFF4_MSB		0xF06700FF
+
+/* IIRCX_COEFF4_LSB */
+#define	R367_OFDM_IIRCX_COEFF4_LSB		0xF068
+#define	F367_OFDM_IIR_CX_COEFF4_LSB		0xF06800FF
+
+/* IIRCX_COEFF5_MSB */
+#define	R367_OFDM_IIRCX_COEFF5_MSB		0xF069
+#define	F367_OFDM_IIR_CX_COEFF5_MSB		0xF06900FF
+
+/* IIRCX_COEFF5_LSB */
+#define	R367_OFDM_IIRCX_COEFF5_LSB		0xF06A
+#define	F367_OFDM_IIR_CX_COEFF5_LSB		0xF06A00FF
+
+/* FEPATH_CFG */
+#define	R367_OFDM_FEPATH_CFG		0xF06B
+#define	F367_OFDM_DEMUX_SWAP		0xF06B0004
+#define	F367_OFDM_DIGAGC_SWAP		0xF06B0002
+#define	F367_OFDM_LONGPATH_IF		0xF06B0001
+
+/* PMC1_FUNC */
+#define	R367_OFDM_PMC1_FUNC		0xF06C
+#define	F367_OFDM_SOFT_RSTN		0xF06C0080
+#define	F367_OFDM_PMC1_AVERAGE_TIME		0xF06C0078
+#define	F367_OFDM_PMC1_WAIT_TIME		0xF06C0006
+#define	F367_OFDM_PMC1_2N_SEL		0xF06C0001
+
+/* PMC1_FOR */
+#define	R367_OFDM_PMC1_FOR		0xF06D
+#define	F367_OFDM_PMC1_FORCE		0xF06D0080
+#define	F367_OFDM_PMC1_FORCE_VALUE		0xF06D007C
+
+/* PMC2_FUNC */
+#define	R367_OFDM_PMC2_FUNC		0xF06E
+#define	F367_OFDM_PMC2_SOFT_STN		0xF06E0080
+#define	F367_OFDM_PMC2_ACCU_TIME		0xF06E0070
+#define	F367_OFDM_PMC2_CMDP_MN		0xF06E0008
+#define	F367_OFDM_PMC2_SWAP		0xF06E0004
+
+/* STATUS_ERR_DA */
+#define	R367_OFDM_STATUS_ERR_DA		0xF06F
+#define	F367_OFDM_COM_USEGAINTRK		0xF06F0080
+#define	F367_OFDM_COM_AGCLOCK		0xF06F0040
+#define	F367_OFDM_AUT_AGCLOCK		0xF06F0020
+#define	F367_OFDM_MIN_ERR_X_LSB		0xF06F000F
+
+/* DIG_AGC_R */
+#define	R367_OFDM_DIG_AGC_R		0xF070
+#define	F367_OFDM_COM_SOFT_RSTN		0xF0700080
+#define	F367_OFDM_COM_AGC_ON		0xF0700040
+#define	F367_OFDM_COM_EARLY		0xF0700020
+#define	F367_OFDM_AUT_SOFT_RESETN		0xF0700010
+#define	F367_OFDM_AUT_AGC_ON		0xF0700008
+#define	F367_OFDM_AUT_EARLY		0xF0700004
+#define	F367_OFDM_AUT_ROT_EN		0xF0700002
+#define	F367_OFDM_LOCK_SOFT_RESETN		0xF0700001
+
+/* COMAGC_TARMSB */
+#define	R367_OFDM_COMAGC_TARMSB		0xF071
+#define	F367_OFDM_COM_AGC_TARGET_MSB		0xF07100FF
+
+/* COM_AGC_TAR_ENMODE */
+#define	R367_OFDM_COM_AGC_TAR_ENMODE		0xF072
+#define	F367_OFDM_COM_AGC_TARGET_LSB		0xF07200F0
+#define	F367_OFDM_COM_ENMODE		0xF072000F
+
+/* COM_AGC_CFG */
+#define	R367_OFDM_COM_AGC_CFG		0xF073
+#define	F367_OFDM_COM_N		0xF07300F8
+#define	F367_OFDM_COM_STABMODE		0xF0730006
+#define	F367_OFDM_ERR_SEL		0xF0730001
+
+/* COM_AGC_GAIN1 */
+#define	R367_OFDM_COM_AGC_GAIN1		0xF074
+#define	F367_OFDM_COM_GAIN1ACK		0xF07400F0
+#define	F367_OFDM_COM_GAIN1TRK		0xF074000F
+
+/* AUT_AGC_TARGETMSB */
+#define	R367_OFDM_AUT_AGC_TARGETMSB		0xF075
+#define	F367_OFDM_AUT_AGC_TARGET_MSB		0xF07500FF
+
+/* LOCK_DET_MSB */
+#define	R367_OFDM_LOCK_DET_MSB		0xF076
+#define	F367_OFDM_LOCK_DETECT_MSB		0xF07600FF
+
+/* AGCTAR_LOCK_LSBS */
+#define	R367_OFDM_AGCTAR_LOCK_LSBS		0xF077
+#define	F367_OFDM_AUT_AGC_TARGET_LSB		0xF07700F0
+#define	F367_OFDM_LOCK_DETECT_LSB		0xF077000F
+
+/* AUT_GAIN_EN */
+#define	R367_OFDM_AUT_GAIN_EN		0xF078
+#define	F367_OFDM_AUT_ENMODE		0xF07800F0
+#define	F367_OFDM_AUT_GAIN2		0xF078000F
+
+/* AUT_CFG */
+#define	R367_OFDM_AUT_CFG		0xF079
+#define	F367_OFDM_AUT_N		0xF07900F8
+#define	F367_OFDM_INT_CHOICE		0xF0790006
+#define	F367_OFDM_INT_LOAD		0xF0790001
+
+/* LOCKN */
+#define	R367_OFDM_LOCKN		0xF07A
+#define	F367_OFDM_LOCK_N		0xF07A00F8
+#define	F367_OFDM_SEL_IQNTAR		0xF07A0004
+#define	F367_OFDM_LOCK_DETECT_CHOICE		0xF07A0003
+
+/* INT_X_3 */
+#define	R367_OFDM_INT_X_3		0xF07B
+#define	F367_OFDM_INT_X3		0xF07B00FF
+
+/* INT_X_2 */
+#define	R367_OFDM_INT_X_2		0xF07C
+#define	F367_OFDM_INT_X2		0xF07C00FF
+
+/* INT_X_1 */
+#define	R367_OFDM_INT_X_1		0xF07D
+#define	F367_OFDM_INT_X1		0xF07D00FF
+
+/* INT_X_0 */
+#define	R367_OFDM_INT_X_0		0xF07E
+#define	F367_OFDM_INT_X0		0xF07E00FF
+
+/* MIN_ERRX_MSB */
+#define	R367_OFDM_MIN_ERRX_MSB		0xF07F
+#define	F367_OFDM_MIN_ERR_X_MSB		0xF07F00FF
+
+/* COR_CTL */
+#define	R367_OFDM_COR_CTL		0xF080
+#define	F367_OFDM_CORE_ACTIVE		0xF0800020
+#define	F367_OFDM_HOLD		0xF0800010
+#define	F367_OFDM_CORE_STATE_CTL		0xF080000F
+
+/* COR_STAT */
+#define	R367_OFDM_COR_STAT		0xF081
+#define	F367_OFDM_SCATT_LOCKED		0xF0810080
+#define	F367_OFDM_TPS_LOCKED		0xF0810040
+#define	F367_OFDM_SYR_LOCKED_COR		0xF0810020
+#define	F367_OFDM_AGC_LOCKED_STAT		0xF0810010
+#define	F367_OFDM_CORE_STATE_STAT		0xF081000F
+
+/* COR_INTEN */
+#define	R367_OFDM_COR_INTEN		0xF082
+#define	F367_OFDM_INTEN		0xF0820080
+#define	F367_OFDM_INTEN_SYR		0xF0820020
+#define	F367_OFDM_INTEN_FFT		0xF0820010
+#define	F367_OFDM_INTEN_AGC		0xF0820008
+#define	F367_OFDM_INTEN_TPS1		0xF0820004
+#define	F367_OFDM_INTEN_TPS2		0xF0820002
+#define	F367_OFDM_INTEN_TPS3		0xF0820001
+
+/* COR_INTSTAT */
+#define	R367_OFDM_COR_INTSTAT		0xF083
+#define	F367_OFDM_INTSTAT_SYR		0xF0830020
+#define	F367_OFDM_INTSTAT_FFT		0xF0830010
+#define	F367_OFDM_INTSAT_AGC		0xF0830008
+#define	F367_OFDM_INTSTAT_TPS1		0xF0830004
+#define	F367_OFDM_INTSTAT_TPS2		0xF0830002
+#define	F367_OFDM_INTSTAT_TPS3		0xF0830001
+
+/* COR_MODEGUARD */
+#define	R367_OFDM_COR_MODEGUARD		0xF084
+#define	F367_OFDM_FORCE		0xF0840010
+#define	F367_OFDM_MODE		0xF084000C
+#define	F367_OFDM_GUARD		0xF0840003
+
+/* AGC_CTL */
+#define	R367_OFDM_AGC_CTL		0xF085
+#define	F367_OFDM_AGC_TIMING_FACTOR		0xF08500E0
+#define	F367_OFDM_AGC_LAST		0xF0850010
+#define	F367_OFDM_AGC_GAIN		0xF085000C
+#define	F367_OFDM_AGC_NEG		0xF0850002
+#define	F367_OFDM_AGC_SET		0xF0850001
+
+/* AGC_MANUAL1 */
+#define	R367_OFDM_AGC_MANUAL1		0xF086
+#define	F367_OFDM_AGC_VAL_LO		0xF08600FF
+
+/* AGC_MANUAL2 */
+#define	R367_OFDM_AGC_MANUAL2		0xF087
+#define	F367_OFDM_AGC_VAL_HI		0xF087000F
+
+/* AGC_TARG */
+#define	R367_OFDM_AGC_TARG		0xF088
+#define	F367_OFDM_AGC_TARGET		0xF08800FF
+
+/* AGC_GAIN1 */
+#define	R367_OFDM_AGC_GAIN1		0xF089
+#define	F367_OFDM_AGC_GAIN_LO		0xF08900FF
+
+/* AGC_GAIN2 */
+#define	R367_OFDM_AGC_GAIN2		0xF08A
+#define	F367_OFDM_AGC_LOCKED_GAIN2		0xF08A0010
+#define	F367_OFDM_AGC_GAIN_HI		0xF08A000F
+
+/* RESERVED_1 */
+#define	R367_OFDM_RESERVED_1		0xF08B
+#define	F367_OFDM_RESERVED1		0xF08B00FF
+
+/* RESERVED_2 */
+#define	R367_OFDM_RESERVED_2		0xF08C
+#define	F367_OFDM_RESERVED2		0xF08C00FF
+
+/* RESERVED_3 */
+#define	R367_OFDM_RESERVED_3		0xF08D
+#define	F367_OFDM_RESERVED3		0xF08D00FF
+
+/* CAS_CTL */
+#define	R367_OFDM_CAS_CTL		0xF08E
+#define	F367_OFDM_CCS_ENABLE		0xF08E0080
+#define	F367_OFDM_ACS_DISABLE		0xF08E0040
+#define	F367_OFDM_DAGC_DIS		0xF08E0020
+#define	F367_OFDM_DAGC_GAIN		0xF08E0018
+#define	F367_OFDM_CCSMU		0xF08E0007
+
+/* CAS_FREQ */
+#define	R367_OFDM_CAS_FREQ		0xF08F
+#define	F367_OFDM_CCS_FREQ		0xF08F00FF
+
+/* CAS_DAGCGAIN */
+#define	R367_OFDM_CAS_DAGCGAIN		0xF090
+#define	F367_OFDM_CAS_DAGC_GAIN		0xF09000FF
+
+/* SYR_CTL */
+#define	R367_OFDM_SYR_CTL		0xF091
+#define	F367_OFDM_SICTH_ENABLE		0xF0910080
+#define	F367_OFDM_LONG_ECHO		0xF0910078
+#define	F367_OFDM_AUTO_LE_EN		0xF0910004
+#define	F367_OFDM_SYR_BYPASS		0xF0910002
+#define	F367_OFDM_SYR_TR_DIS		0xF0910001
+
+/* SYR_STAT */
+#define	R367_OFDM_SYR_STAT		0xF092
+#define	F367_OFDM_SYR_LOCKED_STAT		0xF0920010
+#define	F367_OFDM_SYR_MODE		0xF092000C
+#define	F367_OFDM_SYR_GUARD		0xF0920003
+
+/* SYR_NCO1 */
+#define	R367_OFDM_SYR_NCO1		0xF093
+#define	F367_OFDM_SYR_NCO_LO		0xF09300FF
+
+/* SYR_NCO2 */
+#define	R367_OFDM_SYR_NCO2		0xF094
+#define	F367_OFDM_SYR_NCO_HI		0xF094003F
+
+/* SYR_OFFSET1 */
+#define	R367_OFDM_SYR_OFFSET1		0xF095
+#define	F367_OFDM_SYR_OFFSET_LO		0xF09500FF
+
+/* SYR_OFFSET2 */
+#define	R367_OFDM_SYR_OFFSET2		0xF096
+#define	F367_OFDM_SYR_OFFSET_HI		0xF096003F
+
+/* FFT_CTL */
+#define	R367_OFDM_FFT_CTL		0xF097
+#define	F367_OFDM_SHIFT_FFT_TRIG		0xF0970018
+#define	F367_OFDM_FFT_TRIGGER		0xF0970004
+#define	F367_OFDM_FFT_MANUAL		0xF0970002
+#define	F367_OFDM_IFFT_MODE		0xF0970001
+
+/* SCR_CTL */
+#define	R367_OFDM_SCR_CTL		0xF098
+#define	F367_OFDM_SYRADJDECAY		0xF0980070
+#define	F367_OFDM_SCR_CPEDIS		0xF0980002
+#define	F367_OFDM_SCR_DIS		0xF0980001
+
+/* PPM_CTL1 */
+#define	R367_OFDM_PPM_CTL1		0xF099
+#define	F367_OFDM_PPM_MAXFREQ		0xF0990030
+#define	F367_OFDM_PPM_MAXTIM		0xF0990008
+#define	F367_OFDM_PPM_INVSEL		0xF0990004
+#define	F367_OFDM_PPM_SCATDIS		0xF0990002
+#define	F367_OFDM_PPM_BYP		0xF0990001
+
+/* TRL_CTL */
+#define	R367_OFDM_TRL_CTL		0xF09A
+#define	F367_OFDM_TRL_NOMRATE_LSB		0xF09A0080
+#define	F367_OFDM_TRL_GAIN_FACTOR		0xF09A0078
+#define	F367_OFDM_TRL_LOOPGAIN		0xF09A0007
+
+/* TRL_NOMRATE1 */
+#define	R367_OFDM_TRL_NOMRATE1		0xF09B
+#define	F367_OFDM_TRL_NOMRATE_LO		0xF09B00FF
+
+/* TRL_NOMRATE2 */
+#define	R367_OFDM_TRL_NOMRATE2		0xF09C
+#define	F367_OFDM_TRL_NOMRATE_HI		0xF09C00FF
+
+/* TRL_TIME1 */
+#define	R367_OFDM_TRL_TIME1		0xF09D
+#define	F367_OFDM_TRL_TOFFSET_LO		0xF09D00FF
+
+/* TRL_TIME2 */
+#define	R367_OFDM_TRL_TIME2		0xF09E
+#define	F367_OFDM_TRL_TOFFSET_HI		0xF09E00FF
+
+/* CRL_CTL */
+#define	R367_OFDM_CRL_CTL		0xF09F
+#define	F367_OFDM_CRL_DIS		0xF09F0080
+#define	F367_OFDM_CRL_GAIN_FACTOR		0xF09F0078
+#define	F367_OFDM_CRL_LOOPGAIN		0xF09F0007
+
+/* CRL_FREQ1 */
+#define	R367_OFDM_CRL_FREQ1		0xF0A0
+#define	F367_OFDM_CRL_FOFFSET_LO		0xF0A000FF
+
+/* CRL_FREQ2 */
+#define	R367_OFDM_CRL_FREQ2		0xF0A1
+#define	F367_OFDM_CRL_FOFFSET_HI		0xF0A100FF
+
+/* CRL_FREQ3 */
+#define	R367_OFDM_CRL_FREQ3		0xF0A2
+#define	F367_OFDM_CRL_FOFFSET_VHI		0xF0A200FF
+
+/* TPS_SFRAME_CTL */
+#define	R367_OFDM_TPS_SFRAME_CTL		0xF0A3
+#define	F367_OFDM_TPS_SFRAME_SYNC		0xF0A30001
+
+/* CHC_SNR */
+#define	R367_OFDM_CHC_SNR		0xF0A4
+#define	F367_OFDM_CHCSNR		0xF0A400FF
+
+/* BDI_CTL */
+#define	R367_OFDM_BDI_CTL		0xF0A5
+#define	F367_OFDM_BDI_LPSEL		0xF0A50002
+#define	F367_OFDM_BDI_SERIAL		0xF0A50001
+
+/* DMP_CTL */
+#define	R367_OFDM_DMP_CTL		0xF0A6
+#define	F367_OFDM_DMP_SCALING_FACTOR		0xF0A6001E
+#define	F367_OFDM_DMP_SDDIS		0xF0A60001
+
+/* TPS_RCVD1 */
+#define	R367_OFDM_TPS_RCVD1		0xF0A7
+#define	F367_OFDM_TPS_CHANGE		0xF0A70040
+#define	F367_OFDM_BCH_OK		0xF0A70020
+#define	F367_OFDM_TPS_SYNC		0xF0A70010
+#define	F367_OFDM_TPS_FRAME		0xF0A70003
+
+/* TPS_RCVD2 */
+#define	R367_OFDM_TPS_RCVD2		0xF0A8
+#define	F367_OFDM_TPS_HIERMODE		0xF0A80070
+#define	F367_OFDM_TPS_CONST		0xF0A80003
+
+/* TPS_RCVD3 */
+#define	R367_OFDM_TPS_RCVD3		0xF0A9
+#define	F367_OFDM_TPS_LPCODE		0xF0A90070
+#define	F367_OFDM_TPS_HPCODE		0xF0A90007
+
+/* TPS_RCVD4 */
+#define	R367_OFDM_TPS_RCVD4		0xF0AA
+#define	F367_OFDM_TPS_GUARD		0xF0AA0030
+#define	F367_OFDM_TPS_MODE		0xF0AA0003
+
+/* TPS_ID_CELL1 */
+#define	R367_OFDM_TPS_ID_CELL1		0xF0AB
+#define	F367_OFDM_TPS_ID_CELL_LO		0xF0AB00FF
+
+/* TPS_ID_CELL2 */
+#define	R367_OFDM_TPS_ID_CELL2		0xF0AC
+#define	F367_OFDM_TPS_ID_CELL_HI		0xF0AC00FF
+
+/* TPS_RCVD5_SET1 */
+#define	R367_OFDM_TPS_RCVD5_SET1		0xF0AD
+#define	F367_OFDM_TPS_NA		0xF0AD00FC
+#define	F367_OFDM_TPS_SETFRAME		0xF0AD0003
+
+/* TPS_SET2 */
+#define	R367_OFDM_TPS_SET2		0xF0AE
+#define	F367_OFDM_TPS_SETHIERMODE		0xF0AE0070
+#define	F367_OFDM_TPS_SETCONST		0xF0AE0003
+
+/* TPS_SET3 */
+#define	R367_OFDM_TPS_SET3		0xF0AF
+#define	F367_OFDM_TPS_SETLPCODE		0xF0AF0070
+#define	F367_OFDM_TPS_SETHPCODE		0xF0AF0007
+
+/* TPS_CTL */
+#define	R367_OFDM_TPS_CTL		0xF0B0
+#define	F367_OFDM_TPS_IMM		0xF0B00004
+#define	F367_OFDM_TPS_BCHDIS		0xF0B00002
+#define	F367_OFDM_TPS_UPDDIS		0xF0B00001
+
+/* CTL_FFTOSNUM */
+#define	R367_OFDM_CTL_FFTOSNUM		0xF0B1
+#define	F367_OFDM_SYMBOL_NUMBER		0xF0B1007F
+
+/* TESTSELECT */
+#define	R367_OFDM_TESTSELECT		0xF0B2
+#define	F367_OFDM_TEST_SELECT		0xF0B2001F
+
+/* MSC_REV */
+#define	R367_OFDM_MSC_REV		0xF0B3
+#define	F367_OFDM_REV_NUMBER		0xF0B300FF
+
+/* PIR_CTL */
+#define	R367_OFDM_PIR_CTL		0xF0B4
+#define	F367_OFDM_FREEZE		0xF0B40001
+
+/* SNR_CARRIER1 */
+#define	R367_OFDM_SNR_CARRIER1		0xF0B5
+#define	F367_OFDM_SNR_CARRIER_LO		0xF0B500FF
+
+/* SNR_CARRIER2 */
+#define	R367_OFDM_SNR_CARRIER2		0xF0B6
+#define	F367_OFDM_MEAN		0xF0B600C0
+#define	F367_OFDM_SNR_CARRIER_HI		0xF0B6001F
+
+/* PPM_CPAMP */
+#define	R367_OFDM_PPM_CPAMP		0xF0B7
+#define	F367_OFDM_PPM_CPC		0xF0B700FF
+
+/* TSM_AP0 */
+#define	R367_OFDM_TSM_AP0		0xF0B8
+#define	F367_OFDM_ADDRESS_BYTE_0		0xF0B800FF
+
+/* TSM_AP1 */
+#define	R367_OFDM_TSM_AP1		0xF0B9
+#define	F367_OFDM_ADDRESS_BYTE_1		0xF0B900FF
+
+/* TSM_AP2 */
+#define	R367_OFDM_TSM_AP2		0xF0BA
+#define	F367_OFDM_DATA_BYTE_0		0xF0BA00FF
+
+/* TSM_AP3 */
+#define	R367_OFDM_TSM_AP3		0xF0BB
+#define	F367_OFDM_DATA_BYTE_1		0xF0BB00FF
+
+/* TSM_AP4 */
+#define	R367_OFDM_TSM_AP4		0xF0BC
+#define	F367_OFDM_DATA_BYTE_2		0xF0BC00FF
+
+/* TSM_AP5 */
+#define	R367_OFDM_TSM_AP5		0xF0BD
+#define	F367_OFDM_DATA_BYTE_3		0xF0BD00FF
+
+/* TSM_AP6 */
+#define	R367_OFDM_TSM_AP6		0xF0BE
+#define	F367_OFDM_TSM_AP_6		0xF0BE00FF
+
+/* TSM_AP7 */
+#define	R367_OFDM_TSM_AP7		0xF0BF
+#define	F367_OFDM_MEM_SELECT_BYTE		0xF0BF00FF
+
+/* TSTRES */
+#define	R367_TSTRES		0xF0C0
+#define	F367_FRES_DISPLAY		0xF0C00080
+#define	F367_FRES_FIFO_AD		0xF0C00020
+#define	F367_FRESRS		0xF0C00010
+#define	F367_FRESACS		0xF0C00008
+#define	F367_FRESFEC		0xF0C00004
+#define	F367_FRES_PRIF		0xF0C00002
+#define	F367_FRESCORE		0xF0C00001
+
+/* ANACTRL */
+#define	R367_ANACTRL		0xF0C1
+#define	F367_BYPASS_XTAL		0xF0C10040
+#define	F367_BYPASS_PLLXN		0xF0C1000C
+#define	F367_DIS_PAD_OSC		0xF0C10002
+#define	F367_STDBY_PLLXN		0xF0C10001
+
+/* TSTBUS */
+#define	R367_TSTBUS		0xF0C2
+#define	F367_TS_BYTE_CLK_INV		0xF0C20080
+#define	F367_CFG_IP		0xF0C20070
+#define	F367_CFG_TST		0xF0C2000F
+
+/* TSTRATE */
+#define	R367_TSTRATE		0xF0C6
+#define	F367_FORCEPHA		0xF0C60080
+#define	F367_FNEWPHA		0xF0C60010
+#define	F367_FROT90		0xF0C60008
+#define	F367_FR		0xF0C60007
+
+/* CONSTMODE */
+#define	R367_OFDM_CONSTMODE		0xF0CB
+#define	F367_OFDM_TST_PRIF		0xF0CB00E0
+#define	F367_OFDM_CAR_TYPE		0xF0CB0018
+#define	F367_OFDM_CONST_MODE		0xF0CB0003
+
+/* CONSTCARR1 */
+#define	R367_OFDM_CONSTCARR1		0xF0CC
+#define	F367_OFDM_CONST_CARR_LO		0xF0CC00FF
+
+/* CONSTCARR2 */
+#define	R367_OFDM_CONSTCARR2		0xF0CD
+#define	F367_OFDM_CONST_CARR_HI		0xF0CD001F
+
+/* ICONSTEL */
+#define	R367_OFDM_ICONSTEL		0xF0CE
+#define	F367_OFDM_PICONSTEL		0xF0CE00FF
+
+/* QCONSTEL */
+#define	R367_OFDM_QCONSTEL		0xF0CF
+#define	F367_OFDM_PQCONSTEL		0xF0CF00FF
+
+/* TSTBISTRES0 */
+#define	R367_OFDM_TSTBISTRES0		0xF0D0
+#define	F367_OFDM_BEND_PPM		0xF0D00080
+#define	F367_OFDM_BBAD_PPM		0xF0D00040
+#define	F367_OFDM_BEND_FFTW		0xF0D00020
+#define	F367_OFDM_BBAD_FFTW		0xF0D00010
+#define	F367_OFDM_BEND_FFT_BUF		0xF0D00008
+#define	F367_OFDM_BBAD_FFT_BUF		0xF0D00004
+#define	F367_OFDM_BEND_SYR		0xF0D00002
+#define	F367_OFDM_BBAD_SYR		0xF0D00001
+
+/* TSTBISTRES1 */
+#define	R367_OFDM_TSTBISTRES1		0xF0D1
+#define	F367_OFDM_BEND_CHC_CP		0xF0D10080
+#define	F367_OFDM_BBAD_CHC_CP		0xF0D10040
+#define	F367_OFDM_BEND_CHCI		0xF0D10020
+#define	F367_OFDM_BBAD_CHCI		0xF0D10010
+#define	F367_OFDM_BEND_BDI		0xF0D10008
+#define	F367_OFDM_BBAD_BDI		0xF0D10004
+#define	F367_OFDM_BEND_SDI		0xF0D10002
+#define	F367_OFDM_BBAD_SDI		0xF0D10001
+
+/* TSTBISTRES2 */
+#define	R367_OFDM_TSTBISTRES2		0xF0D2
+#define	F367_OFDM_BEND_CHC_INC		0xF0D20080
+#define	F367_OFDM_BBAD_CHC_INC		0xF0D20040
+#define	F367_OFDM_BEND_CHC_SPP		0xF0D20020
+#define	F367_OFDM_BBAD_CHC_SPP		0xF0D20010
+#define	F367_OFDM_BEND_CHC_CPP		0xF0D20008
+#define	F367_OFDM_BBAD_CHC_CPP		0xF0D20004
+#define	F367_OFDM_BEND_CHC_SP		0xF0D20002
+#define	F367_OFDM_BBAD_CHC_SP		0xF0D20001
+
+/* TSTBISTRES3 */
+#define	R367_OFDM_TSTBISTRES3		0xF0D3
+#define	F367_OFDM_BEND_QAM		0xF0D30080
+#define	F367_OFDM_BBAD_QAM		0xF0D30040
+#define	F367_OFDM_BEND_SFEC_VIT		0xF0D30020
+#define	F367_OFDM_BBAD_SFEC_VIT		0xF0D30010
+#define	F367_OFDM_BEND_SFEC_DLINE		0xF0D30008
+#define	F367_OFDM_BBAD_SFEC_DLINE		0xF0D30004
+#define	F367_OFDM_BEND_SFEC_HW		0xF0D30002
+#define	F367_OFDM_BBAD_SFEC_HW		0xF0D30001
+
+/* RF_AGC1 */
+#define	R367_RF_AGC1		0xF0D4
+#define	F367_RF_AGC1_LEVEL_HI		0xF0D400FF
+
+/* RF_AGC2 */
+#define	R367_RF_AGC2		0xF0D5
+#define	F367_REF_ADGP		0xF0D50080
+#define	F367_STDBY_ADCGP		0xF0D50020
+#define	F367_CHANNEL_SEL		0xF0D5001C
+#define	F367_RF_AGC1_LEVEL_LO		0xF0D50003
+
+/* ANADIGCTRL */
+#define	R367_ANADIGCTRL		0xF0D7
+#define	F367_SEL_CLKDEM		0xF0D70020
+#define	F367_EN_BUFFER_Q		0xF0D70010
+#define	F367_EN_BUFFER_I		0xF0D70008
+#define	F367_ADC_RIS_EGDE		0xF0D70004
+#define	F367_SGN_ADC		0xF0D70002
+#define	F367_SEL_AD12_SYNC		0xF0D70001
+
+/* PLLMDIV */
+#define	R367_PLLMDIV		0xF0D8
+#define	F367_PLL_MDIV		0xF0D800FF
+
+/* PLLNDIV */
+#define	R367_PLLNDIV		0xF0D9
+#define	F367_PLL_NDIV		0xF0D900FF
+
+/* PLLSETUP */
+#define	R367_PLLSETUP		0xF0DA
+#define	F367_PLL_PDIV		0xF0DA0070
+#define	F367_PLL_KDIV		0xF0DA000F
+
+/* DUAL_AD12 */
+#define	R367_DUAL_AD12		0xF0DB
+#define	F367_FS20M		0xF0DB0020
+#define	F367_FS50M		0xF0DB0010
+#define	F367_INMODE0		0xF0DB0008
+#define	F367_POFFQ		0xF0DB0004
+#define	F367_POFFI		0xF0DB0002
+#define	F367_INMODE1		0xF0DB0001
+
+/* TSTBIST */
+#define	R367_TSTBIST		0xF0DC
+#define	F367_TST_BYP_CLK		0xF0DC0080
+#define	F367_TST_GCLKENA_STD		0xF0DC0040
+#define	F367_TST_GCLKENA		0xF0DC0020
+#define	F367_TST_MEMBIST		0xF0DC001F
+
+/* PAD_COMP_CTRL */
+#define	R367_PAD_COMP_CTRL		0xF0DD
+#define	F367_COMPTQ		0xF0DD0010
+#define	F367_COMPEN		0xF0DD0008
+#define	F367_FREEZE2		0xF0DD0004
+#define	F367_SLEEP_INHBT		0xF0DD0002
+#define	F367_CHIP_SLEEP		0xF0DD0001
+
+/* PAD_COMP_WR */
+#define	R367_PAD_COMP_WR		0xF0DE
+#define	F367_WR_ASRC		0xF0DE007F
+
+/* PAD_COMP_RD */
+#define	R367_PAD_COMP_RD		0xF0DF
+#define	F367_COMPOK		0xF0DF0080
+#define	F367_RD_ASRC		0xF0DF007F
+
+/* SYR_TARGET_FFTADJT_MSB */
+#define	R367_OFDM_SYR_TARGET_FFTADJT_MSB		0xF100
+#define	F367_OFDM_SYR_START		0xF1000080
+#define	F367_OFDM_SYR_TARGET_FFTADJ_HI		0xF100000F
+
+/* SYR_TARGET_FFTADJT_LSB */
+#define	R367_OFDM_SYR_TARGET_FFTADJT_LSB		0xF101
+#define	F367_OFDM_SYR_TARGET_FFTADJ_LO		0xF10100FF
+
+/* SYR_TARGET_CHCADJT_MSB */
+#define	R367_OFDM_SYR_TARGET_CHCADJT_MSB		0xF102
+#define	F367_OFDM_SYR_TARGET_CHCADJ_HI		0xF102000F
+
+/* SYR_TARGET_CHCADJT_LSB */
+#define	R367_OFDM_SYR_TARGET_CHCADJT_LSB		0xF103
+#define	F367_OFDM_SYR_TARGET_CHCADJ_LO		0xF10300FF
+
+/* SYR_FLAG */
+#define	R367_OFDM_SYR_FLAG		0xF104
+#define	F367_OFDM_TRIG_FLG1		0xF1040080
+#define	F367_OFDM_TRIG_FLG0		0xF1040040
+#define	F367_OFDM_FFT_FLG1		0xF1040008
+#define	F367_OFDM_FFT_FLG0		0xF1040004
+#define	F367_OFDM_CHC_FLG1		0xF1040002
+#define	F367_OFDM_CHC_FLG0		0xF1040001
+
+/* CRL_TARGET1 */
+#define	R367_OFDM_CRL_TARGET1		0xF105
+#define	F367_OFDM_CRL_START		0xF1050080
+#define	F367_OFDM_CRL_TARGET_VHI		0xF105000F
+
+/* CRL_TARGET2 */
+#define	R367_OFDM_CRL_TARGET2		0xF106
+#define	F367_OFDM_CRL_TARGET_HI		0xF10600FF
+
+/* CRL_TARGET3 */
+#define	R367_OFDM_CRL_TARGET3		0xF107
+#define	F367_OFDM_CRL_TARGET_LO		0xF10700FF
+
+/* CRL_TARGET4 */
+#define	R367_OFDM_CRL_TARGET4		0xF108
+#define	F367_OFDM_CRL_TARGET_VLO		0xF10800FF
+
+/* CRL_FLAG */
+#define	R367_OFDM_CRL_FLAG		0xF109
+#define	F367_OFDM_CRL_FLAG1		0xF1090002
+#define	F367_OFDM_CRL_FLAG0		0xF1090001
+
+/* TRL_TARGET1 */
+#define	R367_OFDM_TRL_TARGET1		0xF10A
+#define	F367_OFDM_TRL_TARGET_HI		0xF10A00FF
+
+/* TRL_TARGET2 */
+#define	R367_OFDM_TRL_TARGET2		0xF10B
+#define	F367_OFDM_TRL_TARGET_LO		0xF10B00FF
+
+/* TRL_CHC */
+#define	R367_OFDM_TRL_CHC		0xF10C
+#define	F367_OFDM_TRL_START		0xF10C0080
+#define	F367_OFDM_CHC_START		0xF10C0040
+#define	F367_OFDM_TRL_FLAG1		0xF10C0002
+#define	F367_OFDM_TRL_FLAG0		0xF10C0001
+
+/* CHC_SNR_TARG */
+#define	R367_OFDM_CHC_SNR_TARG		0xF10D
+#define	F367_OFDM_CHC_SNR_TARGET		0xF10D00FF
+
+/* TOP_TRACK */
+#define	R367_OFDM_TOP_TRACK		0xF10E
+#define	F367_OFDM_TOP_START		0xF10E0080
+#define	F367_OFDM_FIRST_FLAG		0xF10E0070
+#define	F367_OFDM_TOP_FLAG1		0xF10E0008
+#define	F367_OFDM_TOP_FLAG0		0xF10E0004
+#define	F367_OFDM_CHC_FLAG1		0xF10E0002
+#define	F367_OFDM_CHC_FLAG0		0xF10E0001
+
+/* TRACKER_FREE1 */
+#define	R367_OFDM_TRACKER_FREE1		0xF10F
+#define	F367_OFDM_TRACKER_FREE_1		0xF10F00FF
+
+/* ERROR_CRL1 */
+#define	R367_OFDM_ERROR_CRL1		0xF110
+#define	F367_OFDM_ERROR_CRL_VHI		0xF11000FF
+
+/* ERROR_CRL2 */
+#define	R367_OFDM_ERROR_CRL2		0xF111
+#define	F367_OFDM_ERROR_CRL_HI		0xF11100FF
+
+/* ERROR_CRL3 */
+#define	R367_OFDM_ERROR_CRL3		0xF112
+#define	F367_OFDM_ERROR_CRL_LOI		0xF11200FF
+
+/* ERROR_CRL4 */
+#define	R367_OFDM_ERROR_CRL4		0xF113
+#define	F367_OFDM_ERROR_CRL_VLO		0xF11300FF
+
+/* DEC_NCO1 */
+#define	R367_OFDM_DEC_NCO1		0xF114
+#define	F367_OFDM_DEC_NCO_VHI		0xF11400FF
+
+/* DEC_NCO2 */
+#define	R367_OFDM_DEC_NCO2		0xF115
+#define	F367_OFDM_DEC_NCO_HI		0xF11500FF
+
+/* DEC_NCO3 */
+#define	R367_OFDM_DEC_NCO3		0xF116
+#define	F367_OFDM_DEC_NCO_LO		0xF11600FF
+
+/* SNR */
+#define	R367_OFDM_SNR		0xF117
+#define	F367_OFDM_SNRATIO		0xF11700FF
+
+/* SYR_FFTADJ1 */
+#define	R367_OFDM_SYR_FFTADJ1		0xF118
+#define	F367_OFDM_SYR_FFTADJ_HI		0xF11800FF
+
+/* SYR_FFTADJ2 */
+#define	R367_OFDM_SYR_FFTADJ2		0xF119
+#define	F367_OFDM_SYR_FFTADJ_LO		0xF11900FF
+
+/* SYR_CHCADJ1 */
+#define	R367_OFDM_SYR_CHCADJ1		0xF11A
+#define	F367_OFDM_SYR_CHCADJ_HI		0xF11A00FF
+
+/* SYR_CHCADJ2 */
+#define	R367_OFDM_SYR_CHCADJ2		0xF11B
+#define	F367_OFDM_SYR_CHCADJ_LO		0xF11B00FF
+
+/* SYR_OFF */
+#define	R367_OFDM_SYR_OFF		0xF11C
+#define	F367_OFDM_SYR_OFFSET		0xF11C00FF
+
+/* PPM_OFFSET1 */
+#define	R367_OFDM_PPM_OFFSET1		0xF11D
+#define	F367_OFDM_PPM_OFFSET_HI		0xF11D00FF
+
+/* PPM_OFFSET2 */
+#define	R367_OFDM_PPM_OFFSET2		0xF11E
+#define	F367_OFDM_PPM_OFFSET_LO		0xF11E00FF
+
+/* TRACKER_FREE2 */
+#define	R367_OFDM_TRACKER_FREE2		0xF11F
+#define	F367_OFDM_TRACKER_FREE_2		0xF11F00FF
+
+/* DEBG_LT10 */
+#define	R367_OFDM_DEBG_LT10		0xF120
+#define	F367_OFDM_DEBUG_LT10		0xF12000FF
+
+/* DEBG_LT11 */
+#define	R367_OFDM_DEBG_LT11		0xF121
+#define	F367_OFDM_DEBUG_LT11		0xF12100FF
+
+/* DEBG_LT12 */
+#define	R367_OFDM_DEBG_LT12		0xF122
+#define	F367_OFDM_DEBUG_LT12		0xF12200FF
+
+/* DEBG_LT13 */
+#define	R367_OFDM_DEBG_LT13		0xF123
+#define	F367_OFDM_DEBUG_LT13		0xF12300FF
+
+/* DEBG_LT14 */
+#define	R367_OFDM_DEBG_LT14		0xF124
+#define	F367_OFDM_DEBUG_LT14		0xF12400FF
+
+/* DEBG_LT15 */
+#define	R367_OFDM_DEBG_LT15		0xF125
+#define	F367_OFDM_DEBUG_LT15		0xF12500FF
+
+/* DEBG_LT16 */
+#define	R367_OFDM_DEBG_LT16		0xF126
+#define	F367_OFDM_DEBUG_LT16		0xF12600FF
+
+/* DEBG_LT17 */
+#define	R367_OFDM_DEBG_LT17		0xF127
+#define	F367_OFDM_DEBUG_LT17		0xF12700FF
+
+/* DEBG_LT18 */
+#define	R367_OFDM_DEBG_LT18		0xF128
+#define	F367_OFDM_DEBUG_LT18		0xF12800FF
+
+/* DEBG_LT19 */
+#define	R367_OFDM_DEBG_LT19		0xF129
+#define	F367_OFDM_DEBUG_LT19		0xF12900FF
+
+/* DEBG_LT1A */
+#define	R367_OFDM_DEBG_LT1A		0xF12A
+#define	F367_OFDM_DEBUG_LT1A		0xF12A00FF
+
+/* DEBG_LT1B */
+#define	R367_OFDM_DEBG_LT1B		0xF12B
+#define	F367_OFDM_DEBUG_LT1B		0xF12B00FF
+
+/* DEBG_LT1C */
+#define	R367_OFDM_DEBG_LT1C		0xF12C
+#define	F367_OFDM_DEBUG_LT1C		0xF12C00FF
+
+/* DEBG_LT1D */
+#define	R367_OFDM_DEBG_LT1D		0xF12D
+#define	F367_OFDM_DEBUG_LT1D		0xF12D00FF
+
+/* DEBG_LT1E */
+#define	R367_OFDM_DEBG_LT1E		0xF12E
+#define	F367_OFDM_DEBUG_LT1E		0xF12E00FF
+
+/* DEBG_LT1F */
+#define	R367_OFDM_DEBG_LT1F		0xF12F
+#define	F367_OFDM_DEBUG_LT1F		0xF12F00FF
+
+/* RCCFGH */
+#define	R367_OFDM_RCCFGH		0xF200
+#define	F367_OFDM_TSRCFIFO_DVBCI		0xF2000080
+#define	F367_OFDM_TSRCFIFO_SERIAL		0xF2000040
+#define	F367_OFDM_TSRCFIFO_DISABLE		0xF2000020
+#define	F367_OFDM_TSFIFO_2TORC		0xF2000010
+#define	F367_OFDM_TSRCFIFO_HSGNLOUT		0xF2000008
+#define	F367_OFDM_TSRCFIFO_ERRMODE		0xF2000006
+#define	F367_OFDM_RCCFGH_0		0xF2000001
+
+/* RCCFGM */
+#define	R367_OFDM_RCCFGM		0xF201
+#define	F367_OFDM_TSRCFIFO_MANSPEED		0xF20100C0
+#define	F367_OFDM_TSRCFIFO_PERMDATA		0xF2010020
+#define	F367_OFDM_TSRCFIFO_NONEWSGNL		0xF2010010
+#define	F367_OFDM_RCBYTE_OVERSAMPLING		0xF201000E
+#define	F367_OFDM_TSRCFIFO_INVDATA		0xF2010001
+
+/* RCCFGL */
+#define	R367_OFDM_RCCFGL		0xF202
+#define	F367_OFDM_TSRCFIFO_BCLKDEL1CK		0xF20200C0
+#define	F367_OFDM_RCCFGL_5		0xF2020020
+#define	F367_OFDM_TSRCFIFO_DUTY50		0xF2020010
+#define	F367_OFDM_TSRCFIFO_NSGNL2DATA		0xF2020008
+#define	F367_OFDM_TSRCFIFO_DISSERMUX		0xF2020004
+#define	F367_OFDM_RCCFGL_1		0xF2020002
+#define	F367_OFDM_TSRCFIFO_STOPCKDIS		0xF2020001
+
+/* RCINSDELH */
+#define	R367_OFDM_RCINSDELH		0xF203
+#define	F367_OFDM_TSRCDEL_SYNCBYTE		0xF2030080
+#define	F367_OFDM_TSRCDEL_XXHEADER		0xF2030040
+#define	F367_OFDM_TSRCDEL_BBHEADER		0xF2030020
+#define	F367_OFDM_TSRCDEL_DATAFIELD		0xF2030010
+#define	F367_OFDM_TSRCINSDEL_ISCR		0xF2030008
+#define	F367_OFDM_TSRCINSDEL_NPD		0xF2030004
+#define	F367_OFDM_TSRCINSDEL_RSPARITY		0xF2030002
+#define	F367_OFDM_TSRCINSDEL_CRC8		0xF2030001
+
+/* RCINSDELM */
+#define	R367_OFDM_RCINSDELM		0xF204
+#define	F367_OFDM_TSRCINS_BBPADDING		0xF2040080
+#define	F367_OFDM_TSRCINS_BCHFEC		0xF2040040
+#define	F367_OFDM_TSRCINS_LDPCFEC		0xF2040020
+#define	F367_OFDM_TSRCINS_EMODCOD		0xF2040010
+#define	F367_OFDM_TSRCINS_TOKEN		0xF2040008
+#define	F367_OFDM_TSRCINS_XXXERR		0xF2040004
+#define	F367_OFDM_TSRCINS_MATYPE		0xF2040002
+#define	F367_OFDM_TSRCINS_UPL		0xF2040001
+
+/* RCINSDELL */
+#define	R367_OFDM_RCINSDELL		0xF205
+#define	F367_OFDM_TSRCINS_DFL		0xF2050080
+#define	F367_OFDM_TSRCINS_SYNCD		0xF2050040
+#define	F367_OFDM_TSRCINS_BLOCLEN		0xF2050020
+#define	F367_OFDM_TSRCINS_SIGPCOUNT		0xF2050010
+#define	F367_OFDM_TSRCINS_FIFO		0xF2050008
+#define	F367_OFDM_TSRCINS_REALPACK		0xF2050004
+#define	F367_OFDM_TSRCINS_TSCONFIG		0xF2050002
+#define	F367_OFDM_TSRCINS_LATENCY		0xF2050001
+
+/* RCSTATUS */
+#define	R367_OFDM_RCSTATUS		0xF206
+#define	F367_OFDM_TSRCFIFO_LINEOK		0xF2060080
+#define	F367_OFDM_TSRCFIFO_ERROR		0xF2060040
+#define	F367_OFDM_TSRCFIFO_DATA7		0xF2060020
+#define	F367_OFDM_RCSTATUS_4		0xF2060010
+#define	F367_OFDM_TSRCFIFO_DEMODSEL		0xF2060008
+#define	F367_OFDM_TSRC1FIFOSPEED_STORE		0xF2060004
+#define	F367_OFDM_RCSTATUS_1		0xF2060002
+#define	F367_OFDM_TSRCSERIAL_IMPOSSIBLE		0xF2060001
+
+/* RCSPEED */
+#define	R367_OFDM_RCSPEED		0xF207
+#define	F367_OFDM_TSRCFIFO_OUTSPEED		0xF20700FF
+
+/* RCDEBUGM */
+#define	R367_OFDM_RCDEBUGM		0xF208
+#define	F367_OFDM_SD_UNSYNC		0xF2080080
+#define	F367_OFDM_ULFLOCK_DETECTM		0xF2080040
+#define	F367_OFDM_SUL_SELECTOS		0xF2080020
+#define	F367_OFDM_DILUL_NOSCRBLE		0xF2080010
+#define	F367_OFDM_NUL_SCRB		0xF2080008
+#define	F367_OFDM_UL_SCRB		0xF2080004
+#define	F367_OFDM_SCRAULBAD		0xF2080002
+#define	F367_OFDM_SCRAUL_UNSYNC		0xF2080001
+
+/* RCDEBUGL */
+#define	R367_OFDM_RCDEBUGL		0xF209
+#define	F367_OFDM_RS_ERR		0xF2090080
+#define	F367_OFDM_LLFLOCK_DETECTM		0xF2090040
+#define	F367_OFDM_NOT_SUL_SELECTOS		0xF2090020
+#define	F367_OFDM_DILLL_NOSCRBLE		0xF2090010
+#define	F367_OFDM_NLL_SCRB		0xF2090008
+#define	F367_OFDM_LL_SCRB		0xF2090004
+#define	F367_OFDM_SCRALLBAD		0xF2090002
+#define	F367_OFDM_SCRALL_UNSYNC		0xF2090001
+
+/* RCOBSCFG */
+#define	R367_OFDM_RCOBSCFG		0xF20A
+#define	F367_OFDM_TSRCFIFO_OBSCFG		0xF20A00FF
+
+/* RCOBSM */
+#define	R367_OFDM_RCOBSM		0xF20B
+#define	F367_OFDM_TSRCFIFO_OBSDATA_HI		0xF20B00FF
+
+/* RCOBSL */
+#define	R367_OFDM_RCOBSL		0xF20C
+#define	F367_OFDM_TSRCFIFO_OBSDATA_LO		0xF20C00FF
+
+/* RCFECSPY */
+#define	R367_OFDM_RCFECSPY		0xF210
+#define	F367_OFDM_SPYRC_ENABLE		0xF2100080
+#define	F367_OFDM_RCNO_SYNCBYTE		0xF2100040
+#define	F367_OFDM_RCSERIAL_MODE		0xF2100020
+#define	F367_OFDM_RCUNUSUAL_PACKET		0xF2100010
+#define	F367_OFDM_BERRCMETER_DATAMODE		0xF210000C
+#define	F367_OFDM_BERRCMETER_LMODE		0xF2100002
+#define	F367_OFDM_BERRCMETER_RESET		0xF2100001
+
+/* RCFSPYCFG */
+#define	R367_OFDM_RCFSPYCFG		0xF211
+#define	F367_OFDM_FECSPYRC_INPUT		0xF21100C0
+#define	F367_OFDM_RCRST_ON_ERROR		0xF2110020
+#define	F367_OFDM_RCONE_SHOT		0xF2110010
+#define	F367_OFDM_RCI2C_MODE		0xF211000C
+#define	F367_OFDM_SPYRC_HSTERESIS		0xF2110003
+
+/* RCFSPYDATA */
+#define	R367_OFDM_RCFSPYDATA		0xF212
+#define	F367_OFDM_SPYRC_STUFFING		0xF2120080
+#define	F367_OFDM_RCNOERR_PKTJITTER		0xF2120040
+#define	F367_OFDM_SPYRC_CNULLPKT		0xF2120020
+#define	F367_OFDM_SPYRC_OUTDATA_MODE		0xF212001F
+
+/* RCFSPYOUT */
+#define	R367_OFDM_RCFSPYOUT		0xF213
+#define	F367_OFDM_FSPYRC_DIRECT		0xF2130080
+#define	F367_OFDM_RCFSPYOUT_6		0xF2130040
+#define	F367_OFDM_SPYRC_OUTDATA_BUS		0xF2130038
+#define	F367_OFDM_RCSTUFF_MODE		0xF2130007
+
+/* RCFSTATUS */
+#define	R367_OFDM_RCFSTATUS		0xF214
+#define	F367_OFDM_SPYRC_ENDSIM		0xF2140080
+#define	F367_OFDM_RCVALID_SIM		0xF2140040
+#define	F367_OFDM_RCFOUND_SIGNAL		0xF2140020
+#define	F367_OFDM_RCDSS_SYNCBYTE		0xF2140010
+#define	F367_OFDM_RCRESULT_STATE		0xF214000F
+
+/* RCFGOODPACK */
+#define	R367_OFDM_RCFGOODPACK		0xF215
+#define	F367_OFDM_RCGOOD_PACKET		0xF21500FF
+
+/* RCFPACKCNT */
+#define	R367_OFDM_RCFPACKCNT		0xF216
+#define	F367_OFDM_RCPACKET_COUNTER		0xF21600FF
+
+/* RCFSPYMISC */
+#define	R367_OFDM_RCFSPYMISC		0xF217
+#define	F367_OFDM_RCLABEL_COUNTER		0xF21700FF
+
+/* RCFBERCPT4 */
+#define	R367_OFDM_RCFBERCPT4		0xF218
+#define	F367_OFDM_FBERRCMETER_CPT_MMMMSB		0xF21800FF
+
+/* RCFBERCPT3 */
+#define	R367_OFDM_RCFBERCPT3		0xF219
+#define	F367_OFDM_FBERRCMETER_CPT_MMMSB		0xF21900FF
+
+/* RCFBERCPT2 */
+#define	R367_OFDM_RCFBERCPT2		0xF21A
+#define	F367_OFDM_FBERRCMETER_CPT_MMSB		0xF21A00FF
+
+/* RCFBERCPT1 */
+#define	R367_OFDM_RCFBERCPT1		0xF21B
+#define	F367_OFDM_FBERRCMETER_CPT_MSB		0xF21B00FF
+
+/* RCFBERCPT0 */
+#define	R367_OFDM_RCFBERCPT0		0xF21C
+#define	F367_OFDM_FBERRCMETER_CPT_LSB		0xF21C00FF
+
+/* RCFBERERR2 */
+#define	R367_OFDM_RCFBERERR2		0xF21D
+#define	F367_OFDM_FBERRCMETER_ERR_HI		0xF21D00FF
+
+/* RCFBERERR1 */
+#define	R367_OFDM_RCFBERERR1		0xF21E
+#define	F367_OFDM_FBERRCMETER_ERR		0xF21E00FF
+
+/* RCFBERERR0 */
+#define	R367_OFDM_RCFBERERR0		0xF21F
+#define	F367_OFDM_FBERRCMETER_ERR_LO		0xF21F00FF
+
+/* RCFSTATESM */
+#define	R367_OFDM_RCFSTATESM		0xF220
+#define	F367_OFDM_RCRSTATE_F		0xF2200080
+#define	F367_OFDM_RCRSTATE_E		0xF2200040
+#define	F367_OFDM_RCRSTATE_D		0xF2200020
+#define	F367_OFDM_RCRSTATE_C		0xF2200010
+#define	F367_OFDM_RCRSTATE_B		0xF2200008
+#define	F367_OFDM_RCRSTATE_A		0xF2200004
+#define	F367_OFDM_RCRSTATE_9		0xF2200002
+#define	F367_OFDM_RCRSTATE_8		0xF2200001
+
+/* RCFSTATESL */
+#define	R367_OFDM_RCFSTATESL		0xF221
+#define	F367_OFDM_RCRSTATE_7		0xF2210080
+#define	F367_OFDM_RCRSTATE_6		0xF2210040
+#define	F367_OFDM_RCRSTATE_5		0xF2210020
+#define	F367_OFDM_RCRSTATE_4		0xF2210010
+#define	F367_OFDM_RCRSTATE_3		0xF2210008
+#define	F367_OFDM_RCRSTATE_2		0xF2210004
+#define	F367_OFDM_RCRSTATE_1		0xF2210002
+#define	F367_OFDM_RCRSTATE_0		0xF2210001
+
+/* RCFSPYBER */
+#define	R367_OFDM_RCFSPYBER		0xF222
+#define	F367_OFDM_RCFSPYBER_7		0xF2220080
+#define	F367_OFDM_SPYRCOBS_XORREAD		0xF2220040
+#define	F367_OFDM_FSPYRCBER_OBSMODE		0xF2220020
+#define	F367_OFDM_FSPYRCBER_SYNCBYT		0xF2220010
+#define	F367_OFDM_FSPYRCBER_UNSYNC		0xF2220008
+#define	F367_OFDM_FSPYRCBER_CTIME		0xF2220007
+
+/* RCFSPYDISTM */
+#define	R367_OFDM_RCFSPYDISTM		0xF223
+#define	F367_OFDM_RCPKTTIME_DISTANCE_HI		0xF22300FF
+
+/* RCFSPYDISTL */
+#define	R367_OFDM_RCFSPYDISTL		0xF224
+#define	F367_OFDM_RCPKTTIME_DISTANCE_LO		0xF22400FF
+
+/* RCFSPYOBS7 */
+#define	R367_OFDM_RCFSPYOBS7		0xF228
+#define	F367_OFDM_RCSPYOBS_SPYFAIL		0xF2280080
+#define	F367_OFDM_RCSPYOBS_SPYFAIL1		0xF2280040
+#define	F367_OFDM_RCSPYOBS_ERROR		0xF2280020
+#define	F367_OFDM_RCSPYOBS_STROUT		0xF2280010
+#define	F367_OFDM_RCSPYOBS_RESULTSTATE1		0xF228000F
+
+/* RCFSPYOBS6 */
+#define	R367_OFDM_RCFSPYOBS6		0xF229
+#define	F367_OFDM_RCSPYOBS_RESULTSTATE0		0xF22900F0
+#define	F367_OFDM_RCSPYOBS_RESULTSTATEM1		0xF229000F
+
+/* RCFSPYOBS5 */
+#define	R367_OFDM_RCFSPYOBS5		0xF22A
+#define	F367_OFDM_RCSPYOBS_BYTEOFPACKET1		0xF22A00FF
+
+/* RCFSPYOBS4 */
+#define	R367_OFDM_RCFSPYOBS4		0xF22B
+#define	F367_OFDM_RCSPYOBS_BYTEVALUE1		0xF22B00FF
+
+/* RCFSPYOBS3 */
+#define	R367_OFDM_RCFSPYOBS3		0xF22C
+#define	F367_OFDM_RCSPYOBS_DATA1		0xF22C00FF
+
+/* RCFSPYOBS2 */
+#define	R367_OFDM_RCFSPYOBS2		0xF22D
+#define	F367_OFDM_RCSPYOBS_DATA0		0xF22D00FF
+
+/* RCFSPYOBS1 */
+#define	R367_OFDM_RCFSPYOBS1		0xF22E
+#define	F367_OFDM_RCSPYOBS_DATAM1		0xF22E00FF
+
+/* RCFSPYOBS0 */
+#define	R367_OFDM_RCFSPYOBS0		0xF22F
+#define	F367_OFDM_RCSPYOBS_DATAM2		0xF22F00FF
+
+/* TSGENERAL */
+#define	R367_TSGENERAL		0xF230
+#define	F367_TSGENERAL_7		0xF2300080
+#define	F367_TSGENERAL_6		0xF2300040
+#define	F367_TSFIFO_BCLK1ALL		0xF2300020
+#define	F367_TSGENERAL_4		0xF2300010
+#define	F367_MUXSTREAM_OUTMODE		0xF2300008
+#define	F367_TSFIFO_PERMPARAL		0xF2300006
+#define	F367_RST_REEDSOLO		0xF2300001
+
+/* RC1SPEED */
+#define	R367_RC1SPEED		0xF231
+#define	F367_TSRCFIFO1_OUTSPEED		0xF23100FF
+
+/* TSGSTATUS */
+#define	R367_TSGSTATUS		0xF232
+#define	F367_TSGSTATUS_7		0xF2320080
+#define	F367_TSGSTATUS_6		0xF2320040
+#define	F367_RSMEM_FULL		0xF2320020
+#define	F367_RS_MULTCALC		0xF2320010
+#define	F367_RSIN_OVERTIME		0xF2320008
+#define	F367_TSFIFO3_DEMODSEL		0xF2320004
+#define	F367_TSFIFO2_DEMODSEL		0xF2320002
+#define	F367_TSFIFO1_DEMODSEL		0xF2320001
+
+
+/* FECM */
+#define	R367_OFDM_FECM		0xF233
+#define	F367_OFDM_DSS_DVB		0xF2330080
+#define	F367_OFDM_DEMOD_BYPASS		0xF2330040
+#define	F367_OFDM_CMP_SLOWMODE		0xF2330020
+#define	F367_OFDM_DSS_SRCH		0xF2330010
+#define	F367_OFDM_FECM_3		0xF2330008
+#define	F367_OFDM_DIFF_MODEVIT		0xF2330004
+#define	F367_OFDM_SYNCVIT		0xF2330002
+#define	F367_OFDM_I2CSYM		0xF2330001
+
+/* VTH12 */
+#define	R367_OFDM_VTH12		0xF234
+#define	F367_OFDM_VTH_12		0xF23400FF
+
+/* VTH23 */
+#define	R367_OFDM_VTH23		0xF235
+#define	F367_OFDM_VTH_23		0xF23500FF
+
+/* VTH34 */
+#define	R367_OFDM_VTH34		0xF236
+#define	F367_OFDM_VTH_34		0xF23600FF
+
+/* VTH56 */
+#define	R367_OFDM_VTH56		0xF237
+#define	F367_OFDM_VTH_56		0xF23700FF
+
+/* VTH67 */
+#define	R367_OFDM_VTH67		0xF238
+#define	F367_OFDM_VTH_67		0xF23800FF
+
+/* VTH78 */
+#define	R367_OFDM_VTH78		0xF239
+#define	F367_OFDM_VTH_78		0xF23900FF
+
+/* VITCURPUN */
+#define	R367_OFDM_VITCURPUN		0xF23A
+#define	F367_OFDM_VIT_MAPPING		0xF23A00E0
+#define	F367_OFDM_VIT_CURPUN		0xF23A001F
+
+/* VERROR */
+#define	R367_OFDM_VERROR		0xF23B
+#define	F367_OFDM_REGERR_VIT		0xF23B00FF
+
+/* PRVIT */
+#define	R367_OFDM_PRVIT		0xF23C
+#define	F367_OFDM_PRVIT_7		0xF23C0080
+#define	F367_OFDM_DIS_VTHLOCK		0xF23C0040
+#define	F367_OFDM_E7_8VIT		0xF23C0020
+#define	F367_OFDM_E6_7VIT		0xF23C0010
+#define	F367_OFDM_E5_6VIT		0xF23C0008
+#define	F367_OFDM_E3_4VIT		0xF23C0004
+#define	F367_OFDM_E2_3VIT		0xF23C0002
+#define	F367_OFDM_E1_2VIT		0xF23C0001
+
+/* VAVSRVIT */
+#define	R367_OFDM_VAVSRVIT		0xF23D
+#define	F367_OFDM_AMVIT		0xF23D0080
+#define	F367_OFDM_FROZENVIT		0xF23D0040
+#define	F367_OFDM_SNVIT		0xF23D0030
+#define	F367_OFDM_TOVVIT		0xF23D000C
+#define	F367_OFDM_HYPVIT		0xF23D0003
+
+/* VSTATUSVIT */
+#define	R367_OFDM_VSTATUSVIT		0xF23E
+#define	F367_OFDM_VITERBI_ON		0xF23E0080
+#define	F367_OFDM_END_LOOPVIT		0xF23E0040
+#define	F367_OFDM_VITERBI_DEPRF		0xF23E0020
+#define	F367_OFDM_PRFVIT		0xF23E0010
+#define	F367_OFDM_LOCKEDVIT		0xF23E0008
+#define	F367_OFDM_VITERBI_DELOCK		0xF23E0004
+#define	F367_OFDM_VIT_DEMODSEL		0xF23E0002
+#define	F367_OFDM_VITERBI_COMPOUT		0xF23E0001
+
+/* VTHINUSE */
+#define	R367_OFDM_VTHINUSE		0xF23F
+#define	F367_OFDM_VIT_INUSE		0xF23F00FF
+
+/* KDIV12 */
+#define	R367_OFDM_KDIV12		0xF240
+#define	F367_OFDM_KDIV12_MANUAL		0xF2400080
+#define	F367_OFDM_K_DIVIDER_12		0xF240007F
+
+/* KDIV23 */
+#define	R367_OFDM_KDIV23		0xF241
+#define	F367_OFDM_KDIV23_MANUAL		0xF2410080
+#define	F367_OFDM_K_DIVIDER_23		0xF241007F
+
+/* KDIV34 */
+#define	R367_OFDM_KDIV34		0xF242
+#define	F367_OFDM_KDIV34_MANUAL		0xF2420080
+#define	F367_OFDM_K_DIVIDER_34		0xF242007F
+
+/* KDIV56 */
+#define	R367_OFDM_KDIV56		0xF243
+#define	F367_OFDM_KDIV56_MANUAL		0xF2430080
+#define	F367_OFDM_K_DIVIDER_56		0xF243007F
+
+/* KDIV67 */
+#define	R367_OFDM_KDIV67		0xF244
+#define	F367_OFDM_KDIV67_MANUAL		0xF2440080
+#define	F367_OFDM_K_DIVIDER_67		0xF244007F
+
+/* KDIV78 */
+#define	R367_OFDM_KDIV78		0xF245
+#define	F367_OFDM_KDIV78_MANUAL		0xF2450080
+#define	F367_OFDM_K_DIVIDER_78		0xF245007F
+
+/* SIGPOWER */
+#define	R367_OFDM_SIGPOWER		0xF246
+#define	F367_OFDM_SIGPOWER_MANUAL		0xF2460080
+#define	F367_OFDM_SIG_POWER		0xF246007F
+
+/* DEMAPVIT */
+#define	R367_OFDM_DEMAPVIT		0xF247
+#define	F367_OFDM_DEMAPVIT_7		0xF2470080
+#define	F367_OFDM_K_DIVIDER_VIT		0xF247007F
+
+/* VITSCALE */
+#define	R367_OFDM_VITSCALE		0xF248
+#define	F367_OFDM_NVTH_NOSRANGE		0xF2480080
+#define	F367_OFDM_VERROR_MAXMODE		0xF2480040
+#define	F367_OFDM_KDIV_MODE		0xF2480030
+#define	F367_OFDM_NSLOWSN_LOCKED		0xF2480008
+#define	F367_OFDM_DELOCK_PRFLOSS		0xF2480004
+#define	F367_OFDM_DIS_RSFLOCK		0xF2480002
+#define	F367_OFDM_VITSCALE_0		0xF2480001
+
+/* FFEC1PRG */
+#define	R367_OFDM_FFEC1PRG		0xF249
+#define	F367_OFDM_FDSS_DVB		0xF2490080
+#define	F367_OFDM_FDSS_SRCH		0xF2490040
+#define	F367_OFDM_FFECPROG_5		0xF2490020
+#define	F367_OFDM_FFECPROG_4		0xF2490010
+#define	F367_OFDM_FFECPROG_3		0xF2490008
+#define	F367_OFDM_FFECPROG_2		0xF2490004
+#define	F367_OFDM_FTS1_DISABLE		0xF2490002
+#define	F367_OFDM_FTS2_DISABLE		0xF2490001
+
+/* FVITCURPUN */
+#define	R367_OFDM_FVITCURPUN		0xF24A
+#define	F367_OFDM_FVIT_MAPPING		0xF24A00E0
+#define	F367_OFDM_FVIT_CURPUN		0xF24A001F
+
+/* FVERROR */
+#define	R367_OFDM_FVERROR		0xF24B
+#define	F367_OFDM_FREGERR_VIT		0xF24B00FF
+
+/* FVSTATUSVIT */
+#define	R367_OFDM_FVSTATUSVIT		0xF24C
+#define	F367_OFDM_FVITERBI_ON		0xF24C0080
+#define	F367_OFDM_F1END_LOOPVIT		0xF24C0040
+#define	F367_OFDM_FVITERBI_DEPRF		0xF24C0020
+#define	F367_OFDM_FPRFVIT		0xF24C0010
+#define	F367_OFDM_FLOCKEDVIT		0xF24C0008
+#define	F367_OFDM_FVITERBI_DELOCK		0xF24C0004
+#define	F367_OFDM_FVIT_DEMODSEL		0xF24C0002
+#define	F367_OFDM_FVITERBI_COMPOUT		0xF24C0001
+
+/* DEBUG_LT1 */
+#define	R367_OFDM_DEBUG_LT1		0xF24D
+#define	F367_OFDM_DBG_LT1		0xF24D00FF
+
+/* DEBUG_LT2 */
+#define	R367_OFDM_DEBUG_LT2		0xF24E
+#define	F367_OFDM_DBG_LT2		0xF24E00FF
+
+/* DEBUG_LT3 */
+#define	R367_OFDM_DEBUG_LT3		0xF24F
+#define	F367_OFDM_DBG_LT3		0xF24F00FF
+
+	/*	TSTSFMET */
+#define	R367_OFDM_TSTSFMET			0xF250
+#define F367_OFDM_TSTSFEC_METRIQUES	0xF25000FF
+
+	/*	SELOUT */
+#define	R367_OFDM_SELOUT				0xF252
+#define	F367_OFDM_EN_SYNC			0xF2520080
+#define	F367_OFDM_EN_TBUSDEMAP       0xF2520040
+#define	F367_OFDM_SELOUT_5			0xF2520020
+#define	F367_OFDM_SELOUT_4			0xF2520010
+#define	F367_OFDM_TSTSYNCHRO_MODE    0xF2520002
+
+	/*	TSYNC */
+#define R367_OFDM_TSYNC				0xF253
+#define F367_OFDM_CURPUN_INCMODE		0xF2530080
+#define F367_OFDM_CERR_TSTMODE		0xF2530040
+#define F367_OFDM_SHIFTSOF_MODE		0xF2530030
+#define F367_OFDM_SLOWPHA_MODE		0xF2530008
+#define F367_OFDM_PXX_BYPALL			0xF2530004
+#define F367_OFDM_FROTA45_FIRST		0xF2530002
+#define F367_OFDM_TST_BCHERROR		0xF2530001
+
+	/*	TSTERR */
+#define R367_OFDM_TSTERR				0xF254
+#define F367_OFDM_TST_LONGPKT		0xF2540080
+#define F367_OFDM_TST_ISSYION		0xF2540040
+#define F367_OFDM_TST_NPDON			0xF2540020
+#define F367_OFDM_TSTERR_4			0xF2540010
+#define F367_OFDM_TRACEBACK_MODE		0xF2540008
+#define F367_OFDM_TST_RSPARITY		0xF2540004
+#define F367_OFDM_METRIQUE_MODE		0xF2540003
+
+	/*	TSFSYNC */
+#define R367_OFDM_TSFSYNC			0xF255
+#define F367_OFDM_EN_SFECSYNC		0xF2550080
+#define F367_OFDM_EN_SFECDEMAP		0xF2550040
+#define F367_OFDM_SFCERR_TSTMODE		0xF2550020
+#define F367_OFDM_SFECPXX_BYPALL		0xF2550010
+#define F367_OFDM_SFECTSTSYNCHRO_MODE 0xF255000F
+
+	/*	TSTSFERR */
+#define R367_OFDM_TSTSFERR			0xF256
+#define F367_OFDM_TSTSTERR_7			0xF2560080
+#define F367_OFDM_TSTSTERR_6			0xF2560040
+#define F367_OFDM_TSTSTERR_5 		0xF2560020
+#define F367_OFDM_TSTSTERR_4			0xF2560010
+#define F367_OFDM_SFECTRACEBACK_MODE	0xF2560008
+#define F367_OFDM_SFEC_NCONVPROG		0xF2560004
+#define F367_OFDM_SFECMETRIQUE_MODE	0xF2560003
+
+	/*	TSTTSSF1 */
+#define R367_OFDM_TSTTSSF1			0xF258
+#define F367_OFDM_TSTERSSF			0xF2580080
+#define F367_OFDM_TSTTSSFEN			0xF2580040
+#define F367_OFDM_SFEC_OUTMODE		0xF2580030
+#define F367_OFDM_XLSF_NOFTHRESHOLD  0xF2580008
+#define F367_OFDM_TSTTSSF_STACKSEL	0xF2580007
+
+	/*	TSTTSSF2 */
+#define R367_OFDM_TSTTSSF2			0xF259
+#define F367_OFDM_DILSF_DBBHEADER	0xF2590080
+#define F367_OFDM_TSTTSSF_DISBUG		0xF2590040
+#define F367_OFDM_TSTTSSF_NOBADSTART	0xF2590020
+#define F367_OFDM_TSTTSSF_SELECT 	0xF259001F
+
+	/*	TSTTSSF3 */
+#define R367_OFDM_TSTTSSF3			0xF25A
+#define F367_OFDM_TSTTSSF3_7			0xF25A0080
+#define F367_OFDM_TSTTSSF3_6			0xF25A0040
+#define F367_OFDM_TSTTSSF3_5			0xF25A0020
+#define F367_OFDM_TSTTSSF3_4			0xF25A0010
+#define F367_OFDM_TSTTSSF3_3			0xF25A0008
+#define F367_OFDM_TSTTSSF3_2			0xF25A0004
+#define F367_OFDM_TSTTSSF3_1			0xF25A0002
+#define F367_OFDM_DISSF_CLKENABLE    0xF25A0001
+
+	/*	TSTTS1 */
+#define R367_OFDM_TSTTS1				0xF25C
+#define F367_OFDM_TSTERS				0xF25C0080
+#define F367_OFDM_TSFIFO_DSSSYNCB	0xF25C0040
+#define F367_OFDM_TSTTS_FSPYBEFRS	0xF25C0020
+#define F367_OFDM_NFORCE_SYNCBYTE	0xF25C0010
+#define F367_OFDM_XL_NOFTHRESHOLD	0xF25C0008
+#define F367_OFDM_TSTTS_FRFORCEPKT	0xF25C0004
+#define F367_OFDM_DESCR_NOTAUTO		0xF25C0002
+#define F367_OFDM_TSTTSEN			0xF25C0001
+
+	/*	TSTTS2 */
+#define R367_OFDM_TSTTS2				0xF25D
+#define F367_OFDM_DIL_DBBHEADER		0xF25D0080
+#define F367_OFDM_TSTTS_NOBADXXX		0xF25D0040
+#define F367_OFDM_TSFIFO_DELSPEEDUP	0xF25D0020
+#define F367_OFDM_TSTTS_SELECT		0xF25D001F
+
+	/*	TSTTS3 */
+#define R367_OFDM_TSTTS3				0xF25E
+#define F367_OFDM_TSTTS_NOPKTGAIN	0xF25E0080
+#define F367_OFDM_TSTTS_NOPKTENE		0xF25E0040
+#define F367_OFDM_TSTTS_ISOLATION	0xF25E0020
+#define F367_OFDM_TSTTS_DISBUG		0xF25E0010
+#define F367_OFDM_TSTTS_NOBADSTART	0xF25E0008
+#define F367_OFDM_TSTTS_STACKSEL		0xF25E0007
+
+	/*	TSTTS4 */
+#define R367_OFDM_TSTTS4				0xF25F
+#define F367_OFDM_TSTTS4_7			0xF25F0080
+#define F367_OFDM_TSTTS4_6			0xF25F0040
+#define F367_OFDM_TSTTS4_5			0xF25F0020
+#define F367_OFDM_TSTTS_DISDSTATE	0xF25F0010
+#define F367_OFDM_TSTTS_FASTNOSYNC	0xF25F0008
+#define F367_OFDM_EXT_FECSPYIN		0xF25F0004
+#define F367_OFDM_TSTTS_NODPZERO		0xF25F0002
+#define F367_OFDM_TSTTS_NODIV3		0xF25F0001
+
+	/*	TSTTSRC */
+#define R367_OFDM_TSTTSRC				0xF26C
+#define F367_OFDM_TSTTSRC_7				0xF26C0080
+#define F367_OFDM_TSRCFIFO_DSSSYNCB		0xF26C0040
+#define F367_OFDM_TSRCFIFO_DPUNACTIVE	0xF26C0020
+#define F367_OFDM_TSRCFIFO_DELSPEEDUP	0xF26C0010
+#define F367_OFDM_TSTTSRC_NODIV3			0xF26C0008
+#define F367_OFDM_TSTTSRC_FRFORCEPKT		0xF26C0004
+#define F367_OFDM_SAT25_SDDORIGINE		0xF26C0002
+#define F367_OFDM_TSTTSRC_INACTIVE		0xF26C0001
+
+	/*	TSTTSRS */
+#define R367_OFDM_TSTTSRS				0xF26D
+#define F367_OFDM_TSTTSRS_7				0xF26D0080
+#define F367_OFDM_TSTTSRS_6				0xF26D0040
+#define F367_OFDM_TSTTSRS_5				0xF26D0020
+#define F367_OFDM_TSTTSRS_4				0xF26D0010
+#define F367_OFDM_TSTTSRS_3				0xF26D0008
+#define F367_OFDM_TSTTSRS_2				0xF26D0004
+#define F367_OFDM_TSTRS_DISRS2			0xF26D0002
+#define F367_OFDM_TSTRS_DISRS1			0xF26D0001
+
+/* TSSTATEM */
+#define	R367_OFDM_TSSTATEM		0xF270
+#define	F367_OFDM_TSDIL_ON		0xF2700080
+#define	F367_OFDM_TSSKIPRS_ON		0xF2700040
+#define	F367_OFDM_TSRS_ON		0xF2700020
+#define	F367_OFDM_TSDESCRAMB_ON		0xF2700010
+#define	F367_OFDM_TSFRAME_MODE		0xF2700008
+#define	F367_OFDM_TS_DISABLE		0xF2700004
+#define	F367_OFDM_TSACM_MODE		0xF2700002
+#define	F367_OFDM_TSOUT_NOSYNC		0xF2700001
+
+/* TSSTATEL */
+#define	R367_OFDM_TSSTATEL		0xF271
+#define	F367_OFDM_TSNOSYNCBYTE		0xF2710080
+#define	F367_OFDM_TSPARITY_ON		0xF2710040
+#define	F367_OFDM_TSSYNCOUTRS_ON		0xF2710020
+#define	F367_OFDM_TSDVBS2_MODE		0xF2710010
+#define	F367_OFDM_TSISSYI_ON		0xF2710008
+#define	F367_OFDM_TSNPD_ON		0xF2710004
+#define	F367_OFDM_TSCRC8_ON		0xF2710002
+#define	F367_OFDM_TSDSS_PACKET		0xF2710001
+
+/* TSCFGH */
+#define	R367_OFDM_TSCFGH		0xF272
+#define	F367_OFDM_TSFIFO_DVBCI		0xF2720080
+#define	F367_OFDM_TSFIFO_SERIAL		0xF2720040
+#define	F367_OFDM_TSFIFO_TEIUPDATE		0xF2720020
+#define	F367_OFDM_TSFIFO_DUTY50		0xF2720010
+#define	F367_OFDM_TSFIFO_HSGNLOUT		0xF2720008
+#define	F367_OFDM_TSFIFO_ERRMODE		0xF2720006
+#define	F367_OFDM_RST_HWARE		0xF2720001
+
+/* TSCFGM */
+#define	R367_OFDM_TSCFGM		0xF273
+#define	F367_OFDM_TSFIFO_MANSPEED		0xF27300C0
+#define	F367_OFDM_TSFIFO_PERMDATA		0xF2730020
+#define	F367_OFDM_TSFIFO_NONEWSGNL		0xF2730010
+#define	F367_OFDM_TSFIFO_BITSPEED		0xF2730008
+#define	F367_OFDM_NPD_SPECDVBS2		0xF2730004
+#define	F367_OFDM_TSFIFO_STOPCKDIS		0xF2730002
+#define	F367_OFDM_TSFIFO_INVDATA		0xF2730001
+
+/* TSCFGL */
+#define	R367_OFDM_TSCFGL		0xF274
+#define	F367_OFDM_TSFIFO_BCLKDEL1CK		0xF27400C0
+#define	F367_OFDM_BCHERROR_MODE		0xF2740030
+#define	F367_OFDM_TSFIFO_NSGNL2DATA		0xF2740008
+#define	F367_OFDM_TSFIFO_EMBINDVB		0xF2740004
+#define	F367_OFDM_TSFIFO_DPUNACT		0xF2740002
+#define	F367_OFDM_TSFIFO_NPDOFF		0xF2740001
+
+/* TSSYNC */
+#define	R367_OFDM_TSSYNC		0xF275
+#define	F367_OFDM_TSFIFO_PERMUTE		0xF2750080
+#define	F367_OFDM_TSFIFO_FISCR3B		0xF2750060
+#define	F367_OFDM_TSFIFO_SYNCMODE		0xF2750018
+#define	F367_OFDM_TSFIFO_SYNCSEL		0xF2750007
+
+/* TSINSDELH */
+#define	R367_OFDM_TSINSDELH		0xF276
+#define	F367_OFDM_TSDEL_SYNCBYTE		0xF2760080
+#define	F367_OFDM_TSDEL_XXHEADER		0xF2760040
+#define	F367_OFDM_TSDEL_BBHEADER		0xF2760020
+#define	F367_OFDM_TSDEL_DATAFIELD		0xF2760010
+#define	F367_OFDM_TSINSDEL_ISCR		0xF2760008
+#define	F367_OFDM_TSINSDEL_NPD		0xF2760004
+#define	F367_OFDM_TSINSDEL_RSPARITY		0xF2760002
+#define	F367_OFDM_TSINSDEL_CRC8		0xF2760001
+
+/* TSINSDELM */
+#define	R367_OFDM_TSINSDELM		0xF277
+#define	F367_OFDM_TSINS_BBPADDING		0xF2770080
+#define	F367_OFDM_TSINS_BCHFEC		0xF2770040
+#define	F367_OFDM_TSINS_LDPCFEC		0xF2770020
+#define	F367_OFDM_TSINS_EMODCOD		0xF2770010
+#define	F367_OFDM_TSINS_TOKEN		0xF2770008
+#define	F367_OFDM_TSINS_XXXERR		0xF2770004
+#define	F367_OFDM_TSINS_MATYPE		0xF2770002
+#define	F367_OFDM_TSINS_UPL		0xF2770001
+
+/* TSINSDELL */
+#define	R367_OFDM_TSINSDELL		0xF278
+#define	F367_OFDM_TSINS_DFL		0xF2780080
+#define	F367_OFDM_TSINS_SYNCD		0xF2780040
+#define	F367_OFDM_TSINS_BLOCLEN		0xF2780020
+#define	F367_OFDM_TSINS_SIGPCOUNT		0xF2780010
+#define	F367_OFDM_TSINS_FIFO		0xF2780008
+#define	F367_OFDM_TSINS_REALPACK		0xF2780004
+#define	F367_OFDM_TSINS_TSCONFIG		0xF2780002
+#define	F367_OFDM_TSINS_LATENCY		0xF2780001
+
+/* TSDIVN */
+#define	R367_OFDM_TSDIVN		0xF279
+#define	F367_OFDM_TSFIFO_LOWSPEED		0xF2790080
+#define	F367_OFDM_BYTE_OVERSAMPLING		0xF2790070
+#define	F367_OFDM_TSMANUAL_PACKETNBR		0xF279000F
+
+/* TSDIVPM */
+#define	R367_OFDM_TSDIVPM		0xF27A
+#define	F367_OFDM_TSMANUAL_P_HI		0xF27A00FF
+
+/* TSDIVPL */
+#define	R367_OFDM_TSDIVPL		0xF27B
+#define	F367_OFDM_TSMANUAL_P_LO		0xF27B00FF
+
+/* TSDIVQM */
+#define	R367_OFDM_TSDIVQM		0xF27C
+#define	F367_OFDM_TSMANUAL_Q_HI		0xF27C00FF
+
+/* TSDIVQL */
+#define	R367_OFDM_TSDIVQL		0xF27D
+#define	F367_OFDM_TSMANUAL_Q_LO		0xF27D00FF
+
+/* TSDILSTKM */
+#define	R367_OFDM_TSDILSTKM		0xF27E
+#define	F367_OFDM_TSFIFO_DILSTK_HI		0xF27E00FF
+
+/* TSDILSTKL */
+#define	R367_OFDM_TSDILSTKL		0xF27F
+#define	F367_OFDM_TSFIFO_DILSTK_LO		0xF27F00FF
+
+/* TSSPEED */
+#define	R367_OFDM_TSSPEED		0xF280
+#define	F367_OFDM_TSFIFO_OUTSPEED		0xF28000FF
+
+/* TSSTATUS */
+#define	R367_OFDM_TSSTATUS		0xF281
+#define	F367_OFDM_TSFIFO_LINEOK		0xF2810080
+#define	F367_OFDM_TSFIFO_ERROR		0xF2810040
+#define	F367_OFDM_TSFIFO_DATA7		0xF2810020
+#define	F367_OFDM_TSFIFO_NOSYNC		0xF2810010
+#define	F367_OFDM_ISCR_INITIALIZED		0xF2810008
+#define	F367_OFDM_ISCR_UPDATED		0xF2810004
+#define	F367_OFDM_SOFFIFO_UNREGUL		0xF2810002
+#define	F367_OFDM_DIL_READY		0xF2810001
+
+/* TSSTATUS2 */
+#define	R367_OFDM_TSSTATUS2		0xF282
+#define	F367_OFDM_TSFIFO_DEMODSEL		0xF2820080
+#define	F367_OFDM_TSFIFOSPEED_STORE		0xF2820040
+#define	F367_OFDM_DILXX_RESET		0xF2820020
+#define	F367_OFDM_TSSERIAL_IMPOSSIBLE		0xF2820010
+#define	F367_OFDM_TSFIFO_UNDERSPEED		0xF2820008
+#define	F367_OFDM_BITSPEED_EVENT		0xF2820004
+#define	F367_OFDM_UL_SCRAMBDETECT		0xF2820002
+#define	F367_OFDM_ULDTV67_FALSELOCK		0xF2820001
+
+/* TSBITRATEM */
+#define	R367_OFDM_TSBITRATEM		0xF283
+#define	F367_OFDM_TSFIFO_BITRATE_HI		0xF28300FF
+
+/* TSBITRATEL */
+#define	R367_OFDM_TSBITRATEL		0xF284
+#define	F367_OFDM_TSFIFO_BITRATE_LO		0xF28400FF
+
+/* TSPACKLENM */
+#define	R367_OFDM_TSPACKLENM		0xF285
+#define	F367_OFDM_TSFIFO_PACKCPT		0xF28500E0
+#define	F367_OFDM_DIL_RPLEN_HI		0xF285001F
+
+/* TSPACKLENL */
+#define	R367_OFDM_TSPACKLENL		0xF286
+#define	F367_OFDM_DIL_RPLEN_LO		0xF28600FF
+
+/* TSBLOCLENM */
+#define	R367_OFDM_TSBLOCLENM		0xF287
+#define	F367_OFDM_TSFIFO_PFLEN_HI		0xF28700FF
+
+/* TSBLOCLENL */
+#define	R367_OFDM_TSBLOCLENL		0xF288
+#define	F367_OFDM_TSFIFO_PFLEN_LO		0xF28800FF
+
+/* TSDLYH */
+#define	R367_OFDM_TSDLYH		0xF289
+#define	F367_OFDM_SOFFIFO_TSTIMEVALID		0xF2890080
+#define	F367_OFDM_SOFFIFO_SPEEDUP		0xF2890040
+#define	F367_OFDM_SOFFIFO_STOP		0xF2890020
+#define	F367_OFDM_SOFFIFO_REGULATED		0xF2890010
+#define	F367_OFDM_SOFFIFO_REALSBOFF_HI		0xF289000F
+
+/* TSDLYM */
+#define	R367_OFDM_TSDLYM		0xF28A
+#define	F367_OFDM_SOFFIFO_REALSBOFF_MED		0xF28A00FF
+
+/* TSDLYL */
+#define	R367_OFDM_TSDLYL		0xF28B
+#define	F367_OFDM_SOFFIFO_REALSBOFF_LO		0xF28B00FF
+
+/* TSNPDAV */
+#define	R367_OFDM_TSNPDAV		0xF28C
+#define	F367_OFDM_TSNPD_AVERAGE		0xF28C00FF
+
+/* TSBUFSTATH */
+#define	R367_OFDM_TSBUFSTATH		0xF28D
+#define	F367_OFDM_TSISCR_3BYTES		0xF28D0080
+#define	F367_OFDM_TSISCR_NEWDATA		0xF28D0040
+#define	F367_OFDM_TSISCR_BUFSTAT_HI		0xF28D003F
+
+/* TSBUFSTATM */
+#define	R367_OFDM_TSBUFSTATM		0xF28E
+#define	F367_OFDM_TSISCR_BUFSTAT_MED		0xF28E00FF
+
+/* TSBUFSTATL */
+#define	R367_OFDM_TSBUFSTATL		0xF28F
+#define	F367_OFDM_TSISCR_BUFSTAT_LO		0xF28F00FF
+
+/* TSDEBUGM */
+#define	R367_OFDM_TSDEBUGM		0xF290
+#define	F367_OFDM_TSFIFO_ILLPACKET		0xF2900080
+#define	F367_OFDM_DIL_NOSYNC		0xF2900040
+#define	F367_OFDM_DIL_ISCR		0xF2900020
+#define	F367_OFDM_DILOUT_BSYNCB		0xF2900010
+#define	F367_OFDM_TSFIFO_EMPTYPKT		0xF2900008
+#define	F367_OFDM_TSFIFO_EMPTYRD		0xF2900004
+#define	F367_OFDM_SOFFIFO_STOPM		0xF2900002
+#define	F367_OFDM_SOFFIFO_SPEEDUPM		0xF2900001
+
+/* TSDEBUGL */
+#define	R367_OFDM_TSDEBUGL		0xF291
+#define	F367_OFDM_TSFIFO_PACKLENFAIL		0xF2910080
+#define	F367_OFDM_TSFIFO_SYNCBFAIL		0xF2910040
+#define	F367_OFDM_TSFIFO_VITLIBRE		0xF2910020
+#define	F367_OFDM_TSFIFO_BOOSTSPEEDM		0xF2910010
+#define	F367_OFDM_TSFIFO_UNDERSPEEDM		0xF2910008
+#define	F367_OFDM_TSFIFO_ERROR_EVNT		0xF2910004
+#define	F367_OFDM_TSFIFO_FULL		0xF2910002
+#define	F367_OFDM_TSFIFO_OVERFLOWM		0xF2910001
+
+/* TSDLYSETH */
+#define	R367_OFDM_TSDLYSETH		0xF292
+#define	F367_OFDM_SOFFIFO_OFFSET		0xF29200E0
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_HI		0xF292001F
+
+/* TSDLYSETM */
+#define	R367_OFDM_TSDLYSETM		0xF293
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_MED		0xF29300FF
+
+/* TSDLYSETL */
+#define	R367_OFDM_TSDLYSETL		0xF294
+#define	F367_OFDM_SOFFIFO_SYMBOFFSET_LO		0xF29400FF
+
+/* TSOBSCFG */
+#define	R367_OFDM_TSOBSCFG		0xF295
+#define	F367_OFDM_TSFIFO_OBSCFG		0xF29500FF
+
+/* TSOBSM */
+#define	R367_OFDM_TSOBSM		0xF296
+#define	F367_OFDM_TSFIFO_OBSDATA_HI		0xF29600FF
+
+/* TSOBSL */
+#define	R367_OFDM_TSOBSL		0xF297
+#define	F367_OFDM_TSFIFO_OBSDATA_LO		0xF29700FF
+
+/* ERRCTRL1 */
+#define	R367_OFDM_ERRCTRL1		0xF298
+#define	F367_OFDM_ERR_SRC1		0xF29800F0
+#define	F367_OFDM_ERRCTRL1_3		0xF2980008
+#define	F367_OFDM_NUM_EVT1		0xF2980007
+
+/* ERRCNT1H */
+#define	R367_OFDM_ERRCNT1H		0xF299
+#define	F367_OFDM_ERRCNT1_OLDVALUE		0xF2990080
+#define	F367_OFDM_ERR_CNT1		0xF299007F
+
+/* ERRCNT1M */
+#define	R367_OFDM_ERRCNT1M		0xF29A
+#define	F367_OFDM_ERR_CNT1_HI		0xF29A00FF
+
+/* ERRCNT1L */
+#define	R367_OFDM_ERRCNT1L		0xF29B
+#define	F367_OFDM_ERR_CNT1_LO		0xF29B00FF
+
+/* ERRCTRL2 */
+#define	R367_OFDM_ERRCTRL2		0xF29C
+#define	F367_OFDM_ERR_SRC2		0xF29C00F0
+#define	F367_OFDM_ERRCTRL2_3		0xF29C0008
+#define	F367_OFDM_NUM_EVT2		0xF29C0007
+
+/* ERRCNT2H */
+#define	R367_OFDM_ERRCNT2H		0xF29D
+#define	F367_OFDM_ERRCNT2_OLDVALUE		0xF29D0080
+#define	F367_OFDM_ERR_CNT2_HI		0xF29D007F
+
+/* ERRCNT2M */
+#define	R367_OFDM_ERRCNT2M		0xF29E
+#define	F367_OFDM_ERR_CNT2_MED		0xF29E00FF
+
+/* ERRCNT2L */
+#define	R367_OFDM_ERRCNT2L		0xF29F
+#define	F367_OFDM_ERR_CNT2_LO		0xF29F00FF
+
+/* FECSPY */
+#define	R367_OFDM_FECSPY		0xF2A0
+#define	F367_OFDM_SPY_ENABLE		0xF2A00080
+#define	F367_OFDM_NO_SYNCBYTE		0xF2A00040
+#define	F367_OFDM_SERIAL_MODE		0xF2A00020
+#define	F367_OFDM_UNUSUAL_PACKET		0xF2A00010
+#define	F367_OFDM_BERMETER_DATAMODE		0xF2A0000C
+#define	F367_OFDM_BERMETER_LMODE		0xF2A00002
+#define	F367_OFDM_BERMETER_RESET		0xF2A00001
+
+/* FSPYCFG */
+#define	R367_OFDM_FSPYCFG		0xF2A1
+#define	F367_OFDM_FECSPY_INPUT		0xF2A100C0
+#define	F367_OFDM_RST_ON_ERROR		0xF2A10020
+#define	F367_OFDM_ONE_SHOT		0xF2A10010
+#define	F367_OFDM_I2C_MOD		0xF2A1000C
+#define	F367_OFDM_SPY_HYSTERESIS		0xF2A10003
+
+/* FSPYDATA */
+#define	R367_OFDM_FSPYDATA		0xF2A2
+#define	F367_OFDM_SPY_STUFFING		0xF2A20080
+#define	F367_OFDM_NOERROR_PKTJITTER		0xF2A20040
+#define	F367_OFDM_SPY_CNULLPKT		0xF2A20020
+#define	F367_OFDM_SPY_OUTDATA_MODE		0xF2A2001F
+
+/* FSPYOUT */
+#define	R367_OFDM_FSPYOUT		0xF2A3
+#define	F367_OFDM_FSPY_DIRECT		0xF2A30080
+#define	F367_OFDM_FSPYOUT_6		0xF2A30040
+#define	F367_OFDM_SPY_OUTDATA_BUS		0xF2A30038
+#define	F367_OFDM_STUFF_MODE		0xF2A30007
+
+/* FSTATUS */
+#define	R367_OFDM_FSTATUS		0xF2A4
+#define	F367_OFDM_SPY_ENDSIM		0xF2A40080
+#define	F367_OFDM_VALID_SIM		0xF2A40040
+#define	F367_OFDM_FOUND_SIGNAL		0xF2A40020
+#define	F367_OFDM_DSS_SYNCBYTE		0xF2A40010
+#define	F367_OFDM_RESULT_STATE		0xF2A4000F
+
+/* FGOODPACK */
+#define	R367_OFDM_FGOODPACK		0xF2A5
+#define	F367_OFDM_FGOOD_PACKET		0xF2A500FF
+
+/* FPACKCNT */
+#define	R367_OFDM_FPACKCNT		0xF2A6
+#define	F367_OFDM_FPACKET_COUNTER		0xF2A600FF
+
+/* FSPYMISC */
+#define	R367_OFDM_FSPYMISC		0xF2A7
+#define	F367_OFDM_FLABEL_COUNTER		0xF2A700FF
+
+/* FBERCPT4 */
+#define	R367_OFDM_FBERCPT4		0xF2A8
+#define	F367_OFDM_FBERMETER_CPT5		0xF2A800FF
+
+/* FBERCPT3 */
+#define	R367_OFDM_FBERCPT3		0xF2A9
+#define	F367_OFDM_FBERMETER_CPT4		0xF2A900FF
+
+/* FBERCPT2 */
+#define	R367_OFDM_FBERCPT2		0xF2AA
+#define	F367_OFDM_FBERMETER_CPT3		0xF2AA00FF
+
+/* FBERCPT1 */
+#define	R367_OFDM_FBERCPT1		0xF2AB
+#define	F367_OFDM_FBERMETER_CPT2		0xF2AB00FF
+
+/* FBERCPT0 */
+#define	R367_OFDM_FBERCPT0		0xF2AC
+#define	F367_OFDM_FBERMETER_CPT1		0xF2AC00FF
+
+/* FBERERR2 */
+#define	R367_OFDM_FBERERR2		0xF2AD
+#define	F367_OFDM_FBERMETER_ERR_HI		0xF2AD00FF
+
+/* FBERERR1 */
+#define	R367_OFDM_FBERERR1		0xF2AE
+#define	F367_OFDM_FBERMETER_ERR_MED		0xF2AE00FF
+
+/* FBERERR0 */
+#define	R367_OFDM_FBERERR0		0xF2AF
+#define	F367_OFDM_FBERMETER_ERR_LO		0xF2AF00FF
+
+/* FSTATESM */
+#define	R367_OFDM_FSTATESM		0xF2B0
+#define	F367_OFDM_RSTATE_F		0xF2B00080
+#define	F367_OFDM_RSTATE_E		0xF2B00040
+#define	F367_OFDM_RSTATE_D		0xF2B00020
+#define	F367_OFDM_RSTATE_C		0xF2B00010
+#define	F367_OFDM_RSTATE_B		0xF2B00008
+#define	F367_OFDM_RSTATE_A		0xF2B00004
+#define	F367_OFDM_RSTATE_9		0xF2B00002
+#define	F367_OFDM_RSTATE_8		0xF2B00001
+
+/* FSTATESL */
+#define	R367_OFDM_FSTATESL		0xF2B1
+#define	F367_OFDM_RSTATE_7		0xF2B10080
+#define	F367_OFDM_RSTATE_6		0xF2B10040
+#define	F367_OFDM_RSTATE_5		0xF2B10020
+#define	F367_OFDM_RSTATE_4		0xF2B10010
+#define	F367_OFDM_RSTATE_3		0xF2B10008
+#define	F367_OFDM_RSTATE_2		0xF2B10004
+#define	F367_OFDM_RSTATE_1		0xF2B10002
+#define	F367_OFDM_RSTATE_0		0xF2B10001
+
+/* FSPYBER */
+#define	R367_OFDM_FSPYBER		0xF2B2
+#define	F367_OFDM_FSPYBER_7		0xF2B20080
+#define	F367_OFDM_FSPYOBS_XORREAD		0xF2B20040
+#define	F367_OFDM_FSPYBER_OBSMODE		0xF2B20020
+#define	F367_OFDM_FSPYBER_SYNCBYTE		0xF2B20010
+#define	F367_OFDM_FSPYBER_UNSYNC		0xF2B20008
+#define	F367_OFDM_FSPYBER_CTIME		0xF2B20007
+
+/* FSPYDISTM */
+#define	R367_OFDM_FSPYDISTM		0xF2B3
+#define	F367_OFDM_PKTTIME_DISTANCE_HI		0xF2B300FF
+
+/* FSPYDISTL */
+#define	R367_OFDM_FSPYDISTL		0xF2B4
+#define	F367_OFDM_PKTTIME_DISTANCE_LO		0xF2B400FF
+
+/* FSPYOBS7 */
+#define	R367_OFDM_FSPYOBS7		0xF2B8
+#define	F367_OFDM_FSPYOBS_SPYFAIL		0xF2B80080
+#define	F367_OFDM_FSPYOBS_SPYFAIL1		0xF2B80040
+#define	F367_OFDM_FSPYOBS_ERROR		0xF2B80020
+#define	F367_OFDM_FSPYOBS_STROUT		0xF2B80010
+#define	F367_OFDM_FSPYOBS_RESULTSTATE1		0xF2B8000F
+
+/* FSPYOBS6 */
+#define	R367_OFDM_FSPYOBS6		0xF2B9
+#define	F367_OFDM_FSPYOBS_RESULTSTATE0		0xF2B900F0
+#define	F367_OFDM_FSPYOBS_RESULTSTATEM1		0xF2B9000F
+
+/* FSPYOBS5 */
+#define	R367_OFDM_FSPYOBS5		0xF2BA
+#define	F367_OFDM_FSPYOBS_BYTEOFPACKET1		0xF2BA00FF
+
+/* FSPYOBS4 */
+#define	R367_OFDM_FSPYOBS4		0xF2BB
+#define	F367_OFDM_FSPYOBS_BYTEVALUE1		0xF2BB00FF
+
+/* FSPYOBS3 */
+#define	R367_OFDM_FSPYOBS3		0xF2BC
+#define	F367_OFDM_FSPYOBS_DATA1		0xF2BC00FF
+
+/* FSPYOBS2 */
+#define	R367_OFDM_FSPYOBS2		0xF2BD
+#define	F367_OFDM_FSPYOBS_DATA0		0xF2BD00FF
+
+/* FSPYOBS1 */
+#define	R367_OFDM_FSPYOBS1		0xF2BE
+#define	F367_OFDM_FSPYOBS_DATAM1		0xF2BE00FF
+
+/* FSPYOBS0 */
+#define	R367_OFDM_FSPYOBS0		0xF2BF
+#define	F367_OFDM_FSPYOBS_DATAM2		0xF2BF00FF
+
+/* SFDEMAP */
+#define	R367_OFDM_SFDEMAP		0xF2C0
+#define	F367_OFDM_SFDEMAP_7		0xF2C00080
+#define	F367_OFDM_SFEC_K_DIVIDER_VIT		0xF2C0007F
+
+/* SFERROR */
+#define	R367_OFDM_SFERROR		0xF2C1
+#define	F367_OFDM_SFEC_REGERR_VIT		0xF2C100FF
+
+/* SFAVSR */
+#define	R367_OFDM_SFAVSR		0xF2C2
+#define	F367_OFDM_SFEC_SUMERRORS		0xF2C20080
+#define	F367_OFDM_SERROR_MAXMODE		0xF2C20040
+#define	F367_OFDM_SN_SFEC		0xF2C20030
+#define	F367_OFDM_KDIV_MODE_SFEC		0xF2C2000C
+#define	F367_OFDM_SFAVSR_1		0xF2C20002
+#define	F367_OFDM_SFAVSR_0		0xF2C20001
+
+/* SFECSTATUS */
+#define	R367_OFDM_SFECSTATUS		0xF2C3
+#define	F367_OFDM_SFEC_ON		0xF2C30080
+#define	F367_OFDM_SFSTATUS_6		0xF2C30040
+#define	F367_OFDM_SFSTATUS_5		0xF2C30020
+#define	F367_OFDM_SFSTATUS_4		0xF2C30010
+#define	F367_OFDM_LOCKEDSFEC		0xF2C30008
+#define	F367_OFDM_SFEC_DELOCK		0xF2C30004
+#define	F367_OFDM_SFEC_DEMODSEL1		0xF2C30002
+#define	F367_OFDM_SFEC_OVFON		0xF2C30001
+
+/* SFKDIV12 */
+#define	R367_OFDM_SFKDIV12		0xF2C4
+#define	F367_OFDM_SFECKDIV12_MAN		0xF2C40080
+#define	F367_OFDM_SFEC_K_DIVIDER_12		0xF2C4007F
+
+/* SFKDIV23 */
+#define	R367_OFDM_SFKDIV23		0xF2C5
+#define	F367_OFDM_SFECKDIV23_MAN		0xF2C50080
+#define	F367_OFDM_SFEC_K_DIVIDER_23		0xF2C5007F
+
+/* SFKDIV34 */
+#define	R367_OFDM_SFKDIV34		0xF2C6
+#define	F367_OFDM_SFECKDIV34_MAN		0xF2C60080
+#define	F367_OFDM_SFEC_K_DIVIDER_34		0xF2C6007F
+
+/* SFKDIV56 */
+#define	R367_OFDM_SFKDIV56		0xF2C7
+#define	F367_OFDM_SFECKDIV56_MAN		0xF2C70080
+#define	F367_OFDM_SFEC_K_DIVIDER_56		0xF2C7007F
+
+/* SFKDIV67 */
+#define	R367_OFDM_SFKDIV67		0xF2C8
+#define	F367_OFDM_SFECKDIV67_MAN		0xF2C80080
+#define	F367_OFDM_SFEC_K_DIVIDER_67		0xF2C8007F
+
+/* SFKDIV78 */
+#define	R367_OFDM_SFKDIV78		0xF2C9
+#define	F367_OFDM_SFECKDIV78_MAN		0xF2C90080
+#define	F367_OFDM_SFEC_K_DIVIDER_78		0xF2C9007F
+
+/* SFDILSTKM */
+#define	R367_OFDM_SFDILSTKM		0xF2CA
+#define	F367_OFDM_SFEC_PACKCPT		0xF2CA00E0
+#define	F367_OFDM_SFEC_DILSTK_HI		0xF2CA001F
+
+/* SFDILSTKL */
+#define	R367_OFDM_SFDILSTKL		0xF2CB
+#define	F367_OFDM_SFEC_DILSTK_LO		0xF2CB00FF
+
+/* SFSTATUS */
+#define	R367_OFDM_SFSTATUS		0xF2CC
+#define	F367_OFDM_SFEC_LINEOK		0xF2CC0080
+#define	F367_OFDM_SFEC_ERROR		0xF2CC0040
+#define	F367_OFDM_SFEC_DATA7		0xF2CC0020
+#define	F367_OFDM_SFEC_OVERFLOW		0xF2CC0010
+#define	F367_OFDM_SFEC_DEMODSEL2		0xF2CC0008
+#define	F367_OFDM_SFEC_NOSYNC		0xF2CC0004
+#define	F367_OFDM_SFEC_UNREGULA		0xF2CC0002
+#define	F367_OFDM_SFEC_READY		0xF2CC0001
+
+/* SFDLYH */
+#define	R367_OFDM_SFDLYH		0xF2CD
+#define	F367_OFDM_SFEC_TSTIMEVALID		0xF2CD0080
+#define	F367_OFDM_SFEC_SPEEDUP		0xF2CD0040
+#define	F367_OFDM_SFEC_STOP		0xF2CD0020
+#define	F367_OFDM_SFEC_REGULATED		0xF2CD0010
+#define	F367_OFDM_SFEC_REALSYMBOFFSET		0xF2CD000F
+
+/* SFDLYM */
+#define	R367_OFDM_SFDLYM		0xF2CE
+#define	F367_OFDM_SFEC_REALSYMBOFFSET_HI		0xF2CE00FF
+
+/* SFDLYL */
+#define	R367_OFDM_SFDLYL		0xF2CF
+#define	F367_OFDM_SFEC_REALSYMBOFFSET_LO		0xF2CF00FF
+
+/* SFDLYSETH */
+#define	R367_OFDM_SFDLYSETH		0xF2D0
+#define	F367_OFDM_SFEC_OFFSET		0xF2D000E0
+#define	F367_OFDM_SFECDLYSETH_4		0xF2D00010
+#define	F367_OFDM_RST_SFEC		0xF2D00008
+#define	F367_OFDM_SFECDLYSETH_2		0xF2D00004
+#define	F367_OFDM_SFEC_DISABLE		0xF2D00002
+#define	F367_OFDM_SFEC_UNREGUL		0xF2D00001
+
+/* SFDLYSETM */
+#define	R367_OFDM_SFDLYSETM		0xF2D1
+#define	F367_OFDM_SFECDLYSETM_7		0xF2D10080
+#define	F367_OFDM_SFEC_SYMBOFFSET_HI		0xF2D1007F
+
+/* SFDLYSETL */
+#define	R367_OFDM_SFDLYSETL		0xF2D2
+#define	F367_OFDM_SFEC_SYMBOFFSET_LO		0xF2D200FF
+
+/* SFOBSCFG */
+#define	R367_OFDM_SFOBSCFG		0xF2D3
+#define	F367_OFDM_SFEC_OBSCFG		0xF2D300FF
+
+/* SFOBSM */
+#define	R367_OFDM_SFOBSM		0xF2D4
+#define	F367_OFDM_SFEC_OBSDATA_HI		0xF2D400FF
+
+/* SFOBSL */
+#define	R367_OFDM_SFOBSL		0xF2D5
+#define	F367_OFDM_SFEC_OBSDATA_LO		0xF2D500FF
+
+/* SFECINFO */
+#define	R367_OFDM_SFECINFO		0xF2D6
+#define	F367_OFDM_SFECINFO_7		0xF2D60080
+#define	F367_OFDM_SFEC_SYNCDLSB		0xF2D60070
+#define	F367_OFDM_SFCE_S1CPHASE		0xF2D6000F
+
+/* SFERRCTRL */
+#define	R367_OFDM_SFERRCTRL		0xF2D8
+#define	F367_OFDM_SFEC_ERR_SOURCE		0xF2D800F0
+#define	F367_OFDM_SFERRCTRL_3		0xF2D80008
+#define	F367_OFDM_SFEC_NUM_EVENT		0xF2D80007
+
+/* SFERRCNTH */
+#define	R367_OFDM_SFERRCNTH		0xF2D9
+#define	F367_OFDM_SFERRC_OLDVALUE		0xF2D90080
+#define	F367_OFDM_SFEC_ERR_CNT		0xF2D9007F
+
+/* SFERRCNTM */
+#define	R367_OFDM_SFERRCNTM		0xF2DA
+#define	F367_OFDM_SFEC_ERR_CNT_HI		0xF2DA00FF
+
+/* SFERRCNTL */
+#define	R367_OFDM_SFERRCNTL		0xF2DB
+#define	F367_OFDM_SFEC_ERR_CNT_LO		0xF2DB00FF
+
+/* SYMBRATEM */
+#define	R367_OFDM_SYMBRATEM		0xF2E0
+#define	F367_OFDM_DEFGEN_SYMBRATE_HI		0xF2E000FF
+
+/* SYMBRATEL */
+#define	R367_OFDM_SYMBRATEL		0xF2E1
+#define	F367_OFDM_DEFGEN_SYMBRATE_LO		0xF2E100FF
+
+/* SYMBSTATUS */
+#define	R367_OFDM_SYMBSTATUS		0xF2E2
+#define	F367_OFDM_SYMBDLINE2_OFF		0xF2E20080
+#define	F367_OFDM_SDDL_REINIT1		0xF2E20040
+#define	F367_OFDM_SDD_REINIT1		0xF2E20020
+#define	F367_OFDM_TOKENID_ERROR		0xF2E20010
+#define	F367_OFDM_SYMBRATE_OVERFLOW		0xF2E20008
+#define	F367_OFDM_SYMBRATE_UNDERFLOW		0xF2E20004
+#define	F367_OFDM_TOKENID_RSTEVENT		0xF2E20002
+#define	F367_OFDM_TOKENID_RESET1		0xF2E20001
+
+/* SYMBCFG */
+#define	R367_OFDM_SYMBCFG		0xF2E3
+#define	F367_OFDM_SYMBCFG_7		0xF2E30080
+#define	F367_OFDM_SYMBCFG_6		0xF2E30040
+#define	F367_OFDM_SYMBCFG_5		0xF2E30020
+#define	F367_OFDM_SYMBCFG_4		0xF2E30010
+#define	F367_OFDM_SYMRATE_FSPEED		0xF2E3000C
+#define	F367_OFDM_SYMRATE_SSPEED		0xF2E30003
+
+/* SYMBFIFOM */
+#define	R367_OFDM_SYMBFIFOM		0xF2E4
+#define	F367_OFDM_SYMBFIFOM_7		0xF2E40080
+#define	F367_OFDM_SYMBFIFOM_6		0xF2E40040
+#define	F367_OFDM_DEFGEN_SYMFIFO_HI		0xF2E4003F
+
+/* SYMBFIFOL */
+#define	R367_OFDM_SYMBFIFOL		0xF2E5
+#define	F367_OFDM_DEFGEN_SYMFIFO_LO		0xF2E500FF
+
+/* SYMBOFFSM */
+#define	R367_OFDM_SYMBOFFSM		0xF2E6
+#define	F367_OFDM_TOKENID_RESET2		0xF2E60080
+#define	F367_OFDM_SDDL_REINIT2		0xF2E60040
+#define	F367_OFDM_SDD_REINIT2		0xF2E60020
+#define	F367_OFDM_SYMBOFFSM_4		0xF2E60010
+#define	F367_OFDM_SYMBOFFSM_3		0xF2E60008
+#define	F367_OFDM_DEFGEN_SYMBOFFSET_HI		0xF2E60007
+
+/* SYMBOFFSL */
+#define	R367_OFDM_SYMBOFFSL		0xF2E7
+#define	F367_OFDM_DEFGEN_SYMBOFFSET_LO		0xF2E700FF
+
+/* DEBUG_LT4 */
+#define	R367_DEBUG_LT4		0xF400
+#define	F367_F_DEBUG_LT4		0xF40000FF
+
+/* DEBUG_LT5 */
+#define	R367_DEBUG_LT5		0xF401
+#define	F367_F_DEBUG_LT5		0xF40100FF
+
+/* DEBUG_LT6 */
+#define	R367_DEBUG_LT6		0xF402
+#define	F367_F_DEBUG_LT6		0xF40200FF
+
+/* DEBUG_LT7 */
+#define	R367_DEBUG_LT7		0xF403
+#define	F367_F_DEBUG_LT7		0xF40300FF
+
+/* DEBUG_LT8 */
+#define	R367_DEBUG_LT8		0xF404
+#define	F367_F_DEBUG_LT8		0xF40400FF
+
+/* DEBUG_LT9 */
+#define	R367_DEBUG_LT9		0xF405
+#define	F367_F_DEBUG_LT9		0xF40500FF
+
+/* CTRL_1 */
+#define	R367_QAM_CTRL_1		0xF402
+#define	F367_QAM_SOFT_RST		0xF4020080
+#define	F367_QAM_EQU_RST		0xF4020008
+#define	F367_QAM_CRL_RST		0xF4020004
+#define	F367_QAM_TRL_RST		0xF4020002
+#define	F367_QAM_AGC_RST		0xF4020001
+
+/* CTRL_2 */
+#define	R367_QAM_CTRL_2		0xF403
+#define	F367_QAM_DEINT_RST		0xF4030008
+#define	F367_QAM_RS_RST		0xF4030004
+
+/* IT_STATUS1 */
+#define	R367_QAM_IT_STATUS1		0xF408
+#define	F367_QAM_SWEEP_OUT		0xF4080080
+#define	F367_QAM_FSM_CRL		0xF4080040
+#define	F367_QAM_CRL_LOCK		0xF4080020
+#define	F367_QAM_MFSM		0xF4080010
+#define	F367_QAM_TRL_LOCK		0xF4080008
+#define	F367_QAM_TRL_AGC_LIMIT		0xF4080004
+#define	F367_QAM_ADJ_AGC_LOCK		0xF4080002
+#define	F367_QAM_AGC_QAM_LOCK		0xF4080001
+
+/* IT_STATUS2 */
+#define	R367_QAM_IT_STATUS2		0xF409
+#define	F367_QAM_TSMF_CNT		0xF4090080
+#define	F367_QAM_TSMF_EOF		0xF4090040
+#define	F367_QAM_TSMF_RDY		0xF4090020
+#define	F367_QAM_FEC_NOCORR		0xF4090010
+#define	F367_QAM_SYNCSTATE		0xF4090008
+#define	F367_QAM_DEINT_LOCK		0xF4090004
+#define	F367_QAM_FADDING_FRZ		0xF4090002
+#define	F367_QAM_TAPMON_ALARM		0xF4090001
+
+/* IT_EN1 */
+#define	R367_QAM_IT_EN1		0xF40A
+#define	F367_QAM_SWEEP_OUTE		0xF40A0080
+#define	F367_QAM_FSM_CRLE		0xF40A0040
+#define	F367_QAM_CRL_LOCKE		0xF40A0020
+#define	F367_QAM_MFSME		0xF40A0010
+#define	F367_QAM_TRL_LOCKE		0xF40A0008
+#define	F367_QAM_TRL_AGC_LIMITE		0xF40A0004
+#define	F367_QAM_ADJ_AGC_LOCKE		0xF40A0002
+#define	F367_QAM_AGC_LOCKE		0xF40A0001
+
+/* IT_EN2 */
+#define	R367_QAM_IT_EN2		0xF40B
+#define	F367_QAM_TSMF_CNTE		0xF40B0080
+#define	F367_QAM_TSMF_EOFE		0xF40B0040
+#define	F367_QAM_TSMF_RDYE		0xF40B0020
+#define	F367_QAM_FEC_NOCORRE		0xF40B0010
+#define	F367_QAM_SYNCSTATEE		0xF40B0008
+#define	F367_QAM_DEINT_LOCKE		0xF40B0004
+#define	F367_QAM_FADDING_FRZE		0xF40B0002
+#define	F367_QAM_TAPMON_ALARME		0xF40B0001
+
+/* CTRL_STATUS */
+#define	R367_QAM_CTRL_STATUS		0xF40C
+#define	F367_QAM_QAMFEC_LOCK		0xF40C0004
+#define	F367_QAM_TSMF_LOCK		0xF40C0002
+#define	F367_QAM_TSMF_ERROR		0xF40C0001
+
+/* TEST_CTL */
+#define	R367_QAM_TEST_CTL		0xF40F
+#define	F367_QAM_TST_BLK_SEL		0xF40F0060
+#define	F367_QAM_TST_BUS_SEL		0xF40F001F
+
+/* AGC_CTL */
+#define	R367_QAM_AGC_CTL		0xF410
+#define	F367_QAM_AGC_LCK_TH		0xF41000F0
+#define	F367_QAM_AGC_ACCUMRSTSEL		0xF4100007
+
+/* AGC_IF_CFG */
+#define	R367_QAM_AGC_IF_CFG		0xF411
+#define	F367_QAM_AGC_IF_BWSEL		0xF41100F0
+#define	F367_QAM_AGC_IF_FREEZE		0xF4110002
+
+/* AGC_RF_CFG */
+#define	R367_QAM_AGC_RF_CFG		0xF412
+#define	F367_QAM_AGC_RF_BWSEL		0xF4120070
+#define	F367_QAM_AGC_RF_FREEZE		0xF4120002
+
+/* AGC_PWM_CFG */
+#define	R367_QAM_AGC_PWM_CFG		0xF413
+#define	F367_QAM_AGC_RF_PWM_TST		0xF4130080
+#define	F367_QAM_AGC_RF_PWM_INV		0xF4130040
+#define	F367_QAM_AGC_IF_PWM_TST		0xF4130008
+#define	F367_QAM_AGC_IF_PWM_INV		0xF4130004
+#define	F367_QAM_AGC_PWM_CLKDIV		0xF4130003
+
+/* AGC_PWR_REF_L */
+#define	R367_QAM_AGC_PWR_REF_L		0xF414
+#define	F367_QAM_AGC_PWRREF_LO		0xF41400FF
+
+/* AGC_PWR_REF_H */
+#define	R367_QAM_AGC_PWR_REF_H		0xF415
+#define	F367_QAM_AGC_PWRREF_HI		0xF4150003
+
+/* AGC_RF_TH_L */
+#define	R367_QAM_AGC_RF_TH_L		0xF416
+#define	F367_QAM_AGC_RF_TH_LO		0xF41600FF
+
+/* AGC_RF_TH_H */
+#define	R367_QAM_AGC_RF_TH_H		0xF417
+#define	F367_QAM_AGC_RF_TH_HI		0xF417000F
+
+/* AGC_IF_LTH_L */
+#define	R367_QAM_AGC_IF_LTH_L		0xF418
+#define	F367_QAM_AGC_IF_THLO_LO		0xF41800FF
+
+/* AGC_IF_LTH_H */
+#define	R367_QAM_AGC_IF_LTH_H		0xF419
+#define	F367_QAM_AGC_IF_THLO_HI		0xF419000F
+
+/* AGC_IF_HTH_L */
+#define	R367_QAM_AGC_IF_HTH_L		0xF41A
+#define	F367_QAM_AGC_IF_THHI_LO		0xF41A00FF
+
+/* AGC_IF_HTH_H */
+#define	R367_QAM_AGC_IF_HTH_H		0xF41B
+#define	F367_QAM_AGC_IF_THHI_HI		0xF41B000F
+
+/* AGC_PWR_RD_L */
+#define	R367_QAM_AGC_PWR_RD_L		0xF41C
+#define	F367_QAM_AGC_PWR_WORD_LO		0xF41C00FF
+
+/* AGC_PWR_RD_M */
+#define	R367_QAM_AGC_PWR_RD_M		0xF41D
+#define	F367_QAM_AGC_PWR_WORD_ME		0xF41D00FF
+
+/* AGC_PWR_RD_H */
+#define	R367_QAM_AGC_PWR_RD_H		0xF41E
+#define	F367_QAM_AGC_PWR_WORD_HI		0xF41E0003
+
+/* AGC_PWM_IFCMD_L */
+#define	R367_QAM_AGC_PWM_IFCMD_L		0xF420
+#define	F367_QAM_AGC_IF_PWMCMD_LO		0xF42000FF
+
+/* AGC_PWM_IFCMD_H */
+#define	R367_QAM_AGC_PWM_IFCMD_H		0xF421
+#define	F367_QAM_AGC_IF_PWMCMD_HI		0xF421000F
+
+/* AGC_PWM_RFCMD_L */
+#define	R367_QAM_AGC_PWM_RFCMD_L		0xF422
+#define	F367_QAM_AGC_RF_PWMCMD_LO		0xF42200FF
+
+/* AGC_PWM_RFCMD_H */
+#define	R367_QAM_AGC_PWM_RFCMD_H		0xF423
+#define	F367_QAM_AGC_RF_PWMCMD_HI		0xF423000F
+
+/* IQDEM_CFG */
+#define	R367_QAM_IQDEM_CFG		0xF424
+#define	F367_QAM_IQDEM_CLK_SEL		0xF4240004
+#define	F367_QAM_IQDEM_INVIQ		0xF4240002
+#define	F367_QAM_IQDEM_A2DTYPE		0xF4240001
+
+/* MIX_NCO_LL */
+#define	R367_QAM_MIX_NCO_LL		0xF425
+#define	F367_QAM_MIX_NCO_INC_LL		0xF42500FF
+
+/* MIX_NCO_HL */
+#define	R367_QAM_MIX_NCO_HL		0xF426
+#define	F367_QAM_MIX_NCO_INC_HL		0xF42600FF
+
+/* MIX_NCO_HH */
+#define	R367_QAM_MIX_NCO_HH		0xF427
+#define	F367_QAM_MIX_NCO_INVCNST		0xF4270080
+#define	F367_QAM_MIX_NCO_INC_HH		0xF427007F
+
+/* SRC_NCO_LL */
+#define	R367_QAM_SRC_NCO_LL		0xF428
+#define	F367_QAM_SRC_NCO_INC_LL		0xF42800FF
+
+/* SRC_NCO_LH */
+#define	R367_QAM_SRC_NCO_LH		0xF429
+#define	F367_QAM_SRC_NCO_INC_LH		0xF42900FF
+
+/* SRC_NCO_HL */
+#define	R367_QAM_SRC_NCO_HL		0xF42A
+#define	F367_QAM_SRC_NCO_INC_HL		0xF42A00FF
+
+/* SRC_NCO_HH */
+#define	R367_QAM_SRC_NCO_HH		0xF42B
+#define	F367_QAM_SRC_NCO_INC_HH		0xF42B007F
+
+/* IQDEM_GAIN_SRC_L */
+#define	R367_QAM_IQDEM_GAIN_SRC_L		0xF42C
+#define	F367_QAM_GAIN_SRC_LO		0xF42C00FF
+
+/* IQDEM_GAIN_SRC_H */
+#define	R367_QAM_IQDEM_GAIN_SRC_H		0xF42D
+#define	F367_QAM_GAIN_SRC_HI		0xF42D0003
+
+/* IQDEM_DCRM_CFG_LL */
+#define	R367_QAM_IQDEM_DCRM_CFG_LL		0xF430
+#define	F367_QAM_DCRM0_DCIN_L		0xF43000FF
+
+/* IQDEM_DCRM_CFG_LH */
+#define	R367_QAM_IQDEM_DCRM_CFG_LH		0xF431
+#define	F367_QAM_DCRM1_I_DCIN_L		0xF43100FC
+#define	F367_QAM_DCRM0_DCIN_H		0xF4310003
+
+/* IQDEM_DCRM_CFG_HL */
+#define	R367_QAM_IQDEM_DCRM_CFG_HL		0xF432
+#define	F367_QAM_DCRM1_Q_DCIN_L		0xF43200F0
+#define	F367_QAM_DCRM1_I_DCIN_H		0xF432000F
+
+/* IQDEM_DCRM_CFG_HH */
+#define	R367_QAM_IQDEM_DCRM_CFG_HH		0xF433
+#define	F367_QAM_DCRM1_FRZ		0xF4330080
+#define	F367_QAM_DCRM0_FRZ		0xF4330040
+#define	F367_QAM_DCRM1_Q_DCIN_H		0xF433003F
+
+/* IQDEM_ADJ_COEFF0 */
+#define	R367_QAM_IQDEM_ADJ_COEFF0		0xF434
+#define	F367_QAM_ADJIIR_COEFF10_L		0xF43400FF
+
+/* IQDEM_ADJ_COEFF1 */
+#define	R367_QAM_IQDEM_ADJ_COEFF1		0xF435
+#define	F367_QAM_ADJIIR_COEFF11_L		0xF43500FC
+#define	F367_QAM_ADJIIR_COEFF10_H		0xF4350003
+
+/* IQDEM_ADJ_COEFF2 */
+#define	R367_QAM_IQDEM_ADJ_COEFF2		0xF436
+#define	F367_QAM_ADJIIR_COEFF12_L		0xF43600F0
+#define	F367_QAM_ADJIIR_COEFF11_H		0xF436000F
+
+/* IQDEM_ADJ_COEFF3 */
+#define	R367_QAM_IQDEM_ADJ_COEFF3		0xF437
+#define	F367_QAM_ADJIIR_COEFF20_L		0xF43700C0
+#define	F367_QAM_ADJIIR_COEFF12_H		0xF437003F
+
+/* IQDEM_ADJ_COEFF4 */
+#define	R367_QAM_IQDEM_ADJ_COEFF4		0xF438
+#define	F367_QAM_ADJIIR_COEFF20_H		0xF43800FF
+
+/* IQDEM_ADJ_COEFF5 */
+#define	R367_QAM_IQDEM_ADJ_COEFF5		0xF439
+#define	F367_QAM_ADJIIR_COEFF21_L		0xF43900FF
+
+/* IQDEM_ADJ_COEFF6 */
+#define	R367_QAM_IQDEM_ADJ_COEFF6		0xF43A
+#define	F367_QAM_ADJIIR_COEFF22_L		0xF43A00FC
+#define	F367_QAM_ADJIIR_COEFF21_H		0xF43A0003
+
+/* IQDEM_ADJ_COEFF7 */
+#define	R367_QAM_IQDEM_ADJ_COEFF7		0xF43B
+#define	F367_QAM_ADJIIR_COEFF22_H		0xF43B000F
+
+/* IQDEM_ADJ_EN */
+#define	R367_QAM_IQDEM_ADJ_EN		0xF43C
+#define	F367_QAM_ALLPASSFILT_EN		0xF43C0008
+#define	F367_QAM_ADJ_AGC_EN		0xF43C0004
+#define	F367_QAM_ADJ_COEFF_FRZ		0xF43C0002
+#define	F367_QAM_ADJ_EN		0xF43C0001
+
+/* IQDEM_ADJ_AGC_REF */
+#define	R367_QAM_IQDEM_ADJ_AGC_REF		0xF43D
+#define	F367_QAM_ADJ_AGC_REF		0xF43D00FF
+
+/* ALLPASSFILT1 */
+#define	R367_QAM_ALLPASSFILT1		0xF440
+#define	F367_QAM_ALLPASSFILT_COEFF1_LO		0xF44000FF
+
+/* ALLPASSFILT2 */
+#define	R367_QAM_ALLPASSFILT2		0xF441
+#define	F367_QAM_ALLPASSFILT_COEFF1_ME		0xF44100FF
+
+/* ALLPASSFILT3 */
+#define	R367_QAM_ALLPASSFILT3		0xF442
+#define	F367_QAM_ALLPASSFILT_COEFF2_LO		0xF44200C0
+#define	F367_QAM_ALLPASSFILT_COEFF1_HI		0xF442003F
+
+/* ALLPASSFILT4 */
+#define	R367_QAM_ALLPASSFILT4		0xF443
+#define	F367_QAM_ALLPASSFILT_COEFF2_MEL		0xF44300FF
+
+/* ALLPASSFILT5 */
+#define	R367_QAM_ALLPASSFILT5		0xF444
+#define	F367_QAM_ALLPASSFILT_COEFF2_MEH		0xF44400FF
+
+/* ALLPASSFILT6 */
+#define	R367_QAM_ALLPASSFILT6		0xF445
+#define	F367_QAM_ALLPASSFILT_COEFF3_LO		0xF44500F0
+#define	F367_QAM_ALLPASSFILT_COEFF2_HI		0xF445000F
+
+/* ALLPASSFILT7 */
+#define	R367_QAM_ALLPASSFILT7		0xF446
+#define	F367_QAM_ALLPASSFILT_COEFF3_MEL		0xF44600FF
+
+/* ALLPASSFILT8 */
+#define	R367_QAM_ALLPASSFILT8		0xF447
+#define	F367_QAM_ALLPASSFILT_COEFF3_MEH		0xF44700FF
+
+/* ALLPASSFILT9 */
+#define	R367_QAM_ALLPASSFILT9		0xF448
+#define	F367_QAM_ALLPASSFILT_COEFF4_LO		0xF44800FC
+#define	F367_QAM_ALLPASSFILT_COEFF3_HI		0xF4480003
+
+/* ALLPASSFILT10 */
+#define	R367_QAM_ALLPASSFILT10		0xF449
+#define	F367_QAM_ALLPASSFILT_COEFF4_ME		0xF44900FF
+
+/* ALLPASSFILT11 */
+#define	R367_QAM_ALLPASSFILT11		0xF44A
+#define	F367_QAM_ALLPASSFILT_COEFF4_HI		0xF44A00FF
+
+/* TRL_AGC_CFG */
+#define	R367_QAM_TRL_AGC_CFG		0xF450
+#define	F367_QAM_TRL_AGC_FREEZE		0xF4500080
+#define	F367_QAM_TRL_AGC_REF		0xF450007F
+
+/* TRL_LPF_CFG */
+#define	R367_QAM_TRL_LPF_CFG		0xF454
+#define	F367_QAM_NYQPOINT_INV		0xF4540040
+#define	F367_QAM_TRL_SHIFT		0xF4540030
+#define	F367_QAM_NYQ_COEFF_SEL		0xF454000C
+#define	F367_QAM_TRL_LPF_FREEZE		0xF4540002
+#define	F367_QAM_TRL_LPF_CRT		0xF4540001
+
+/* TRL_LPF_ACQ_GAIN */
+#define	R367_QAM_TRL_LPF_ACQ_GAIN		0xF455
+#define	F367_QAM_TRL_GDIR_ACQ		0xF4550070
+#define	F367_QAM_TRL_GINT_ACQ		0xF4550007
+
+/* TRL_LPF_TRK_GAIN */
+#define	R367_QAM_TRL_LPF_TRK_GAIN		0xF456
+#define	F367_QAM_TRL_GDIR_TRK		0xF4560070
+#define	F367_QAM_TRL_GINT_TRK		0xF4560007
+
+/* TRL_LPF_OUT_GAIN */
+#define	R367_QAM_TRL_LPF_OUT_GAIN		0xF457
+#define	F367_QAM_TRL_GAIN_OUT		0xF4570007
+
+/* TRL_LOCKDET_LTH */
+#define	R367_QAM_TRL_LOCKDET_LTH		0xF458
+#define	F367_QAM_TRL_LCK_THLO		0xF4580007
+
+/* TRL_LOCKDET_HTH */
+#define	R367_QAM_TRL_LOCKDET_HTH		0xF459
+#define	F367_QAM_TRL_LCK_THHI		0xF45900FF
+
+/* TRL_LOCKDET_TRGVAL */
+#define	R367_QAM_TRL_LOCKDET_TRGVAL		0xF45A
+#define	F367_QAM_TRL_LCK_TRG		0xF45A00FF
+
+/* IQ_QAM */
+#define	R367_QAM_IQ_QAM		0xF45C
+#define	F367_QAM_IQ_INPUT		0xF45C0008
+#define	F367_QAM_DETECT_MODE		0xF45C0007
+
+/* FSM_STATE */
+#define	R367_QAM_FSM_STATE		0xF460
+#define	F367_QAM_CRL_DFE		0xF4600080
+#define	F367_QAM_DFE_START		0xF4600040
+#define	F367_QAM_CTRLG_START		0xF4600030
+#define	F367_QAM_FSM_FORCESTATE		0xF460000F
+
+/* FSM_CTL */
+#define	R367_QAM_FSM_CTL		0xF461
+#define	F367_QAM_FEC2_EN		0xF4610040
+#define	F367_QAM_SIT_EN		0xF4610020
+#define	F367_QAM_TRL_AHEAD		0xF4610010
+#define	F367_QAM_TRL2_EN		0xF4610008
+#define	F367_QAM_FSM_EQA1_EN		0xF4610004
+#define	F367_QAM_FSM_BKP_DIS		0xF4610002
+#define	F367_QAM_FSM_FORCE_EN		0xF4610001
+
+/* FSM_STS */
+#define	R367_QAM_FSM_STS		0xF462
+#define	F367_QAM_FSM_STATUS		0xF462000F
+
+/* FSM_SNR0_HTH */
+#define	R367_QAM_FSM_SNR0_HTH		0xF463
+#define	F367_QAM_SNR0_HTH		0xF46300FF
+
+/* FSM_SNR1_HTH */
+#define	R367_QAM_FSM_SNR1_HTH		0xF464
+#define	F367_QAM_SNR1_HTH		0xF46400FF
+
+/* FSM_SNR2_HTH */
+#define	R367_QAM_FSM_SNR2_HTH		0xF465
+#define	F367_QAM_SNR2_HTH		0xF46500FF
+
+/* FSM_SNR0_LTH */
+#define	R367_QAM_FSM_SNR0_LTH		0xF466
+#define	F367_QAM_SNR0_LTH		0xF46600FF
+
+/* FSM_SNR1_LTH */
+#define	R367_QAM_FSM_SNR1_LTH		0xF467
+#define	F367_QAM_SNR1_LTH		0xF46700FF
+
+/* FSM_EQA1_HTH */
+#define	R367_QAM_FSM_EQA1_HTH		0xF468
+#define	F367_QAM_SNR3_HTH_LO		0xF46800F0
+#define	F367_QAM_EQA1_HTH		0xF468000F
+
+/* FSM_TEMPO */
+#define	R367_QAM_FSM_TEMPO		0xF469
+#define	F367_QAM_SIT		0xF46900C0
+#define	F367_QAM_WST		0xF4690038
+#define	F367_QAM_ELT		0xF4690006
+#define	F367_QAM_SNR3_HTH_HI		0xF4690001
+
+/* FSM_CONFIG */
+#define	R367_QAM_FSM_CONFIG		0xF46A
+#define	F367_QAM_FEC2_DFEOFF		0xF46A0004
+#define	F367_QAM_PRIT_STATE		0xF46A0002
+#define	F367_QAM_MODMAP_STATE		0xF46A0001
+
+/* EQU_I_TESTTAP_L */
+#define	R367_QAM_EQU_I_TESTTAP_L		0xF474
+#define	F367_QAM_I_TEST_TAP_L		0xF47400FF
+
+/* EQU_I_TESTTAP_M */
+#define	R367_QAM_EQU_I_TESTTAP_M		0xF475
+#define	F367_QAM_I_TEST_TAP_M		0xF47500FF
+
+/* EQU_I_TESTTAP_H */
+#define	R367_QAM_EQU_I_TESTTAP_H		0xF476
+#define	F367_QAM_I_TEST_TAP_H		0xF476001F
+
+/* EQU_TESTAP_CFG */
+#define	R367_QAM_EQU_TESTAP_CFG		0xF477
+#define	F367_QAM_TEST_FFE_DFE_SEL		0xF4770040
+#define	F367_QAM_TEST_TAP_SELECT		0xF477003F
+
+/* EQU_Q_TESTTAP_L */
+#define	R367_QAM_EQU_Q_TESTTAP_L		0xF478
+#define	F367_QAM_Q_TEST_TAP_L		0xF47800FF
+
+/* EQU_Q_TESTTAP_M */
+#define	R367_QAM_EQU_Q_TESTTAP_M		0xF479
+#define	F367_QAM_Q_TEST_TAP_M		0xF47900FF
+
+/* EQU_Q_TESTTAP_H */
+#define	R367_QAM_EQU_Q_TESTTAP_H		0xF47A
+#define	F367_QAM_Q_TEST_TAP_H		0xF47A001F
+
+/* EQU_TAP_CTRL */
+#define	R367_QAM_EQU_TAP_CTRL		0xF47B
+#define	F367_QAM_MTAP_FRZ		0xF47B0010
+#define	F367_QAM_PRE_FREEZE		0xF47B0008
+#define	F367_QAM_DFE_TAPMON_EN		0xF47B0004
+#define	F367_QAM_FFE_TAPMON_EN		0xF47B0002
+#define	F367_QAM_MTAP_ONLY		0xF47B0001
+
+/* EQU_CTR_CRL_CONTROL_L */
+#define	R367_QAM_EQU_CTR_CRL_CONTROL_L		0xF47C
+#define	F367_QAM_EQU_CTR_CRL_CONTROL_LO		0xF47C00FF
+
+/* EQU_CTR_CRL_CONTROL_H */
+#define	R367_QAM_EQU_CTR_CRL_CONTROL_H		0xF47D
+#define	F367_QAM_EQU_CTR_CRL_CONTROL_HI		0xF47D00FF
+
+/* EQU_CTR_HIPOW_L */
+#define	R367_QAM_EQU_CTR_HIPOW_L		0xF47E
+#define	F367_QAM_CTR_HIPOW_L		0xF47E00FF
+
+/* EQU_CTR_HIPOW_H */
+#define	R367_QAM_EQU_CTR_HIPOW_H		0xF47F
+#define	F367_QAM_CTR_HIPOW_H		0xF47F00FF
+
+/* EQU_I_EQU_LO */
+#define	R367_QAM_EQU_I_EQU_LO		0xF480
+#define	F367_QAM_EQU_I_EQU_L		0xF48000FF
+
+/* EQU_I_EQU_HI */
+#define	R367_QAM_EQU_I_EQU_HI		0xF481
+#define	F367_QAM_EQU_I_EQU_H		0xF4810003
+
+/* EQU_Q_EQU_LO */
+#define	R367_QAM_EQU_Q_EQU_LO		0xF482
+#define	F367_QAM_EQU_Q_EQU_L		0xF48200FF
+
+/* EQU_Q_EQU_HI */
+#define	R367_QAM_EQU_Q_EQU_HI		0xF483
+#define	F367_QAM_EQU_Q_EQU_H		0xF4830003
+
+/* EQU_MAPPER */
+#define	R367_QAM_EQU_MAPPER		0xF484
+#define	F367_QAM_QUAD_AUTO		0xF4840080
+#define	F367_QAM_QUAD_INV		0xF4840040
+#define	F367_QAM_QAM_MODE		0xF4840007
+
+/* EQU_SWEEP_RATE */
+#define	R367_QAM_EQU_SWEEP_RATE		0xF485
+#define	F367_QAM_SNR_PER		0xF48500C0
+#define	F367_QAM_SWEEP_RATE		0xF485003F
+
+/* EQU_SNR_LO */
+#define	R367_QAM_EQU_SNR_LO		0xF486
+#define	F367_QAM_SNR_LO		0xF48600FF
+
+/* EQU_SNR_HI */
+#define	R367_QAM_EQU_SNR_HI		0xF487
+#define	F367_QAM_SNR_HI		0xF48700FF
+
+/* EQU_GAMMA_LO */
+#define	R367_QAM_EQU_GAMMA_LO		0xF488
+#define	F367_QAM_GAMMA_LO		0xF48800FF
+
+/* EQU_GAMMA_HI */
+#define	R367_QAM_EQU_GAMMA_HI		0xF489
+#define	F367_QAM_GAMMA_ME		0xF48900FF
+
+/* EQU_ERR_GAIN */
+#define	R367_QAM_EQU_ERR_GAIN		0xF48A
+#define	F367_QAM_EQA1MU		0xF48A0070
+#define	F367_QAM_CRL2MU		0xF48A000E
+#define	F367_QAM_GAMMA_HI		0xF48A0001
+
+/* EQU_RADIUS */
+#define	R367_QAM_EQU_RADIUS		0xF48B
+#define	F367_QAM_RADIUS		0xF48B00FF
+
+/* EQU_FFE_MAINTAP */
+#define	R367_QAM_EQU_FFE_MAINTAP		0xF48C
+#define	F367_QAM_FFE_MAINTAP_INIT		0xF48C00FF
+
+/* EQU_FFE_LEAKAGE */
+#define	R367_QAM_EQU_FFE_LEAKAGE		0xF48E
+#define	F367_QAM_LEAK_PER		0xF48E00F0
+#define	F367_QAM_EQU_OUTSEL		0xF48E0002
+#define	F367_QAM_PNT2DFE		0xF48E0001
+
+/* EQU_FFE_MAINTAP_POS */
+#define	R367_QAM_EQU_FFE_MAINTAP_POS		0xF48F
+#define	F367_QAM_FFE_LEAK_EN		0xF48F0080
+#define	F367_QAM_DFE_LEAK_EN		0xF48F0040
+#define	F367_QAM_FFE_MAINTAP_POS		0xF48F003F
+
+/* EQU_GAIN_WIDE */
+#define	R367_QAM_EQU_GAIN_WIDE		0xF490
+#define	F367_QAM_DFE_GAIN_WIDE		0xF49000F0
+#define	F367_QAM_FFE_GAIN_WIDE		0xF490000F
+
+/* EQU_GAIN_NARROW */
+#define	R367_QAM_EQU_GAIN_NARROW		0xF491
+#define	F367_QAM_DFE_GAIN_NARROW		0xF49100F0
+#define	F367_QAM_FFE_GAIN_NARROW		0xF491000F
+
+/* EQU_CTR_LPF_GAIN */
+#define	R367_QAM_EQU_CTR_LPF_GAIN		0xF492
+#define	F367_QAM_CTR_GTO		0xF4920080
+#define	F367_QAM_CTR_GDIR		0xF4920070
+#define	F367_QAM_SWEEP_EN		0xF4920008
+#define	F367_QAM_CTR_GINT		0xF4920007
+
+/* EQU_CRL_LPF_GAIN */
+#define	R367_QAM_EQU_CRL_LPF_GAIN		0xF493
+#define	F367_QAM_CRL_GTO		0xF4930080
+#define	F367_QAM_CRL_GDIR		0xF4930070
+#define	F367_QAM_SWEEP_DIR		0xF4930008
+#define	F367_QAM_CRL_GINT		0xF4930007
+
+/* EQU_GLOBAL_GAIN */
+#define	R367_QAM_EQU_GLOBAL_GAIN		0xF494
+#define	F367_QAM_CRL_GAIN		0xF49400F8
+#define	F367_QAM_CTR_INC_GAIN		0xF4940004
+#define	F367_QAM_CTR_FRAC		0xF4940003
+
+/* EQU_CRL_LD_SEN */
+#define	R367_QAM_EQU_CRL_LD_SEN		0xF495
+#define	F367_QAM_CTR_BADPOINT_EN		0xF4950080
+#define	F367_QAM_CTR_GAIN		0xF4950070
+#define	F367_QAM_LIMANEN		0xF4950008
+#define	F367_QAM_CRL_LD_SEN		0xF4950007
+
+/* EQU_CRL_LD_VAL */
+#define	R367_QAM_EQU_CRL_LD_VAL		0xF496
+#define	F367_QAM_CRL_BISTH_LIMIT		0xF4960080
+#define	F367_QAM_CARE_EN		0xF4960040
+#define	F367_QAM_CRL_LD_PER		0xF4960030
+#define	F367_QAM_CRL_LD_WST		0xF496000C
+#define	F367_QAM_CRL_LD_TFS		0xF4960003
+
+/* EQU_CRL_TFR */
+#define	R367_QAM_EQU_CRL_TFR		0xF497
+#define	F367_QAM_CRL_LD_TFR		0xF49700FF
+
+/* EQU_CRL_BISTH_LO */
+#define	R367_QAM_EQU_CRL_BISTH_LO		0xF498
+#define	F367_QAM_CRL_BISTH_LO		0xF49800FF
+
+/* EQU_CRL_BISTH_HI */
+#define	R367_QAM_EQU_CRL_BISTH_HI		0xF499
+#define	F367_QAM_CRL_BISTH_HI		0xF49900FF
+
+/* EQU_SWEEP_RANGE_LO */
+#define	R367_QAM_EQU_SWEEP_RANGE_LO		0xF49A
+#define	F367_QAM_SWEEP_RANGE_LO		0xF49A00FF
+
+/* EQU_SWEEP_RANGE_HI */
+#define	R367_QAM_EQU_SWEEP_RANGE_HI		0xF49B
+#define	F367_QAM_SWEEP_RANGE_HI		0xF49B00FF
+
+/* EQU_CRL_LIMITER */
+#define	R367_QAM_EQU_CRL_LIMITER		0xF49C
+#define	F367_QAM_BISECTOR_EN		0xF49C0080
+#define	F367_QAM_PHEST128_EN		0xF49C0040
+#define	F367_QAM_CRL_LIM		0xF49C003F
+
+/* EQU_MODULUS_MAP */
+#define	R367_QAM_EQU_MODULUS_MAP		0xF49D
+#define	F367_QAM_PNT_DEPTH		0xF49D00E0
+#define	F367_QAM_MODULUS_CMP		0xF49D001F
+
+/* EQU_PNT_GAIN */
+#define	R367_QAM_EQU_PNT_GAIN		0xF49E
+#define	F367_QAM_PNT_EN		0xF49E0080
+#define	F367_QAM_MODULUSMAP_EN		0xF49E0040
+#define	F367_QAM_PNT_GAIN		0xF49E003F
+
+/* FEC_AC_CTR_0 */
+#define	R367_QAM_FEC_AC_CTR_0		0xF4A8
+#define	F367_QAM_BE_BYPASS		0xF4A80020
+#define	F367_QAM_REFRESH47		0xF4A80010
+#define	F367_QAM_CT_NBST		0xF4A80008
+#define	F367_QAM_TEI_ENA		0xF4A80004
+#define	F367_QAM_DS_ENA		0xF4A80002
+#define	F367_QAM_TSMF_EN		0xF4A80001
+
+/* FEC_AC_CTR_1 */
+#define	R367_QAM_FEC_AC_CTR_1		0xF4A9
+#define	F367_QAM_DEINT_DEPTH		0xF4A900FF
+
+/* FEC_AC_CTR_2 */
+#define	R367_QAM_FEC_AC_CTR_2		0xF4AA
+#define	F367_QAM_DEINT_M		0xF4AA00F8
+#define	F367_QAM_DIS_UNLOCK		0xF4AA0004
+#define	F367_QAM_DESCR_MODE		0xF4AA0003
+
+/* FEC_AC_CTR_3 */
+#define	R367_QAM_FEC_AC_CTR_3		0xF4AB
+#define	F367_QAM_DI_UNLOCK		0xF4AB0080
+#define	F367_QAM_DI_FREEZE		0xF4AB0040
+#define	F367_QAM_MISMATCH		0xF4AB0030
+#define	F367_QAM_ACQ_MODE		0xF4AB000C
+#define	F367_QAM_TRK_MODE		0xF4AB0003
+
+/* FEC_STATUS */
+#define	R367_QAM_FEC_STATUS		0xF4AC
+#define	F367_QAM_DEINT_SMCNTR		0xF4AC00E0
+#define	F367_QAM_DEINT_SYNCSTATE		0xF4AC0018
+#define	F367_QAM_DEINT_SYNLOST		0xF4AC0004
+#define	F367_QAM_DESCR_SYNCSTATE		0xF4AC0002
+
+/* RS_COUNTER_0 */
+#define	R367_QAM_RS_COUNTER_0		0xF4AE
+#define	F367_QAM_BK_CT_L		0xF4AE00FF
+
+/* RS_COUNTER_1 */
+#define	R367_QAM_RS_COUNTER_1		0xF4AF
+#define	F367_QAM_BK_CT_H		0xF4AF00FF
+
+/* RS_COUNTER_2 */
+#define	R367_QAM_RS_COUNTER_2		0xF4B0
+#define	F367_QAM_CORR_CT_L		0xF4B000FF
+
+/* RS_COUNTER_3 */
+#define	R367_QAM_RS_COUNTER_3		0xF4B1
+#define	F367_QAM_CORR_CT_H		0xF4B100FF
+
+/* RS_COUNTER_4 */
+#define	R367_QAM_RS_COUNTER_4		0xF4B2
+#define	F367_QAM_UNCORR_CT_L		0xF4B200FF
+
+/* RS_COUNTER_5 */
+#define	R367_QAM_RS_COUNTER_5		0xF4B3
+#define	F367_QAM_UNCORR_CT_H		0xF4B300FF
+
+/* BERT_0 */
+#define	R367_QAM_BERT_0		0xF4B4
+#define	F367_QAM_RS_NOCORR		0xF4B40004
+#define	F367_QAM_CT_HOLD		0xF4B40002
+#define	F367_QAM_CT_CLEAR		0xF4B40001
+
+/* BERT_1 */
+#define	R367_QAM_BERT_1		0xF4B5
+#define	F367_QAM_BERT_ON		0xF4B50020
+#define	F367_QAM_BERT_ERR_SRC		0xF4B50010
+#define	F367_QAM_BERT_ERR_MODE		0xF4B50008
+#define	F367_QAM_BERT_NBYTE		0xF4B50007
+
+/* BERT_2 */
+#define	R367_QAM_BERT_2		0xF4B6
+#define	F367_QAM_BERT_ERRCOUNT_L		0xF4B600FF
+
+/* BERT_3 */
+#define	R367_QAM_BERT_3		0xF4B7
+#define	F367_QAM_BERT_ERRCOUNT_H		0xF4B700FF
+
+/* OUTFORMAT_0 */
+#define	R367_QAM_OUTFORMAT_0		0xF4B8
+#define	F367_QAM_CLK_POLARITY		0xF4B80080
+#define	F367_QAM_FEC_TYPE		0xF4B80040
+#define	F367_QAM_SYNC_STRIP		0xF4B80008
+#define	F367_QAM_TS_SWAP		0xF4B80004
+#define	F367_QAM_OUTFORMAT		0xF4B80003
+
+/* OUTFORMAT_1 */
+#define	R367_QAM_OUTFORMAT_1		0xF4B9
+#define	F367_QAM_CI_DIVRANGE		0xF4B900FF
+
+/* SMOOTHER_2 */
+#define	R367_QAM_SMOOTHER_2		0xF4BE
+#define	F367_QAM_FIFO_BYPASS		0xF4BE0020
+
+/* TSMF_CTRL_0 */
+#define	R367_QAM_TSMF_CTRL_0		0xF4C0
+#define	F367_QAM_TS_NUMBER		0xF4C0001E
+#define	F367_QAM_SEL_MODE		0xF4C00001
+
+/* TSMF_CTRL_1 */
+#define	R367_QAM_TSMF_CTRL_1		0xF4C1
+#define	F367_QAM_CHECK_ERROR_BIT		0xF4C10080
+#define	F367_QAM_CHCK_F_SYNC		0xF4C10040
+#define	F367_QAM_H_MODE		0xF4C10008
+#define	F367_QAM_D_V_MODE		0xF4C10004
+#define	F367_QAM_MODE		0xF4C10003
+
+/* TSMF_CTRL_3 */
+#define	R367_QAM_TSMF_CTRL_3		0xF4C3
+#define	F367_QAM_SYNC_IN_COUNT		0xF4C300F0
+#define	F367_QAM_SYNC_OUT_COUNT		0xF4C3000F
+
+/* TS_ON_ID_0 */
+#define	R367_QAM_TS_ON_ID_0		0xF4C4
+#define	F367_QAM_TS_ID_L		0xF4C400FF
+
+/* TS_ON_ID_1 */
+#define	R367_QAM_TS_ON_ID_1		0xF4C5
+#define	F367_QAM_TS_ID_H		0xF4C500FF
+
+/* TS_ON_ID_2 */
+#define	R367_QAM_TS_ON_ID_2		0xF4C6
+#define	F367_QAM_ON_ID_L		0xF4C600FF
+
+/* TS_ON_ID_3 */
+#define	R367_QAM_TS_ON_ID_3		0xF4C7
+#define	F367_QAM_ON_ID_H		0xF4C700FF
+
+/* RE_STATUS_0 */
+#define	R367_QAM_RE_STATUS_0		0xF4C8
+#define	F367_QAM_RECEIVE_STATUS_L		0xF4C800FF
+
+/* RE_STATUS_1 */
+#define	R367_QAM_RE_STATUS_1		0xF4C9
+#define	F367_QAM_RECEIVE_STATUS_LH		0xF4C900FF
+
+/* RE_STATUS_2 */
+#define	R367_QAM_RE_STATUS_2		0xF4CA
+#define	F367_QAM_RECEIVE_STATUS_HL		0xF4CA00FF
+
+/* RE_STATUS_3 */
+#define	R367_QAM_RE_STATUS_3		0xF4CB
+#define	F367_QAM_RECEIVE_STATUS_HH		0xF4CB003F
+
+/* TS_STATUS_0 */
+#define	R367_QAM_TS_STATUS_0		0xF4CC
+#define	F367_QAM_TS_STATUS_L		0xF4CC00FF
+
+/* TS_STATUS_1 */
+#define	R367_QAM_TS_STATUS_1		0xF4CD
+#define	F367_QAM_TS_STATUS_H		0xF4CD007F
+
+/* TS_STATUS_2 */
+#define	R367_QAM_TS_STATUS_2		0xF4CE
+#define	F367_QAM_ERROR		0xF4CE0080
+#define	F367_QAM_EMERGENCY		0xF4CE0040
+#define	F367_QAM_CRE_TS		0xF4CE0030
+#define	F367_QAM_VER		0xF4CE000E
+#define	F367_QAM_M_LOCK		0xF4CE0001
+
+/* TS_STATUS_3 */
+#define	R367_QAM_TS_STATUS_3		0xF4CF
+#define	F367_QAM_UPDATE_READY		0xF4CF0080
+#define	F367_QAM_END_FRAME_HEADER		0xF4CF0040
+#define	F367_QAM_CONTCNT		0xF4CF0020
+#define	F367_QAM_TS_IDENTIFIER_SEL		0xF4CF000F
+
+/* T_O_ID_0 */
+#define	R367_QAM_T_O_ID_0		0xF4D0
+#define	F367_QAM_ON_ID_I_L		0xF4D000FF
+
+/* T_O_ID_1 */
+#define	R367_QAM_T_O_ID_1		0xF4D1
+#define	F367_QAM_ON_ID_I_H		0xF4D100FF
+
+/* T_O_ID_2 */
+#define	R367_QAM_T_O_ID_2		0xF4D2
+#define	F367_QAM_TS_ID_I_L		0xF4D200FF
+
+/* T_O_ID_3 */
+#define	R367_QAM_T_O_ID_3		0xF4D3
+#define	F367_QAM_TS_ID_I_H		0xF4D300FF
+
diff -urN linux-3.4.3/drivers/media/dvb/frontends/stv090x.c linux-3.4.3.dd/drivers/media/dvb/frontends/stv090x.c
--- linux-3.4.3/drivers/media/dvb/frontends/stv090x.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/stv090x.c	2012-06-18 22:35:23.174032306 +0200
@@ -3512,6 +3512,7 @@
 	return 0;
 }
 
+#if 0
 static int stv090x_read_per(struct dvb_frontend *fe, u32 *per)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -3562,6 +3563,27 @@
 	dprintk(FE_ERROR, 1, "I/O error");
 	return -1;
 }
+#endif
+
+static int stv090x_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, h, m, l;
+
+	/* Counter 1: S1: 0x75 BER, S2: 0x67 PER */
+	reg = STV090x_READ_DEMOD(state, ERRCNT12);
+	h = STV090x_GETFIELD_Px(reg, ERR_CNT12_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT11);
+	m = STV090x_GETFIELD_Px(reg, ERR_CNT11_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT10);
+	l = STV090x_GETFIELD_Px(reg, ERR_CNT10_FIELD);
+
+	*ber = ((h << 16) | (m << 8) | l);
+
+	return 0;
+}
 
 static int stv090x_table_lookup(const struct stv090x_tab *tab, int max, int val)
 {
@@ -3682,6 +3704,26 @@
 	return 0;
 }
 
+static int stv090x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, h, m, l;
+
+	/* Counter 2: 0xc1 TS error count */
+	reg = STV090x_READ_DEMOD(state, ERRCNT22);
+	h = STV090x_GETFIELD_Px(reg, ERR_CNT2_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT21);
+	m = STV090x_GETFIELD_Px(reg, ERR_CNT21_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT20);
+	l = STV090x_GETFIELD_Px(reg, ERR_CNT20_FIELD);
+
+	*ucblocks = ((h << 16) | (m << 8) | l);
+
+	return 0;
+}
+
 static int stv090x_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -4240,7 +4282,7 @@
 	return -1;
 }
 
-static int stv090x_set_tspath(struct stv090x_state *state)
+static int stv0900_set_tspath(struct stv090x_state *state)
 {
 	u32 reg;
 
@@ -4511,6 +4553,121 @@
 	return -1;
 }
 
+static int stv0903_set_tspath(struct stv090x_state *state)
+{
+	u32 reg;
+
+	if (state->internal->dev_ver >= 0x20) {
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+			stv090x_write_reg(state, STV090x_TSGENERAL, 0x00);
+			break;
+
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		default:
+			stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c);
+			break;
+		}
+	} else {
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+			stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x10);
+			break;
+
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		default:
+			stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x14);
+			break;
+		}
+	}
+
+	switch (state->config->ts1_mode) {
+	case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_DVBCI:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	default:
+		break;
+	}
+
+	if (state->config->ts1_clk > 0) {
+		u32 speed;
+
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+		default:
+			speed = state->internal->mclk /
+				(state->config->ts1_clk / 4);
+			if (speed < 0x08)
+				speed = 0x08;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			speed = state->internal->mclk /
+				(state->config->ts1_clk / 32);
+			if (speed < 0x20)
+				speed = 0x20;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		}
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
+		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
+			goto err;
+		if (stv090x_write_reg(state, STV090x_P1_TSSPEED, speed) < 0)
+			goto err;
+	}
+
+	reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
+	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+		goto err;
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
+	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
 static int stv090x_init(struct dvb_frontend *fe)
 {
 	struct stv090x_state *state = fe->demodulator_priv;
@@ -4573,8 +4730,13 @@
 	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
 		goto err;
 
-	if (stv090x_set_tspath(state) < 0)
-		goto err;
+	if (state->device == STV0900) {
+		if (stv0900_set_tspath(state) < 0)
+			goto err;
+	} else {
+		if (stv0903_set_tspath(state) < 0)
+			goto err;
+	}
 
 	return 0;
 
@@ -4615,23 +4777,26 @@
 	/* Stop Demod */
 	if (stv090x_write_reg(state, STV090x_P1_DMDISTATE, 0x5c) < 0)
 		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
-		goto err;
+	if (state->device == STV0900)
+		if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
+			goto err;
 
 	msleep(5);
 
 	/* Set No Tuner Mode */
 	if (stv090x_write_reg(state, STV090x_P1_TNRCFG, 0x6c) < 0)
 		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
-		goto err;
+	if (state->device == STV0900)
+		if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
+			goto err;
 
 	/* I2C repeater OFF */
 	STV090x_SETFIELD_Px(reg, ENARPT_LEVEL_FIELD, config->repeater_level);
 	if (stv090x_write_reg(state, STV090x_P1_I2CRPT, reg) < 0)
 		goto err;
-	if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
-		goto err;
+	if (state->device == STV0900)
+		if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
+			goto err;
 
 	if (stv090x_write_reg(state, STV090x_NCOARSE, 0x13) < 0) /* set PLL divider */
 		goto err;
@@ -4740,9 +4905,10 @@
 
 	.search				= stv090x_search,
 	.read_status			= stv090x_read_status,
-	.read_ber			= stv090x_read_per,
+	.read_ber			= stv090x_read_ber,
 	.read_signal_strength		= stv090x_read_signal_strength,
 	.read_snr			= stv090x_read_cnr,
+	.read_ucblocks			= stv090x_read_ucblocks,
 };
 
 
diff -urN linux-3.4.3/drivers/media/dvb/frontends/stv090x.c.orig linux-3.4.3.dd/drivers/media/dvb/frontends/stv090x.c.orig
--- linux-3.4.3/drivers/media/dvb/frontends/stv090x.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/stv090x.c.orig	2012-06-18 22:35:09.894032300 +0200
@@ -0,0 +1,4868 @@
+/*
+	STV0900/0903 Multistandard Broadcast Frontend driver
+	Copyright (C) Manu Abraham <abraham.manu@gmail.com>
+
+	Copyright (C) ST Microelectronics
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+
+#include <linux/dvb/frontend.h>
+#include "dvb_frontend.h"
+
+#include "stv6110x.h" /* for demodulator internal modes */
+
+#include "stv090x_reg.h"
+#include "stv090x.h"
+#include "stv090x_priv.h"
+
+static unsigned int verbose;
+module_param(verbose, int, 0644);
+
+/* internal params node */
+struct stv090x_dev {
+	/* pointer for internal params, one for each pair of demods */
+	struct stv090x_internal		*internal;
+	struct stv090x_dev		*next_dev;
+};
+
+/* first internal params */
+static struct stv090x_dev *stv090x_first_dev;
+
+/* find chip by i2c adapter and i2c address */
+static struct stv090x_dev *find_dev(struct i2c_adapter *i2c_adap,
+					u8 i2c_addr)
+{
+	struct stv090x_dev *temp_dev = stv090x_first_dev;
+
+	/*
+	 Search of the last stv0900 chip or
+	 find it by i2c adapter and i2c address */
+	while ((temp_dev != NULL) &&
+		((temp_dev->internal->i2c_adap != i2c_adap) ||
+		(temp_dev->internal->i2c_addr != i2c_addr))) {
+
+		temp_dev = temp_dev->next_dev;
+	}
+
+	return temp_dev;
+}
+
+/* deallocating chip */
+static void remove_dev(struct stv090x_internal *internal)
+{
+	struct stv090x_dev *prev_dev = stv090x_first_dev;
+	struct stv090x_dev *del_dev = find_dev(internal->i2c_adap,
+						internal->i2c_addr);
+
+	if (del_dev != NULL) {
+		if (del_dev == stv090x_first_dev) {
+			stv090x_first_dev = del_dev->next_dev;
+		} else {
+			while (prev_dev->next_dev != del_dev)
+				prev_dev = prev_dev->next_dev;
+
+			prev_dev->next_dev = del_dev->next_dev;
+		}
+
+		kfree(del_dev);
+	}
+}
+
+/* allocating new chip */
+static struct stv090x_dev *append_internal(struct stv090x_internal *internal)
+{
+	struct stv090x_dev *new_dev;
+	struct stv090x_dev *temp_dev;
+
+	new_dev = kmalloc(sizeof(struct stv090x_dev), GFP_KERNEL);
+	if (new_dev != NULL) {
+		new_dev->internal = internal;
+		new_dev->next_dev = NULL;
+
+		/* append to list */
+		if (stv090x_first_dev == NULL) {
+			stv090x_first_dev = new_dev;
+		} else {
+			temp_dev = stv090x_first_dev;
+			while (temp_dev->next_dev != NULL)
+				temp_dev = temp_dev->next_dev;
+
+			temp_dev->next_dev = new_dev;
+		}
+	}
+
+	return new_dev;
+}
+
+
+/* DVBS1 and DSS C/N Lookup table */
+static const struct stv090x_tab stv090x_s1cn_tab[] = {
+	{   0, 8917 }, /*  0.0dB */
+	{   5, 8801 }, /*  0.5dB */
+	{  10, 8667 }, /*  1.0dB */
+	{  15, 8522 }, /*  1.5dB */
+	{  20, 8355 }, /*  2.0dB */
+	{  25, 8175 }, /*  2.5dB */
+	{  30, 7979 }, /*  3.0dB */
+	{  35, 7763 }, /*  3.5dB */
+	{  40, 7530 }, /*  4.0dB */
+	{  45, 7282 }, /*  4.5dB */
+	{  50, 7026 }, /*  5.0dB */
+	{  55, 6781 }, /*  5.5dB */
+	{  60, 6514 }, /*  6.0dB */
+	{  65, 6241 }, /*  6.5dB */
+	{  70, 5965 }, /*  7.0dB */
+	{  75, 5690 }, /*  7.5dB */
+	{  80, 5424 }, /*  8.0dB */
+	{  85, 5161 }, /*  8.5dB */
+	{  90, 4902 }, /*  9.0dB */
+	{  95, 4654 }, /*  9.5dB */
+	{ 100, 4417 }, /* 10.0dB */
+	{ 105, 4186 }, /* 10.5dB */
+	{ 110, 3968 }, /* 11.0dB */
+	{ 115, 3757 }, /* 11.5dB */
+	{ 120, 3558 }, /* 12.0dB */
+	{ 125, 3366 }, /* 12.5dB */
+	{ 130, 3185 }, /* 13.0dB */
+	{ 135, 3012 }, /* 13.5dB */
+	{ 140, 2850 }, /* 14.0dB */
+	{ 145, 2698 }, /* 14.5dB */
+	{ 150, 2550 }, /* 15.0dB */
+	{ 160, 2283 }, /* 16.0dB */
+	{ 170, 2042 }, /* 17.0dB */
+	{ 180, 1827 }, /* 18.0dB */
+	{ 190, 1636 }, /* 19.0dB */
+	{ 200, 1466 }, /* 20.0dB */
+	{ 210, 1315 }, /* 21.0dB */
+	{ 220, 1181 }, /* 22.0dB */
+	{ 230, 1064 }, /* 23.0dB */
+	{ 240,	960 }, /* 24.0dB */
+	{ 250,	869 }, /* 25.0dB */
+	{ 260,	792 }, /* 26.0dB */
+	{ 270,	724 }, /* 27.0dB */
+	{ 280,	665 }, /* 28.0dB */
+	{ 290,	616 }, /* 29.0dB */
+	{ 300,	573 }, /* 30.0dB */
+	{ 310,	537 }, /* 31.0dB */
+	{ 320,	507 }, /* 32.0dB */
+	{ 330,	483 }, /* 33.0dB */
+	{ 400,	398 }, /* 40.0dB */
+	{ 450,	381 }, /* 45.0dB */
+	{ 500,	377 }  /* 50.0dB */
+};
+
+/* DVBS2 C/N Lookup table */
+static const struct stv090x_tab stv090x_s2cn_tab[] = {
+	{ -30, 13348 }, /* -3.0dB */
+	{ -20, 12640 }, /* -2d.0B */
+	{ -10, 11883 }, /* -1.0dB */
+	{   0, 11101 }, /* -0.0dB */
+	{   5, 10718 }, /*  0.5dB */
+	{  10, 10339 }, /*  1.0dB */
+	{  15,  9947 }, /*  1.5dB */
+	{  20,  9552 }, /*  2.0dB */
+	{  25,  9183 }, /*  2.5dB */
+	{  30,  8799 }, /*  3.0dB */
+	{  35,  8422 }, /*  3.5dB */
+	{  40,  8062 }, /*  4.0dB */
+	{  45,  7707 }, /*  4.5dB */
+	{  50,  7353 }, /*  5.0dB */
+	{  55,  7025 }, /*  5.5dB */
+	{  60,  6684 }, /*  6.0dB */
+	{  65,  6331 }, /*  6.5dB */
+	{  70,  6036 }, /*  7.0dB */
+	{  75,  5727 }, /*  7.5dB */
+	{  80,  5437 }, /*  8.0dB */
+	{  85,  5164 }, /*  8.5dB */
+	{  90,  4902 }, /*  9.0dB */
+	{  95,  4653 }, /*  9.5dB */
+	{ 100,  4408 }, /* 10.0dB */
+	{ 105,  4187 }, /* 10.5dB */
+	{ 110,  3961 }, /* 11.0dB */
+	{ 115,  3751 }, /* 11.5dB */
+	{ 120,  3558 }, /* 12.0dB */
+	{ 125,  3368 }, /* 12.5dB */
+	{ 130,  3191 }, /* 13.0dB */
+	{ 135,  3017 }, /* 13.5dB */
+	{ 140,  2862 }, /* 14.0dB */
+	{ 145,  2710 }, /* 14.5dB */
+	{ 150,  2565 }, /* 15.0dB */
+	{ 160,  2300 }, /* 16.0dB */
+	{ 170,  2058 }, /* 17.0dB */
+	{ 180,  1849 }, /* 18.0dB */
+	{ 190,  1663 }, /* 19.0dB */
+	{ 200,  1495 }, /* 20.0dB */
+	{ 210,  1349 }, /* 21.0dB */
+	{ 220,  1222 }, /* 22.0dB */
+	{ 230,  1110 }, /* 23.0dB */
+	{ 240,  1011 }, /* 24.0dB */
+	{ 250,   925 }, /* 25.0dB */
+	{ 260,   853 }, /* 26.0dB */
+	{ 270,   789 }, /* 27.0dB */
+	{ 280,   734 }, /* 28.0dB */
+	{ 290,   690 }, /* 29.0dB */
+	{ 300,   650 }, /* 30.0dB */
+	{ 310,   619 }, /* 31.0dB */
+	{ 320,   593 }, /* 32.0dB */
+	{ 330,   571 }, /* 33.0dB */
+	{ 400,   498 }, /* 40.0dB */
+	{ 450,	 484 }, /* 45.0dB */
+	{ 500,	 481 }	/* 50.0dB */
+};
+
+/* RF level C/N lookup table */
+static const struct stv090x_tab stv090x_rf_tab[] = {
+	{  -5, 0xcaa1 }, /*  -5dBm */
+	{ -10, 0xc229 }, /* -10dBm */
+	{ -15, 0xbb08 }, /* -15dBm */
+	{ -20, 0xb4bc }, /* -20dBm */
+	{ -25, 0xad5a }, /* -25dBm */
+	{ -30, 0xa298 }, /* -30dBm */
+	{ -35, 0x98a8 }, /* -35dBm */
+	{ -40, 0x8389 }, /* -40dBm */
+	{ -45, 0x59be }, /* -45dBm */
+	{ -50, 0x3a14 }, /* -50dBm */
+	{ -55, 0x2d11 }, /* -55dBm */
+	{ -60, 0x210d }, /* -60dBm */
+	{ -65, 0xa14f }, /* -65dBm */
+	{ -70, 0x07aa }	 /* -70dBm */
+};
+
+
+static struct stv090x_reg stv0900_initval[] = {
+
+	{ STV090x_OUTCFG,		0x00 },
+	{ STV090x_MODECFG,		0xff },
+	{ STV090x_AGCRF1CFG,		0x11 },
+	{ STV090x_AGCRF2CFG,		0x13 },
+	{ STV090x_TSGENERAL1X,		0x14 },
+	{ STV090x_TSTTNR2,		0x21 },
+	{ STV090x_TSTTNR4,		0x21 },
+	{ STV090x_P2_DISTXCTL,		0x22 },
+	{ STV090x_P2_F22TX,		0xc0 },
+	{ STV090x_P2_F22RX,		0xc0 },
+	{ STV090x_P2_DISRXCTL,		0x00 },
+	{ STV090x_P2_DMDCFGMD,		0xF9 },
+	{ STV090x_P2_DEMOD,		0x08 },
+	{ STV090x_P2_DMDCFG3,		0xc4 },
+	{ STV090x_P2_CARFREQ,		0xed },
+	{ STV090x_P2_LDT,		0xd0 },
+	{ STV090x_P2_LDT2,		0xb8 },
+	{ STV090x_P2_TMGCFG,		0xd2 },
+	{ STV090x_P2_TMGTHRISE,		0x20 },
+	{ STV090x_P1_TMGCFG,		0xd2 },
+
+	{ STV090x_P2_TMGTHFALL,		0x00 },
+	{ STV090x_P2_FECSPY,		0x88 },
+	{ STV090x_P2_FSPYDATA,		0x3a },
+	{ STV090x_P2_FBERCPT4,		0x00 },
+	{ STV090x_P2_FSPYBER,		0x10 },
+	{ STV090x_P2_ERRCTRL1,		0x35 },
+	{ STV090x_P2_ERRCTRL2,		0xc1 },
+	{ STV090x_P2_CFRICFG,		0xf8 },
+	{ STV090x_P2_NOSCFG,		0x1c },
+	{ STV090x_P2_DMDTOM,		0x20 },
+	{ STV090x_P2_CORRELMANT,	0x70 },
+	{ STV090x_P2_CORRELABS,		0x88 },
+	{ STV090x_P2_AGC2O,		0x5b },
+	{ STV090x_P2_AGC2REF,		0x38 },
+	{ STV090x_P2_CARCFG,		0xe4 },
+	{ STV090x_P2_ACLC,		0x1A },
+	{ STV090x_P2_BCLC,		0x09 },
+	{ STV090x_P2_CARHDR,		0x08 },
+	{ STV090x_P2_KREFTMG,		0xc1 },
+	{ STV090x_P2_SFRUPRATIO,	0xf0 },
+	{ STV090x_P2_SFRLOWRATIO,	0x70 },
+	{ STV090x_P2_SFRSTEP,		0x58 },
+	{ STV090x_P2_TMGCFG2,		0x01 },
+	{ STV090x_P2_CAR2CFG,		0x26 },
+	{ STV090x_P2_BCLC2S2Q,		0x86 },
+	{ STV090x_P2_BCLC2S28,		0x86 },
+	{ STV090x_P2_SMAPCOEF7,		0x77 },
+	{ STV090x_P2_SMAPCOEF6,		0x85 },
+	{ STV090x_P2_SMAPCOEF5,		0x77 },
+	{ STV090x_P2_TSCFGL,		0x20 },
+	{ STV090x_P2_DMDCFG2,		0x3b },
+	{ STV090x_P2_MODCODLST0,	0xff },
+	{ STV090x_P2_MODCODLST1,	0xff },
+	{ STV090x_P2_MODCODLST2,	0xff },
+	{ STV090x_P2_MODCODLST3,	0xff },
+	{ STV090x_P2_MODCODLST4,	0xff },
+	{ STV090x_P2_MODCODLST5,	0xff },
+	{ STV090x_P2_MODCODLST6,	0xff },
+	{ STV090x_P2_MODCODLST7,	0xcc },
+	{ STV090x_P2_MODCODLST8,	0xcc },
+	{ STV090x_P2_MODCODLST9,	0xcc },
+	{ STV090x_P2_MODCODLSTA,	0xcc },
+	{ STV090x_P2_MODCODLSTB,	0xcc },
+	{ STV090x_P2_MODCODLSTC,	0xcc },
+	{ STV090x_P2_MODCODLSTD,	0xcc },
+	{ STV090x_P2_MODCODLSTE,	0xcc },
+	{ STV090x_P2_MODCODLSTF,	0xcf },
+	{ STV090x_P1_DISTXCTL,		0x22 },
+	{ STV090x_P1_F22TX,		0xc0 },
+	{ STV090x_P1_F22RX,		0xc0 },
+	{ STV090x_P1_DISRXCTL,		0x00 },
+	{ STV090x_P1_DMDCFGMD,		0xf9 },
+	{ STV090x_P1_DEMOD,		0x08 },
+	{ STV090x_P1_DMDCFG3,		0xc4 },
+	{ STV090x_P1_DMDTOM,		0x20 },
+	{ STV090x_P1_CARFREQ,		0xed },
+	{ STV090x_P1_LDT,		0xd0 },
+	{ STV090x_P1_LDT2,		0xb8 },
+	{ STV090x_P1_TMGCFG,		0xd2 },
+	{ STV090x_P1_TMGTHRISE,		0x20 },
+	{ STV090x_P1_TMGTHFALL,		0x00 },
+	{ STV090x_P1_SFRUPRATIO,	0xf0 },
+	{ STV090x_P1_SFRLOWRATIO,	0x70 },
+	{ STV090x_P1_TSCFGL,		0x20 },
+	{ STV090x_P1_FECSPY,		0x88 },
+	{ STV090x_P1_FSPYDATA,		0x3a },
+	{ STV090x_P1_FBERCPT4,		0x00 },
+	{ STV090x_P1_FSPYBER,		0x10 },
+	{ STV090x_P1_ERRCTRL1,		0x35 },
+	{ STV090x_P1_ERRCTRL2,		0xc1 },
+	{ STV090x_P1_CFRICFG,		0xf8 },
+	{ STV090x_P1_NOSCFG,		0x1c },
+	{ STV090x_P1_CORRELMANT,	0x70 },
+	{ STV090x_P1_CORRELABS,		0x88 },
+	{ STV090x_P1_AGC2O,		0x5b },
+	{ STV090x_P1_AGC2REF,		0x38 },
+	{ STV090x_P1_CARCFG,		0xe4 },
+	{ STV090x_P1_ACLC,		0x1A },
+	{ STV090x_P1_BCLC,		0x09 },
+	{ STV090x_P1_CARHDR,		0x08 },
+	{ STV090x_P1_KREFTMG,		0xc1 },
+	{ STV090x_P1_SFRSTEP,		0x58 },
+	{ STV090x_P1_TMGCFG2,		0x01 },
+	{ STV090x_P1_CAR2CFG,		0x26 },
+	{ STV090x_P1_BCLC2S2Q,		0x86 },
+	{ STV090x_P1_BCLC2S28,		0x86 },
+	{ STV090x_P1_SMAPCOEF7,		0x77 },
+	{ STV090x_P1_SMAPCOEF6,		0x85 },
+	{ STV090x_P1_SMAPCOEF5,		0x77 },
+	{ STV090x_P1_DMDCFG2,		0x3b },
+	{ STV090x_P1_MODCODLST0,	0xff },
+	{ STV090x_P1_MODCODLST1,	0xff },
+	{ STV090x_P1_MODCODLST2,	0xff },
+	{ STV090x_P1_MODCODLST3,	0xff },
+	{ STV090x_P1_MODCODLST4,	0xff },
+	{ STV090x_P1_MODCODLST5,	0xff },
+	{ STV090x_P1_MODCODLST6,	0xff },
+	{ STV090x_P1_MODCODLST7,	0xcc },
+	{ STV090x_P1_MODCODLST8,	0xcc },
+	{ STV090x_P1_MODCODLST9,	0xcc },
+	{ STV090x_P1_MODCODLSTA,	0xcc },
+	{ STV090x_P1_MODCODLSTB,	0xcc },
+	{ STV090x_P1_MODCODLSTC,	0xcc },
+	{ STV090x_P1_MODCODLSTD,	0xcc },
+	{ STV090x_P1_MODCODLSTE,	0xcc },
+	{ STV090x_P1_MODCODLSTF,	0xcf },
+	{ STV090x_GENCFG,		0x1d },
+	{ STV090x_NBITER_NF4,		0x37 },
+	{ STV090x_NBITER_NF5,		0x29 },
+	{ STV090x_NBITER_NF6,		0x37 },
+	{ STV090x_NBITER_NF7,		0x33 },
+	{ STV090x_NBITER_NF8,		0x31 },
+	{ STV090x_NBITER_NF9,		0x2f },
+	{ STV090x_NBITER_NF10,		0x39 },
+	{ STV090x_NBITER_NF11,		0x3a },
+	{ STV090x_NBITER_NF12,		0x29 },
+	{ STV090x_NBITER_NF13,		0x37 },
+	{ STV090x_NBITER_NF14,		0x33 },
+	{ STV090x_NBITER_NF15,		0x2f },
+	{ STV090x_NBITER_NF16,		0x39 },
+	{ STV090x_NBITER_NF17,		0x3a },
+	{ STV090x_NBITERNOERR,		0x04 },
+	{ STV090x_GAINLLR_NF4,		0x0C },
+	{ STV090x_GAINLLR_NF5,		0x0F },
+	{ STV090x_GAINLLR_NF6,		0x11 },
+	{ STV090x_GAINLLR_NF7,		0x14 },
+	{ STV090x_GAINLLR_NF8,		0x17 },
+	{ STV090x_GAINLLR_NF9,		0x19 },
+	{ STV090x_GAINLLR_NF10,		0x20 },
+	{ STV090x_GAINLLR_NF11,		0x21 },
+	{ STV090x_GAINLLR_NF12,		0x0D },
+	{ STV090x_GAINLLR_NF13,		0x0F },
+	{ STV090x_GAINLLR_NF14,		0x13 },
+	{ STV090x_GAINLLR_NF15,		0x1A },
+	{ STV090x_GAINLLR_NF16,		0x1F },
+	{ STV090x_GAINLLR_NF17,		0x21 },
+	{ STV090x_RCCFGH,		0x20 },
+	{ STV090x_P1_FECM,		0x01 }, /* disable DSS modes */
+	{ STV090x_P2_FECM,		0x01 }, /* disable DSS modes */
+	{ STV090x_P1_PRVIT,		0x2F }, /* disable PR 6/7 */
+	{ STV090x_P2_PRVIT,		0x2F }, /* disable PR 6/7 */
+};
+
+static struct stv090x_reg stv0903_initval[] = {
+	{ STV090x_OUTCFG,		0x00 },
+	{ STV090x_AGCRF1CFG,		0x11 },
+	{ STV090x_STOPCLK1,		0x48 },
+	{ STV090x_STOPCLK2,		0x14 },
+	{ STV090x_TSTTNR1,		0x27 },
+	{ STV090x_TSTTNR2,		0x21 },
+	{ STV090x_P1_DISTXCTL,		0x22 },
+	{ STV090x_P1_F22TX,		0xc0 },
+	{ STV090x_P1_F22RX,		0xc0 },
+	{ STV090x_P1_DISRXCTL,		0x00 },
+	{ STV090x_P1_DMDCFGMD,		0xF9 },
+	{ STV090x_P1_DEMOD,		0x08 },
+	{ STV090x_P1_DMDCFG3,		0xc4 },
+	{ STV090x_P1_CARFREQ,		0xed },
+	{ STV090x_P1_TNRCFG2,		0x82 },
+	{ STV090x_P1_LDT,		0xd0 },
+	{ STV090x_P1_LDT2,		0xb8 },
+	{ STV090x_P1_TMGCFG,		0xd2 },
+	{ STV090x_P1_TMGTHRISE,		0x20 },
+	{ STV090x_P1_TMGTHFALL,		0x00 },
+	{ STV090x_P1_SFRUPRATIO,	0xf0 },
+	{ STV090x_P1_SFRLOWRATIO,	0x70 },
+	{ STV090x_P1_TSCFGL,		0x20 },
+	{ STV090x_P1_FECSPY,		0x88 },
+	{ STV090x_P1_FSPYDATA,		0x3a },
+	{ STV090x_P1_FBERCPT4,		0x00 },
+	{ STV090x_P1_FSPYBER,		0x10 },
+	{ STV090x_P1_ERRCTRL1,		0x35 },
+	{ STV090x_P1_ERRCTRL2,		0xc1 },
+	{ STV090x_P1_CFRICFG,		0xf8 },
+	{ STV090x_P1_NOSCFG,		0x1c },
+	{ STV090x_P1_DMDTOM,		0x20 },
+	{ STV090x_P1_CORRELMANT,	0x70 },
+	{ STV090x_P1_CORRELABS,		0x88 },
+	{ STV090x_P1_AGC2O,		0x5b },
+	{ STV090x_P1_AGC2REF,		0x38 },
+	{ STV090x_P1_CARCFG,		0xe4 },
+	{ STV090x_P1_ACLC,		0x1A },
+	{ STV090x_P1_BCLC,		0x09 },
+	{ STV090x_P1_CARHDR,		0x08 },
+	{ STV090x_P1_KREFTMG,		0xc1 },
+	{ STV090x_P1_SFRSTEP,		0x58 },
+	{ STV090x_P1_TMGCFG2,		0x01 },
+	{ STV090x_P1_CAR2CFG,		0x26 },
+	{ STV090x_P1_BCLC2S2Q,		0x86 },
+	{ STV090x_P1_BCLC2S28,		0x86 },
+	{ STV090x_P1_SMAPCOEF7,		0x77 },
+	{ STV090x_P1_SMAPCOEF6,		0x85 },
+	{ STV090x_P1_SMAPCOEF5,		0x77 },
+	{ STV090x_P1_DMDCFG2,		0x3b },
+	{ STV090x_P1_MODCODLST0,	0xff },
+	{ STV090x_P1_MODCODLST1,	0xff },
+	{ STV090x_P1_MODCODLST2,	0xff },
+	{ STV090x_P1_MODCODLST3,	0xff },
+	{ STV090x_P1_MODCODLST4,	0xff },
+	{ STV090x_P1_MODCODLST5,	0xff },
+	{ STV090x_P1_MODCODLST6,	0xff },
+	{ STV090x_P1_MODCODLST7,	0xcc },
+	{ STV090x_P1_MODCODLST8,	0xcc },
+	{ STV090x_P1_MODCODLST9,	0xcc },
+	{ STV090x_P1_MODCODLSTA,	0xcc },
+	{ STV090x_P1_MODCODLSTB,	0xcc },
+	{ STV090x_P1_MODCODLSTC,	0xcc },
+	{ STV090x_P1_MODCODLSTD,	0xcc },
+	{ STV090x_P1_MODCODLSTE,	0xcc },
+	{ STV090x_P1_MODCODLSTF,	0xcf },
+	{ STV090x_GENCFG,		0x1c },
+	{ STV090x_NBITER_NF4,		0x37 },
+	{ STV090x_NBITER_NF5,		0x29 },
+	{ STV090x_NBITER_NF6,		0x37 },
+	{ STV090x_NBITER_NF7,		0x33 },
+	{ STV090x_NBITER_NF8,		0x31 },
+	{ STV090x_NBITER_NF9,		0x2f },
+	{ STV090x_NBITER_NF10,		0x39 },
+	{ STV090x_NBITER_NF11,		0x3a },
+	{ STV090x_NBITER_NF12,		0x29 },
+	{ STV090x_NBITER_NF13,		0x37 },
+	{ STV090x_NBITER_NF14,		0x33 },
+	{ STV090x_NBITER_NF15,		0x2f },
+	{ STV090x_NBITER_NF16,		0x39 },
+	{ STV090x_NBITER_NF17,		0x3a },
+	{ STV090x_NBITERNOERR,		0x04 },
+	{ STV090x_GAINLLR_NF4,		0x0C },
+	{ STV090x_GAINLLR_NF5,		0x0F },
+	{ STV090x_GAINLLR_NF6,		0x11 },
+	{ STV090x_GAINLLR_NF7,		0x14 },
+	{ STV090x_GAINLLR_NF8,		0x17 },
+	{ STV090x_GAINLLR_NF9,		0x19 },
+	{ STV090x_GAINLLR_NF10,		0x20 },
+	{ STV090x_GAINLLR_NF11,		0x21 },
+	{ STV090x_GAINLLR_NF12,		0x0D },
+	{ STV090x_GAINLLR_NF13,		0x0F },
+	{ STV090x_GAINLLR_NF14,		0x13 },
+	{ STV090x_GAINLLR_NF15,		0x1A },
+	{ STV090x_GAINLLR_NF16,		0x1F },
+	{ STV090x_GAINLLR_NF17,		0x21 },
+	{ STV090x_RCCFGH,		0x20 },
+	{ STV090x_P1_FECM,		0x01 }, /*disable the DSS mode */
+	{ STV090x_P1_PRVIT,		0x2f }  /*disable puncture rate 6/7*/
+};
+
+static struct stv090x_reg stv0900_cut20_val[] = {
+
+	{ STV090x_P2_DMDCFG3,		0xe8 },
+	{ STV090x_P2_DMDCFG4,		0x10 },
+	{ STV090x_P2_CARFREQ,		0x38 },
+	{ STV090x_P2_CARHDR,		0x20 },
+	{ STV090x_P2_KREFTMG,		0x5a },
+	{ STV090x_P2_SMAPCOEF7,		0x06 },
+	{ STV090x_P2_SMAPCOEF6,		0x00 },
+	{ STV090x_P2_SMAPCOEF5,		0x04 },
+	{ STV090x_P2_NOSCFG,		0x0c },
+	{ STV090x_P1_DMDCFG3,		0xe8 },
+	{ STV090x_P1_DMDCFG4,		0x10 },
+	{ STV090x_P1_CARFREQ,		0x38 },
+	{ STV090x_P1_CARHDR,		0x20 },
+	{ STV090x_P1_KREFTMG,		0x5a },
+	{ STV090x_P1_SMAPCOEF7,		0x06 },
+	{ STV090x_P1_SMAPCOEF6,		0x00 },
+	{ STV090x_P1_SMAPCOEF5,		0x04 },
+	{ STV090x_P1_NOSCFG,		0x0c },
+	{ STV090x_GAINLLR_NF4,		0x21 },
+	{ STV090x_GAINLLR_NF5,		0x21 },
+	{ STV090x_GAINLLR_NF6,		0x20 },
+	{ STV090x_GAINLLR_NF7,		0x1F },
+	{ STV090x_GAINLLR_NF8,		0x1E },
+	{ STV090x_GAINLLR_NF9,		0x1E },
+	{ STV090x_GAINLLR_NF10,		0x1D },
+	{ STV090x_GAINLLR_NF11,		0x1B },
+	{ STV090x_GAINLLR_NF12,		0x20 },
+	{ STV090x_GAINLLR_NF13,		0x20 },
+	{ STV090x_GAINLLR_NF14,		0x20 },
+	{ STV090x_GAINLLR_NF15,		0x20 },
+	{ STV090x_GAINLLR_NF16,		0x20 },
+	{ STV090x_GAINLLR_NF17,		0x21 },
+};
+
+static struct stv090x_reg stv0903_cut20_val[] = {
+	{ STV090x_P1_DMDCFG3,		0xe8 },
+	{ STV090x_P1_DMDCFG4,		0x10 },
+	{ STV090x_P1_CARFREQ,		0x38 },
+	{ STV090x_P1_CARHDR,		0x20 },
+	{ STV090x_P1_KREFTMG,		0x5a },
+	{ STV090x_P1_SMAPCOEF7,		0x06 },
+	{ STV090x_P1_SMAPCOEF6,		0x00 },
+	{ STV090x_P1_SMAPCOEF5,		0x04 },
+	{ STV090x_P1_NOSCFG,		0x0c },
+	{ STV090x_GAINLLR_NF4,		0x21 },
+	{ STV090x_GAINLLR_NF5,		0x21 },
+	{ STV090x_GAINLLR_NF6,		0x20 },
+	{ STV090x_GAINLLR_NF7,		0x1F },
+	{ STV090x_GAINLLR_NF8,		0x1E },
+	{ STV090x_GAINLLR_NF9,		0x1E },
+	{ STV090x_GAINLLR_NF10,		0x1D },
+	{ STV090x_GAINLLR_NF11,		0x1B },
+	{ STV090x_GAINLLR_NF12,		0x20 },
+	{ STV090x_GAINLLR_NF13,		0x20 },
+	{ STV090x_GAINLLR_NF14,		0x20 },
+	{ STV090x_GAINLLR_NF15,		0x20 },
+	{ STV090x_GAINLLR_NF16,		0x20 },
+	{ STV090x_GAINLLR_NF17,		0x21 }
+};
+
+/* Cut 2.0 Long Frame Tracking CR loop */
+static struct stv090x_long_frame_crloop stv090x_s2_crl_cut20[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_QPSK_12,  0x1f, 0x3f, 0x1e, 0x3f, 0x3d, 0x1f, 0x3d, 0x3e, 0x3d, 0x1e },
+	{ STV090x_QPSK_35,  0x2f, 0x3f, 0x2e, 0x2f, 0x3d, 0x0f, 0x0e, 0x2e, 0x3d, 0x0e },
+	{ STV090x_QPSK_23,  0x2f, 0x3f, 0x2e, 0x2f, 0x0e, 0x0f, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_QPSK_34,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_QPSK_45,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_QPSK_56,  0x3f, 0x3f, 0x3e, 0x1f, 0x0e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_QPSK_89,  0x3f, 0x3f, 0x3e, 0x1f, 0x1e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_QPSK_910, 0x3f, 0x3f, 0x3e, 0x1f, 0x1e, 0x3e, 0x0e, 0x1e, 0x3d, 0x3d },
+	{ STV090x_8PSK_35,  0x3c, 0x3e, 0x1c, 0x2e, 0x0c, 0x1e, 0x2b, 0x2d, 0x1b, 0x1d },
+	{ STV090x_8PSK_23,  0x1d, 0x3e, 0x3c, 0x2e, 0x2c, 0x1e, 0x0c, 0x2d, 0x2b, 0x1d },
+	{ STV090x_8PSK_34,  0x0e, 0x3e, 0x3d, 0x2e, 0x0d, 0x1e, 0x2c, 0x2d, 0x0c, 0x1d },
+	{ STV090x_8PSK_56,  0x2e, 0x3e, 0x1e, 0x2e, 0x2d, 0x1e, 0x3c, 0x2d, 0x2c, 0x1d },
+	{ STV090x_8PSK_89,  0x3e, 0x3e, 0x1e, 0x2e, 0x3d, 0x1e, 0x0d, 0x2d, 0x3c, 0x1d },
+	{ STV090x_8PSK_910, 0x3e, 0x3e, 0x1e, 0x2e, 0x3d, 0x1e, 0x1d, 0x2d, 0x0d, 0x1d }
+};
+
+/* Cut 3.0 Long Frame Tracking CR loop */
+static	struct stv090x_long_frame_crloop stv090x_s2_crl_cut30[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_QPSK_12,  0x3c, 0x2c, 0x0c, 0x2c, 0x1b, 0x2c, 0x1b, 0x1c, 0x0b, 0x3b },
+	{ STV090x_QPSK_35,  0x0d, 0x0d, 0x0c, 0x0d, 0x1b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
+	{ STV090x_QPSK_23,  0x1d, 0x0d, 0x0c, 0x1d, 0x2b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
+	{ STV090x_QPSK_34,  0x1d, 0x1d, 0x0c, 0x1d, 0x2b, 0x3c, 0x1b, 0x1c, 0x0b, 0x3b },
+	{ STV090x_QPSK_45,  0x2d, 0x1d, 0x1c, 0x1d, 0x2b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
+	{ STV090x_QPSK_56,  0x2d, 0x1d, 0x1c, 0x1d, 0x2b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
+	{ STV090x_QPSK_89,  0x3d, 0x2d, 0x1c, 0x1d, 0x3b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
+	{ STV090x_QPSK_910, 0x3d, 0x2d, 0x1c, 0x1d, 0x3b, 0x3c, 0x2b, 0x0c, 0x1b, 0x3b },
+	{ STV090x_8PSK_35,  0x39, 0x29, 0x39, 0x19, 0x19, 0x19, 0x19, 0x19, 0x09, 0x19 },
+	{ STV090x_8PSK_23,  0x2a, 0x39, 0x1a, 0x0a, 0x39, 0x0a, 0x29, 0x39, 0x29, 0x0a },
+	{ STV090x_8PSK_34,  0x2b, 0x3a, 0x1b, 0x1b, 0x3a, 0x1b, 0x1a, 0x0b, 0x1a, 0x3a },
+	{ STV090x_8PSK_56,  0x0c, 0x1b, 0x3b, 0x3b, 0x1b, 0x3b, 0x3a, 0x3b, 0x3a, 0x1b },
+	{ STV090x_8PSK_89,  0x0d, 0x3c, 0x2c, 0x2c, 0x2b, 0x0c, 0x0b, 0x3b, 0x0b, 0x1b },
+	{ STV090x_8PSK_910, 0x0d, 0x0d, 0x2c, 0x3c, 0x3b, 0x1c, 0x0b, 0x3b, 0x0b, 0x1b }
+};
+
+/* Cut 2.0 Long Frame Tracking CR Loop */
+static struct stv090x_long_frame_crloop stv090x_s2_apsk_crl_cut20[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_16APSK_23,  0x0c, 0x0c, 0x0c, 0x0c, 0x1d, 0x0c, 0x3c, 0x0c, 0x2c, 0x0c },
+	{ STV090x_16APSK_34,  0x0c, 0x0c, 0x0c, 0x0c, 0x0e, 0x0c, 0x2d, 0x0c, 0x1d, 0x0c },
+	{ STV090x_16APSK_45,  0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x0c, 0x3d, 0x0c, 0x2d, 0x0c },
+	{ STV090x_16APSK_56,  0x0c, 0x0c, 0x0c, 0x0c, 0x1e, 0x0c, 0x3d, 0x0c, 0x2d, 0x0c },
+	{ STV090x_16APSK_89,  0x0c, 0x0c, 0x0c, 0x0c, 0x2e, 0x0c, 0x0e, 0x0c, 0x3d, 0x0c },
+	{ STV090x_16APSK_910, 0x0c, 0x0c, 0x0c, 0x0c, 0x2e, 0x0c, 0x0e, 0x0c, 0x3d, 0x0c },
+	{ STV090x_32APSK_34,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
+	{ STV090x_32APSK_45,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
+	{ STV090x_32APSK_56,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
+	{ STV090x_32APSK_89,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c },
+	{ STV090x_32APSK_910, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c }
+};
+
+/* Cut 3.0 Long Frame Tracking CR Loop */
+static struct stv090x_long_frame_crloop	stv090x_s2_apsk_crl_cut30[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_16APSK_23,  0x0a, 0x0a, 0x0a, 0x0a, 0x1a, 0x0a, 0x3a, 0x0a, 0x2a, 0x0a },
+	{ STV090x_16APSK_34,  0x0a, 0x0a, 0x0a, 0x0a, 0x0b, 0x0a, 0x3b, 0x0a, 0x1b, 0x0a },
+	{ STV090x_16APSK_45,  0x0a, 0x0a, 0x0a, 0x0a, 0x1b, 0x0a, 0x3b, 0x0a, 0x2b, 0x0a },
+	{ STV090x_16APSK_56,  0x0a, 0x0a, 0x0a, 0x0a, 0x1b, 0x0a, 0x3b, 0x0a, 0x2b, 0x0a },
+	{ STV090x_16APSK_89,  0x0a, 0x0a, 0x0a, 0x0a, 0x2b, 0x0a, 0x0c, 0x0a, 0x3b, 0x0a },
+	{ STV090x_16APSK_910, 0x0a, 0x0a, 0x0a, 0x0a, 0x2b, 0x0a, 0x0c, 0x0a, 0x3b, 0x0a },
+	{ STV090x_32APSK_34,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
+	{ STV090x_32APSK_45,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
+	{ STV090x_32APSK_56,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
+	{ STV090x_32APSK_89,  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
+	{ STV090x_32APSK_910, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a }
+};
+
+static struct stv090x_long_frame_crloop stv090x_s2_lowqpsk_crl_cut20[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_QPSK_14,  0x0f, 0x3f, 0x0e, 0x3f, 0x2d, 0x2f, 0x2d, 0x1f, 0x3d, 0x3e },
+	{ STV090x_QPSK_13,  0x0f, 0x3f, 0x0e, 0x3f, 0x2d, 0x2f, 0x3d, 0x0f, 0x3d, 0x2e },
+	{ STV090x_QPSK_25,  0x1f, 0x3f, 0x1e, 0x3f, 0x3d, 0x1f, 0x3d, 0x3e, 0x3d, 0x2e }
+};
+
+static struct stv090x_long_frame_crloop	stv090x_s2_lowqpsk_crl_cut30[] = {
+	/* MODCOD  2MPon 2MPoff 5MPon 5MPoff 10MPon 10MPoff 20MPon 20MPoff 30MPon 30MPoff */
+	{ STV090x_QPSK_14,  0x0c, 0x3c, 0x0b, 0x3c, 0x2a, 0x2c, 0x2a, 0x1c, 0x3a, 0x3b },
+	{ STV090x_QPSK_13,  0x0c, 0x3c, 0x0b, 0x3c, 0x2a, 0x2c, 0x3a, 0x0c, 0x3a, 0x2b },
+	{ STV090x_QPSK_25,  0x1c, 0x3c, 0x1b, 0x3c, 0x3a, 0x1c, 0x3a, 0x3b, 0x3a, 0x2b }
+};
+
+/* Cut 2.0 Short Frame Tracking CR Loop */
+static struct stv090x_short_frame_crloop stv090x_s2_short_crl_cut20[] = {
+	/* MODCOD	  2M    5M    10M   20M   30M */
+	{ STV090x_QPSK,   0x2f, 0x2e, 0x0e, 0x0e, 0x3d },
+	{ STV090x_8PSK,   0x3e, 0x0e, 0x2d, 0x0d, 0x3c },
+	{ STV090x_16APSK, 0x1e, 0x1e, 0x1e, 0x3d, 0x2d },
+	{ STV090x_32APSK, 0x1e, 0x1e, 0x1e, 0x3d, 0x2d }
+};
+
+/* Cut 3.0 Short Frame Tracking CR Loop */
+static struct stv090x_short_frame_crloop stv090x_s2_short_crl_cut30[] = {
+	/* MODCOD  	  2M	5M    10M   20M	  30M */
+	{ STV090x_QPSK,   0x2C, 0x2B, 0x0B, 0x0B, 0x3A },
+	{ STV090x_8PSK,   0x3B, 0x0B, 0x2A, 0x0A, 0x39 },
+	{ STV090x_16APSK, 0x1B, 0x1B, 0x1B, 0x3A, 0x2A },
+	{ STV090x_32APSK, 0x1B, 0x1B, 0x1B, 0x3A, 0x2A }
+};
+
+static inline s32 comp2(s32 __x, s32 __width)
+{
+	if (__width == 32)
+		return __x;
+	else
+		return (__x >= (1 << (__width - 1))) ? (__x - (1 << __width)) : __x;
+}
+
+static int stv090x_read_reg(struct stv090x_state *state, unsigned int reg)
+{
+	const struct stv090x_config *config = state->config;
+	int ret;
+
+	u8 b0[] = { reg >> 8, reg & 0xff };
+	u8 buf;
+
+	struct i2c_msg msg[] = {
+		{ .addr	= config->address, .flags	= 0, 		.buf = b0,   .len = 2 },
+		{ .addr	= config->address, .flags	= I2C_M_RD,	.buf = &buf, .len = 1 }
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+	if (ret != 2) {
+		if (ret != -ERESTARTSYS)
+			dprintk(FE_ERROR, 1,
+				"Read error, Reg=[0x%02x], Status=%d",
+				reg, ret);
+
+		return ret < 0 ? ret : -EREMOTEIO;
+	}
+	if (unlikely(*state->verbose >= FE_DEBUGREG))
+		dprintk(FE_ERROR, 1, "Reg=[0x%02x], data=%02x",
+			reg, buf);
+
+	return (unsigned int) buf;
+}
+
+static int stv090x_write_regs(struct stv090x_state *state, unsigned int reg, u8 *data, u32 count)
+{
+	const struct stv090x_config *config = state->config;
+	int ret;
+	u8 buf[2 + count];
+	struct i2c_msg i2c_msg = { .addr = config->address, .flags = 0, .buf = buf, .len = 2 + count };
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	memcpy(&buf[2], data, count);
+
+	if (unlikely(*state->verbose >= FE_DEBUGREG)) {
+		int i;
+
+		printk(KERN_DEBUG "%s [0x%04x]:", __func__, reg);
+		for (i = 0; i < count; i++)
+			printk(" %02x", data[i]);
+		printk("\n");
+	}
+
+	ret = i2c_transfer(state->i2c, &i2c_msg, 1);
+	if (ret != 1) {
+		if (ret != -ERESTARTSYS)
+			dprintk(FE_ERROR, 1, "Reg=[0x%04x], Data=[0x%02x ...], Count=%u, Status=%d",
+				reg, data[0], count, ret);
+		return ret < 0 ? ret : -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int stv090x_write_reg(struct stv090x_state *state, unsigned int reg, u8 data)
+{
+	return stv090x_write_regs(state, reg, &data, 1);
+}
+
+static int stv090x_i2c_gate_ctrl(struct stv090x_state *state, int enable)
+{
+	u32 reg;
+
+	/*
+	 * NOTE! A lock is used as a FSM to control the state in which
+	 * access is serialized between two tuners on the same demod.
+	 * This has nothing to do with a lock to protect a critical section
+	 * which may in some other cases be confused with protecting I/O
+	 * access to the demodulator gate.
+	 * In case of any error, the lock is unlocked and exit within the
+	 * relevant operations themselves.
+	 */
+	if (enable) {
+		if (state->config->tuner_i2c_lock)
+			state->config->tuner_i2c_lock(&state->frontend, 1);
+		else
+			mutex_lock(&state->internal->tuner_lock);
+	}
+
+	reg = STV090x_READ_DEMOD(state, I2CRPT);
+	if (enable) {
+		dprintk(FE_DEBUG, 1, "Enable Gate");
+		STV090x_SETFIELD_Px(reg, I2CT_ON_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, I2CRPT, reg) < 0)
+			goto err;
+
+	} else {
+		dprintk(FE_DEBUG, 1, "Disable Gate");
+		STV090x_SETFIELD_Px(reg, I2CT_ON_FIELD, 0);
+		if ((STV090x_WRITE_DEMOD(state, I2CRPT, reg)) < 0)
+			goto err;
+	}
+
+	if (!enable) {
+		if (state->config->tuner_i2c_lock)
+			state->config->tuner_i2c_lock(&state->frontend, 0);
+		else
+			mutex_unlock(&state->internal->tuner_lock);
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	if (state->config->tuner_i2c_lock)
+		state->config->tuner_i2c_lock(&state->frontend, 0);
+	else
+		mutex_unlock(&state->internal->tuner_lock);
+	return -1;
+}
+
+static void stv090x_get_lock_tmg(struct stv090x_state *state)
+{
+	switch (state->algo) {
+	case STV090x_BLIND_SEARCH:
+		dprintk(FE_DEBUG, 1, "Blind Search");
+		if (state->srate <= 1500000) {  /*10Msps< SR <=15Msps*/
+			state->DemodTimeout = 1500;
+			state->FecTimeout = 400;
+		} else if (state->srate <= 5000000) {  /*10Msps< SR <=15Msps*/
+			state->DemodTimeout = 1000;
+			state->FecTimeout = 300;
+		} else {  /*SR >20Msps*/
+			state->DemodTimeout = 700;
+			state->FecTimeout = 100;
+		}
+		break;
+
+	case STV090x_COLD_SEARCH:
+	case STV090x_WARM_SEARCH:
+	default:
+		dprintk(FE_DEBUG, 1, "Normal Search");
+		if (state->srate <= 1000000) {  /*SR <=1Msps*/
+			state->DemodTimeout = 4500;
+			state->FecTimeout = 1700;
+		} else if (state->srate <= 2000000) { /*1Msps < SR <= 2Msps */
+			state->DemodTimeout = 2500;
+			state->FecTimeout = 1100;
+		} else if (state->srate <= 5000000) { /*2Msps < SR <= 5Msps */
+			state->DemodTimeout = 1000;
+			state->FecTimeout = 550;
+		} else if (state->srate <= 10000000) { /*5Msps < SR <= 10Msps */
+			state->DemodTimeout = 700;
+			state->FecTimeout = 250;
+		} else if (state->srate <= 20000000) { /*10Msps < SR <= 20Msps */
+			state->DemodTimeout = 400;
+			state->FecTimeout = 130;
+		} else {   /*SR >20Msps*/
+			state->DemodTimeout = 300;
+			state->FecTimeout = 100;
+		}
+		break;
+	}
+
+	if (state->algo == STV090x_WARM_SEARCH)
+		state->DemodTimeout /= 2;
+}
+
+static int stv090x_set_srate(struct stv090x_state *state, u32 srate)
+{
+	u32 sym;
+
+	if (srate > 60000000) {
+		sym  = (srate << 4); /* SR * 2^16 / master_clk */
+		sym /= (state->internal->mclk >> 12);
+	} else if (srate > 6000000) {
+		sym  = (srate << 6);
+		sym /= (state->internal->mclk >> 10);
+	} else {
+		sym  = (srate << 9);
+		sym /= (state->internal->mclk >> 7);
+	}
+
+	if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0x7f) < 0) /* MSB */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRINIT0, (sym & 0xff)) < 0) /* LSB */
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_set_max_srate(struct stv090x_state *state, u32 clk, u32 srate)
+{
+	u32 sym;
+
+	srate = 105 * (srate / 100);
+	if (srate > 60000000) {
+		sym  = (srate << 4); /* SR * 2^16 / master_clk */
+		sym /= (state->internal->mclk >> 12);
+	} else if (srate > 6000000) {
+		sym  = (srate << 6);
+		sym /= (state->internal->mclk >> 10);
+	} else {
+		sym  = (srate << 9);
+		sym /= (state->internal->mclk >> 7);
+	}
+
+	if (sym < 0x7fff) {
+		if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0) /* MSB */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0) /* LSB */
+			goto err;
+	} else {
+		if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x7f) < 0) /* MSB */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xff) < 0) /* LSB */
+			goto err;
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_set_min_srate(struct stv090x_state *state, u32 clk, u32 srate)
+{
+	u32 sym;
+
+	srate = 95 * (srate / 100);
+	if (srate > 60000000) {
+		sym  = (srate << 4); /* SR * 2^16 / master_clk */
+		sym /= (state->internal->mclk >> 12);
+	} else if (srate > 6000000) {
+		sym  = (srate << 6);
+		sym /= (state->internal->mclk >> 10);
+	} else {
+		sym  = (srate << 9);
+		sym /= (state->internal->mclk >> 7);
+	}
+
+	if (STV090x_WRITE_DEMOD(state, SFRLOW1, ((sym >> 8) & 0x7f)) < 0) /* MSB */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRLOW0, (sym & 0xff)) < 0) /* LSB */
+		goto err;
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static u32 stv090x_car_width(u32 srate, enum stv090x_rolloff rolloff)
+{
+	u32 ro;
+
+	switch (rolloff) {
+	case STV090x_RO_20:
+		ro = 20;
+		break;
+	case STV090x_RO_25:
+		ro = 25;
+		break;
+	case STV090x_RO_35:
+	default:
+		ro = 35;
+		break;
+	}
+
+	return srate + (srate * ro) / 100;
+}
+
+static int stv090x_set_vit_thacq(struct stv090x_state *state)
+{
+	if (STV090x_WRITE_DEMOD(state, VTH12, 0x96) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH23, 0x64) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH34, 0x36) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH56, 0x23) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH67, 0x1e) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH78, 0x19) < 0)
+		goto err;
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_set_vit_thtracq(struct stv090x_state *state)
+{
+	if (STV090x_WRITE_DEMOD(state, VTH12, 0xd0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH23, 0x7d) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH34, 0x53) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH56, 0x2f) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH67, 0x24) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, VTH78, 0x1f) < 0)
+		goto err;
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_set_viterbi(struct stv090x_state *state)
+{
+	switch (state->search_mode) {
+	case STV090x_SEARCH_AUTO:
+		if (STV090x_WRITE_DEMOD(state, FECM, 0x10) < 0) /* DVB-S and DVB-S2 */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, PRVIT, 0x3f) < 0) /* all puncture rate */
+			goto err;
+		break;
+	case STV090x_SEARCH_DVBS1:
+		if (STV090x_WRITE_DEMOD(state, FECM, 0x00) < 0) /* disable DSS */
+			goto err;
+		switch (state->fec) {
+		case STV090x_PR12:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x01) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR23:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x02) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR34:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x04) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR56:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x08) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR78:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x20) < 0)
+				goto err;
+			break;
+
+		default:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x2f) < 0) /* all */
+				goto err;
+			break;
+		}
+		break;
+	case STV090x_SEARCH_DSS:
+		if (STV090x_WRITE_DEMOD(state, FECM, 0x80) < 0)
+			goto err;
+		switch (state->fec) {
+		case STV090x_PR12:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x01) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR23:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x02) < 0)
+				goto err;
+			break;
+
+		case STV090x_PR67:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x10) < 0)
+				goto err;
+			break;
+
+		default:
+			if (STV090x_WRITE_DEMOD(state, PRVIT, 0x13) < 0) /* 1/2, 2/3, 6/7 */
+				goto err;
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_stop_modcod(struct stv090x_state *state)
+{
+	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xff) < 0)
+		goto err;
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_activate_modcod(struct stv090x_state *state)
+{
+	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xfc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xcc) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xcf) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_activate_modcod_single(struct stv090x_state *state)
+{
+
+	if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xf0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0x0f) < 0)
+		goto err;
+
+	return 0;
+
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_vitclk_ctl(struct stv090x_state *state, int enable)
+{
+	u32 reg;
+
+	switch (state->demod) {
+	case STV090x_DEMODULATOR_0:
+		mutex_lock(&state->internal->demod_lock);
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, enable);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		mutex_unlock(&state->internal->demod_lock);
+		break;
+
+	case STV090x_DEMODULATOR_1:
+		mutex_lock(&state->internal->demod_lock);
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, enable);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		mutex_unlock(&state->internal->demod_lock);
+		break;
+
+	default:
+		dprintk(FE_ERROR, 1, "Wrong demodulator!");
+		break;
+	}
+	return 0;
+err:
+	mutex_unlock(&state->internal->demod_lock);
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_dvbs_track_crl(struct stv090x_state *state)
+{
+	if (state->internal->dev_ver >= 0x30) {
+		/* Set ACLC BCLC optimised value vs SR */
+		if (state->srate >= 15000000) {
+			if (STV090x_WRITE_DEMOD(state, ACLC, 0x2b) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1a) < 0)
+				goto err;
+		} else if ((state->srate >= 7000000) && (15000000 > state->srate)) {
+			if (STV090x_WRITE_DEMOD(state, ACLC, 0x0c) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1b) < 0)
+				goto err;
+		} else if (state->srate < 7000000) {
+			if (STV090x_WRITE_DEMOD(state, ACLC, 0x2c) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, BCLC, 0x1c) < 0)
+				goto err;
+		}
+
+	} else {
+		/* Cut 2.0 */
+		if (STV090x_WRITE_DEMOD(state, ACLC, 0x1a) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, BCLC, 0x09) < 0)
+			goto err;
+	}
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_delivery_search(struct stv090x_state *state)
+{
+	u32 reg;
+
+	switch (state->search_mode) {
+	case STV090x_SEARCH_DVBS1:
+	case STV090x_SEARCH_DSS:
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+
+		/* Activate Viterbi decoder in legacy search,
+		 * do not use FRESVIT1, might impact VITERBI2
+		 */
+		if (stv090x_vitclk_ctl(state, 0) < 0)
+			goto err;
+
+		if (stv090x_dvbs_track_crl(state) < 0)
+			goto err;
+
+		if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x22) < 0) /* disable DVB-S2 */
+			goto err;
+
+		if (stv090x_set_vit_thacq(state) < 0)
+			goto err;
+		if (stv090x_set_viterbi(state) < 0)
+			goto err;
+		break;
+
+	case STV090x_SEARCH_DVBS2:
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+
+		if (stv090x_vitclk_ctl(state, 1) < 0)
+			goto err;
+
+		if (STV090x_WRITE_DEMOD(state, ACLC, 0x1a) < 0) /* stop DVB-S CR loop */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, BCLC, 0x09) < 0)
+			goto err;
+
+		if (state->internal->dev_ver <= 0x20) {
+			/* enable S2 carrier loop */
+			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x26) < 0)
+				goto err;
+		} else {
+			/* > Cut 3: Stop carrier 3 */
+			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x66) < 0)
+				goto err;
+		}
+
+		if (state->demod_mode != STV090x_SINGLE) {
+			/* Cut 2: enable link during search */
+			if (stv090x_activate_modcod(state) < 0)
+				goto err;
+		} else {
+			/* Single demodulator
+			 * Authorize SHORT and LONG frames,
+			 * QPSK, 8PSK, 16APSK and 32APSK
+			 */
+			if (stv090x_activate_modcod_single(state) < 0)
+				goto err;
+		}
+
+		if (stv090x_set_vit_thtracq(state) < 0)
+			goto err;
+		break;
+
+	case STV090x_SEARCH_AUTO:
+	default:
+		/* enable DVB-S2 and DVB-S2 in Auto MODE */
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+
+		if (stv090x_vitclk_ctl(state, 0) < 0)
+			goto err;
+
+		if (stv090x_dvbs_track_crl(state) < 0)
+			goto err;
+
+		if (state->internal->dev_ver <= 0x20) {
+			/* enable S2 carrier loop */
+			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x26) < 0)
+				goto err;
+		} else {
+			/* > Cut 3: Stop carrier 3 */
+			if (STV090x_WRITE_DEMOD(state, CAR2CFG, 0x66) < 0)
+				goto err;
+		}
+
+		if (state->demod_mode != STV090x_SINGLE) {
+			/* Cut 2: enable link during search */
+			if (stv090x_activate_modcod(state) < 0)
+				goto err;
+		} else {
+			/* Single demodulator
+			 * Authorize SHORT and LONG frames,
+			 * QPSK, 8PSK, 16APSK and 32APSK
+			 */
+			if (stv090x_activate_modcod_single(state) < 0)
+				goto err;
+		}
+
+		if (stv090x_set_vit_thacq(state) < 0)
+			goto err;
+
+		if (stv090x_set_viterbi(state) < 0)
+			goto err;
+		break;
+	}
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_start_search(struct stv090x_state *state)
+{
+	u32 reg, freq_abs;
+	s16 freq;
+
+	/* Reset demodulator */
+	reg = STV090x_READ_DEMOD(state, DMDISTATE);
+	STV090x_SETFIELD_Px(reg, I2C_DEMOD_MODE_FIELD, 0x1f);
+	if (STV090x_WRITE_DEMOD(state, DMDISTATE, reg) < 0)
+		goto err;
+
+	if (state->internal->dev_ver <= 0x20) {
+		if (state->srate <= 5000000) {
+			if (STV090x_WRITE_DEMOD(state, CARCFG, 0x44) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRUP1, 0x0f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRUP0, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRLOW1, 0xf0) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRLOW0, 0x00) < 0)
+				goto err;
+
+			/*enlarge the timing bandwidth for Low SR*/
+			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x68) < 0)
+				goto err;
+		} else {
+			/* If the symbol rate is >5 Msps
+			Set The carrier search up and low to auto mode */
+			if (STV090x_WRITE_DEMOD(state, CARCFG, 0xc4) < 0)
+				goto err;
+			/*reduce the timing bandwidth for high SR*/
+			if (STV090x_WRITE_DEMOD(state, RTCS2, 0x44) < 0)
+				goto err;
+		}
+	} else {
+		/* >= Cut 3 */
+		if (state->srate <= 5000000) {
+			/* enlarge the timing bandwidth for Low SR */
+			STV090x_WRITE_DEMOD(state, RTCS2, 0x68);
+		} else {
+			/* reduce timing bandwidth for high SR */
+			STV090x_WRITE_DEMOD(state, RTCS2, 0x44);
+		}
+
+		/* Set CFR min and max to manual mode */
+		STV090x_WRITE_DEMOD(state, CARCFG, 0x46);
+
+		if (state->algo == STV090x_WARM_SEARCH) {
+			/* WARM Start
+			 * CFR min = -1MHz,
+			 * CFR max = +1MHz
+			 */
+			freq_abs  = 1000 << 16;
+			freq_abs /= (state->internal->mclk / 1000);
+			freq      = (s16) freq_abs;
+		} else {
+			/* COLD Start
+			 * CFR min =- (SearchRange / 2 + 600KHz)
+			 * CFR max = +(SearchRange / 2 + 600KHz)
+			 * (600KHz for the tuner step size)
+			 */
+			freq_abs  = (state->search_range / 2000) + 600;
+			freq_abs  = freq_abs << 16;
+			freq_abs /= (state->internal->mclk / 1000);
+			freq      = (s16) freq_abs;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, CFRUP1, MSB(freq)) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRUP0, LSB(freq)) < 0)
+			goto err;
+
+		freq *= -1;
+
+		if (STV090x_WRITE_DEMOD(state, CFRLOW1, MSB(freq)) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRLOW0, LSB(freq)) < 0)
+			goto err;
+
+	}
+
+	if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0) < 0)
+		goto err;
+
+	if (state->internal->dev_ver >= 0x20) {
+		if (STV090x_WRITE_DEMOD(state, EQUALCFG, 0x41) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, FFECFG, 0x41) < 0)
+			goto err;
+
+		if ((state->search_mode == STV090x_SEARCH_DVBS1)	||
+			(state->search_mode == STV090x_SEARCH_DSS)	||
+			(state->search_mode == STV090x_SEARCH_AUTO)) {
+
+			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x82) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x00) < 0)
+				goto err;
+		}
+	}
+
+	if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0xe0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0xc0) < 0)
+		goto err;
+
+	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0);
+	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+		goto err;
+	reg = STV090x_READ_DEMOD(state, DMDCFG2);
+	STV090x_SETFIELD_Px(reg, S1S2_SEQUENTIAL_FIELD, 0x0);
+	if (STV090x_WRITE_DEMOD(state, DMDCFG2, reg) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, RTC, 0x88) < 0)
+		goto err;
+
+	if (state->internal->dev_ver >= 0x20) {
+		/*Frequency offset detector setting*/
+		if (state->srate < 2000000) {
+			if (state->internal->dev_ver <= 0x20) {
+				/* Cut 2 */
+				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x39) < 0)
+					goto err;
+			} else {
+				/* Cut 3 */
+				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x89) < 0)
+					goto err;
+			}
+			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x40) < 0)
+				goto err;
+		} else if (state->srate < 10000000) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x4c) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x20) < 0)
+				goto err;
+		} else {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x4b) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CARHDR, 0x20) < 0)
+				goto err;
+		}
+	} else {
+		if (state->srate < 10000000) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0xef) < 0)
+				goto err;
+		} else {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0xed) < 0)
+				goto err;
+		}
+	}
+
+	switch (state->algo) {
+	case STV090x_WARM_SEARCH:
+		/* The symbol rate and the exact
+		 * carrier Frequency are known
+		 */
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
+			goto err;
+		break;
+
+	case STV090x_COLD_SEARCH:
+		/* The symbol rate is known */
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
+			goto err;
+		break;
+
+	default:
+		break;
+	}
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_get_agc2_min_level(struct stv090x_state *state)
+{
+	u32 agc2_min = 0xffff, agc2 = 0, freq_init, freq_step, reg;
+	s32 i, j, steps, dir;
+
+	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
+		goto err;
+	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0);
+	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x83) < 0) /* SR = 65 Msps Max */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xc0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x82) < 0) /* SR= 400 ksps Min */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRLOW0, 0xa0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x00) < 0) /* stop acq @ coarse carrier state */
+		goto err;
+	if (stv090x_set_srate(state, 1000000) < 0)
+		goto err;
+
+	steps  = state->search_range / 1000000;
+	if (steps <= 0)
+		steps = 1;
+
+	dir = 1;
+	freq_step = (1000000 * 256) / (state->internal->mclk / 256);
+	freq_init = 0;
+
+	for (i = 0; i < steps; i++) {
+		if (dir > 0)
+			freq_init = freq_init + (freq_step * i);
+		else
+			freq_init = freq_init - (freq_step * i);
+
+		dir *= -1;
+
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5c) < 0) /* Demod RESET */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT1, (freq_init >> 8) & 0xff) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT0, freq_init & 0xff) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x58) < 0) /* Demod RESET */
+			goto err;
+		msleep(10);
+
+		agc2 = 0;
+		for (j = 0; j < 10; j++) {
+			agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
+				STV090x_READ_DEMOD(state, AGC2I0);
+		}
+		agc2 /= 10;
+		if (agc2 < agc2_min)
+			agc2_min = agc2;
+	}
+
+	return agc2_min;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static u32 stv090x_get_srate(struct stv090x_state *state, u32 clk)
+{
+	u8 r3, r2, r1, r0;
+	s32 srate, int_1, int_2, tmp_1, tmp_2;
+
+	r3 = STV090x_READ_DEMOD(state, SFR3);
+	r2 = STV090x_READ_DEMOD(state, SFR2);
+	r1 = STV090x_READ_DEMOD(state, SFR1);
+	r0 = STV090x_READ_DEMOD(state, SFR0);
+
+	srate = ((r3 << 24) | (r2 << 16) | (r1 <<  8) | r0);
+
+	int_1 = clk >> 16;
+	int_2 = srate >> 16;
+
+	tmp_1 = clk % 0x10000;
+	tmp_2 = srate % 0x10000;
+
+	srate = (int_1 * int_2) +
+		((int_1 * tmp_2) >> 16) +
+		((int_2 * tmp_1) >> 16);
+
+	return srate;
+}
+
+static u32 stv090x_srate_srch_coarse(struct stv090x_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+
+	int tmg_lock = 0, i;
+	s32 tmg_cpt = 0, dir = 1, steps, cur_step = 0, freq;
+	u32 srate_coarse = 0, agc2 = 0, car_step = 1200, reg;
+	u32 agc2th;
+
+	if (state->internal->dev_ver >= 0x30)
+		agc2th = 0x2e00;
+	else
+		agc2th = 0x1f00;
+
+	reg = STV090x_READ_DEMOD(state, DMDISTATE);
+	STV090x_SETFIELD_Px(reg, I2C_DEMOD_MODE_FIELD, 0x1f); /* Demod RESET */
+	if (STV090x_WRITE_DEMOD(state, DMDISTATE, reg) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGCFG, 0x12) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0xf0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0xe0) < 0)
+		goto err;
+	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+	STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 1);
+	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x83) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRUP0, 0xc0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x82) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, SFRLOW0, 0xa0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x50) < 0)
+		goto err;
+
+	if (state->internal->dev_ver >= 0x30) {
+		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x99) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x98) < 0)
+			goto err;
+
+	} else if (state->internal->dev_ver >= 0x20) {
+		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x6a) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRSTEP, 0x95) < 0)
+			goto err;
+	}
+
+	if (state->srate <= 2000000)
+		car_step = 1000;
+	else if (state->srate <= 5000000)
+		car_step = 2000;
+	else if (state->srate <= 12000000)
+		car_step = 3000;
+	else
+		car_step = 5000;
+
+	steps  = -1 + ((state->search_range / 1000) / car_step);
+	steps /= 2;
+	steps  = (2 * steps) + 1;
+	if (steps < 0)
+		steps = 1;
+	else if (steps > 10) {
+		steps = 11;
+		car_step = (state->search_range / 1000) / 10;
+	}
+	cur_step = 0;
+	dir = 1;
+	freq = state->frequency;
+
+	while ((!tmg_lock) && (cur_step < steps)) {
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5f) < 0) /* Demod RESET */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRINIT1, 0x00) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, SFRINIT0, 0x00) < 0)
+			goto err;
+		/* trigger acquisition */
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x40) < 0)
+			goto err;
+		msleep(50);
+		for (i = 0; i < 10; i++) {
+			reg = STV090x_READ_DEMOD(state, DSTATUS);
+			if (STV090x_GETFIELD_Px(reg, TMGLOCK_QUALITY_FIELD) >= 2)
+				tmg_cpt++;
+			agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
+				STV090x_READ_DEMOD(state, AGC2I0);
+		}
+		agc2 /= 10;
+		srate_coarse = stv090x_get_srate(state, state->internal->mclk);
+		cur_step++;
+		dir *= -1;
+		if ((tmg_cpt >= 5) && (agc2 < agc2th) &&
+		    (srate_coarse < 50000000) && (srate_coarse > 850000))
+			tmg_lock = 1;
+		else if (cur_step < steps) {
+			if (dir > 0)
+				freq += cur_step * car_step;
+			else
+				freq -= cur_step * car_step;
+
+			/* Setup tuner */
+			if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+				goto err;
+
+			if (state->config->tuner_set_frequency) {
+				if (state->config->tuner_set_frequency(fe, freq) < 0)
+					goto err_gateoff;
+			}
+
+			if (state->config->tuner_set_bandwidth) {
+				if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
+					goto err_gateoff;
+			}
+
+			if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+				goto err;
+
+			msleep(50);
+
+			if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+				goto err;
+
+			if (state->config->tuner_get_status) {
+				if (state->config->tuner_get_status(fe, &reg) < 0)
+					goto err_gateoff;
+			}
+
+			if (reg)
+				dprintk(FE_DEBUG, 1, "Tuner phase locked");
+			else
+				dprintk(FE_DEBUG, 1, "Tuner unlocked");
+
+			if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+				goto err;
+
+		}
+	}
+	if (!tmg_lock)
+		srate_coarse = 0;
+	else
+		srate_coarse = stv090x_get_srate(state, state->internal->mclk);
+
+	return srate_coarse;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static u32 stv090x_srate_srch_fine(struct stv090x_state *state)
+{
+	u32 srate_coarse, freq_coarse, sym, reg;
+
+	srate_coarse = stv090x_get_srate(state, state->internal->mclk);
+	freq_coarse  = STV090x_READ_DEMOD(state, CFR2) << 8;
+	freq_coarse |= STV090x_READ_DEMOD(state, CFR1);
+	sym = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
+
+	if (sym < state->srate)
+		srate_coarse = 0;
+	else {
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0) /* Demod RESET */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0x20) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0x00) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGCFG, 0xd2) < 0)
+			goto err;
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+
+		if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
+			goto err;
+
+		if (state->internal->dev_ver >= 0x30) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x79) < 0)
+				goto err;
+		} else if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
+				goto err;
+		}
+
+		if (srate_coarse > 3000000) {
+			sym  = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
+			sym  = (sym / 1000) * 65536;
+			sym /= (state->internal->mclk / 1000);
+			if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0)
+				goto err;
+			sym  = 10 * (srate_coarse / 13); /* SFRLOW = SFR - 30% */
+			sym  = (sym / 1000) * 65536;
+			sym /= (state->internal->mclk / 1000);
+			if (STV090x_WRITE_DEMOD(state, SFRLOW1, (sym >> 8) & 0x7f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRLOW0, sym & 0xff) < 0)
+				goto err;
+			sym  = (srate_coarse / 1000) * 65536;
+			sym /= (state->internal->mclk / 1000);
+			if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRINIT0, sym & 0xff) < 0)
+				goto err;
+		} else {
+			sym  = 13 * (srate_coarse / 10); /* SFRUP = SFR + 30% */
+			sym  = (sym / 100) * 65536;
+			sym /= (state->internal->mclk / 100);
+			if (STV090x_WRITE_DEMOD(state, SFRUP1, (sym >> 8) & 0x7f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRUP0, sym & 0xff) < 0)
+				goto err;
+			sym  = 10 * (srate_coarse / 14); /* SFRLOW = SFR - 30% */
+			sym  = (sym / 100) * 65536;
+			sym /= (state->internal->mclk / 100);
+			if (STV090x_WRITE_DEMOD(state, SFRLOW1, (sym >> 8) & 0x7f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRLOW0, sym & 0xff) < 0)
+				goto err;
+			sym  = (srate_coarse / 100) * 65536;
+			sym /= (state->internal->mclk / 100);
+			if (STV090x_WRITE_DEMOD(state, SFRINIT1, (sym >> 8) & 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, SFRINIT0, sym & 0xff) < 0)
+				goto err;
+		}
+		if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x20) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT1, (freq_coarse >> 8) & 0xff) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT0, freq_coarse & 0xff) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0) /* trigger acquisition */
+			goto err;
+	}
+
+	return srate_coarse;
+
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_get_dmdlock(struct stv090x_state *state, s32 timeout)
+{
+	s32 timer = 0, lock = 0;
+	u32 reg;
+	u8 stat;
+
+	while ((timer < timeout) && (!lock)) {
+		reg = STV090x_READ_DEMOD(state, DMDSTATE);
+		stat = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
+
+		switch (stat) {
+		case 0: /* searching */
+		case 1: /* first PLH detected */
+		default:
+			dprintk(FE_DEBUG, 1, "Demodulator searching ..");
+			lock = 0;
+			break;
+		case 2: /* DVB-S2 mode */
+		case 3: /* DVB-S1/legacy mode */
+			reg = STV090x_READ_DEMOD(state, DSTATUS);
+			lock = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
+			break;
+		}
+
+		if (!lock)
+			msleep(10);
+		else
+			dprintk(FE_DEBUG, 1, "Demodulator acquired LOCK");
+
+		timer += 10;
+	}
+	return lock;
+}
+
+static int stv090x_blind_search(struct stv090x_state *state)
+{
+	u32 agc2, reg, srate_coarse;
+	s32 cpt_fail, agc2_ovflw, i;
+	u8 k_ref, k_max, k_min;
+	int coarse_fail = 0;
+	int lock;
+
+	k_max = 110;
+	k_min = 10;
+
+	agc2 = stv090x_get_agc2_min_level(state);
+
+	if (agc2 > STV090x_SEARCH_AGC2_TH(state->internal->dev_ver)) {
+		lock = 0;
+	} else {
+
+		if (state->internal->dev_ver <= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, CARCFG, 0xc4) < 0)
+				goto err;
+		} else {
+			/* > Cut 3 */
+			if (STV090x_WRITE_DEMOD(state, CARCFG, 0x06) < 0)
+				goto err;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, RTCS2, 0x44) < 0)
+			goto err;
+
+		if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, EQUALCFG, 0x41) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, FFECFG, 0x41) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x82) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x00) < 0) /* set viterbi hysteresis */
+				goto err;
+		}
+
+		k_ref = k_max;
+		do {
+			if (STV090x_WRITE_DEMOD(state, KREFTMG, k_ref) < 0)
+				goto err;
+			if (stv090x_srate_srch_coarse(state) != 0) {
+				srate_coarse = stv090x_srate_srch_fine(state);
+				if (srate_coarse != 0) {
+					stv090x_get_lock_tmg(state);
+					lock = stv090x_get_dmdlock(state,
+							state->DemodTimeout);
+				} else {
+					lock = 0;
+				}
+			} else {
+				cpt_fail = 0;
+				agc2_ovflw = 0;
+				for (i = 0; i < 10; i++) {
+					agc2 += (STV090x_READ_DEMOD(state, AGC2I1) << 8) |
+						STV090x_READ_DEMOD(state, AGC2I0);
+					if (agc2 >= 0xff00)
+						agc2_ovflw++;
+					reg = STV090x_READ_DEMOD(state, DSTATUS2);
+					if ((STV090x_GETFIELD_Px(reg, CFR_OVERFLOW_FIELD) == 0x01) &&
+					    (STV090x_GETFIELD_Px(reg, DEMOD_DELOCK_FIELD) == 0x01))
+
+						cpt_fail++;
+				}
+				if ((cpt_fail > 7) || (agc2_ovflw > 7))
+					coarse_fail = 1;
+
+				lock = 0;
+			}
+			k_ref -= 20;
+		} while ((k_ref >= k_min) && (!lock) && (!coarse_fail));
+	}
+
+	return lock;
+
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_chk_tmg(struct stv090x_state *state)
+{
+	u32 reg;
+	s32 tmg_cpt = 0, i;
+	u8 freq, tmg_thh, tmg_thl;
+	int tmg_lock = 0;
+
+	freq = STV090x_READ_DEMOD(state, CARFREQ);
+	tmg_thh = STV090x_READ_DEMOD(state, TMGTHRISE);
+	tmg_thl = STV090x_READ_DEMOD(state, TMGTHFALL);
+	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, 0x20) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, 0x00) < 0)
+		goto err;
+
+	reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+	STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00); /* stop carrier offset search */
+	if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, RTC, 0x80) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, RTCS2, 0x40) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x00) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0) /* set car ofset to 0 */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x65) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0) /* trigger acquisition */
+		goto err;
+	msleep(10);
+
+	for (i = 0; i < 10; i++) {
+		reg = STV090x_READ_DEMOD(state, DSTATUS);
+		if (STV090x_GETFIELD_Px(reg, TMGLOCK_QUALITY_FIELD) >= 2)
+			tmg_cpt++;
+		msleep(1);
+	}
+	if (tmg_cpt >= 3)
+		tmg_lock = 1;
+
+	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, RTC, 0x88) < 0) /* DVB-S1 timing */
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, RTCS2, 0x68) < 0) /* DVB-S2 timing */
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, CARFREQ, freq) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHRISE, tmg_thh) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, TMGTHFALL, tmg_thl) < 0)
+		goto err;
+
+	return	tmg_lock;
+
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_get_coldlock(struct stv090x_state *state, s32 timeout_dmd)
+{
+	struct dvb_frontend *fe = &state->frontend;
+
+	u32 reg;
+	s32 car_step, steps, cur_step, dir, freq, timeout_lock;
+	int lock = 0;
+
+	if (state->srate >= 10000000)
+		timeout_lock = timeout_dmd / 3;
+	else
+		timeout_lock = timeout_dmd / 2;
+
+	lock = stv090x_get_dmdlock(state, timeout_lock); /* cold start wait */
+	if (!lock) {
+		if (state->srate >= 10000000) {
+			if (stv090x_chk_tmg(state)) {
+				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
+					goto err;
+				lock = stv090x_get_dmdlock(state, timeout_dmd);
+			} else {
+				lock = 0;
+			}
+		} else {
+			if (state->srate <= 4000000)
+				car_step = 1000;
+			else if (state->srate <= 7000000)
+				car_step = 2000;
+			else if (state->srate <= 10000000)
+				car_step = 3000;
+			else
+				car_step = 5000;
+
+			steps  = (state->search_range / 1000) / car_step;
+			steps /= 2;
+			steps  = 2 * (steps + 1);
+			if (steps < 0)
+				steps = 2;
+			else if (steps > 12)
+				steps = 12;
+
+			cur_step = 1;
+			dir = 1;
+
+			if (!lock) {
+				freq = state->frequency;
+				state->tuner_bw = stv090x_car_width(state->srate, state->rolloff) + state->srate;
+				while ((cur_step <= steps) && (!lock)) {
+					if (dir > 0)
+						freq += cur_step * car_step;
+					else
+						freq -= cur_step * car_step;
+
+					/* Setup tuner */
+					if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+						goto err;
+
+					if (state->config->tuner_set_frequency) {
+						if (state->config->tuner_set_frequency(fe, freq) < 0)
+							goto err_gateoff;
+					}
+
+					if (state->config->tuner_set_bandwidth) {
+						if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
+							goto err_gateoff;
+					}
+
+					if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+						goto err;
+
+					msleep(50);
+
+					if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+						goto err;
+
+					if (state->config->tuner_get_status) {
+						if (state->config->tuner_get_status(fe, &reg) < 0)
+							goto err_gateoff;
+					}
+
+					if (reg)
+						dprintk(FE_DEBUG, 1, "Tuner phase locked");
+					else
+						dprintk(FE_DEBUG, 1, "Tuner unlocked");
+
+					if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+						goto err;
+
+					STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1c);
+					if (STV090x_WRITE_DEMOD(state, CFRINIT1, 0x00) < 0)
+						goto err;
+					if (STV090x_WRITE_DEMOD(state, CFRINIT0, 0x00) < 0)
+						goto err;
+					if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+						goto err;
+					if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x15) < 0)
+						goto err;
+					lock = stv090x_get_dmdlock(state, (timeout_dmd / 3));
+
+					dir *= -1;
+					cur_step++;
+				}
+			}
+		}
+	}
+
+	return lock;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_get_loop_params(struct stv090x_state *state, s32 *freq_inc, s32 *timeout_sw, s32 *steps)
+{
+	s32 timeout, inc, steps_max, srate, car_max;
+
+	srate = state->srate;
+	car_max = state->search_range / 1000;
+	car_max += car_max / 10;
+	car_max  = 65536 * (car_max / 2);
+	car_max /= (state->internal->mclk / 1000);
+
+	if (car_max > 0x4000)
+		car_max = 0x4000 ; /* maxcarrier should be<= +-1/4 Mclk */
+
+	inc  = srate;
+	inc /= state->internal->mclk / 1000;
+	inc *= 256;
+	inc *= 256;
+	inc /= 1000;
+
+	switch (state->search_mode) {
+	case STV090x_SEARCH_DVBS1:
+	case STV090x_SEARCH_DSS:
+		inc *= 3; /* freq step = 3% of srate */
+		timeout = 20;
+		break;
+
+	case STV090x_SEARCH_DVBS2:
+		inc *= 4;
+		timeout = 25;
+		break;
+
+	case STV090x_SEARCH_AUTO:
+	default:
+		inc *= 3;
+		timeout = 25;
+		break;
+	}
+	inc /= 100;
+	if ((inc > car_max) || (inc < 0))
+		inc = car_max / 2; /* increment <= 1/8 Mclk */
+
+	timeout *= 27500; /* 27.5 Msps reference */
+	if (srate > 0)
+		timeout /= (srate / 1000);
+
+	if ((timeout > 100) || (timeout < 0))
+		timeout = 100;
+
+	steps_max = (car_max / inc) + 1; /* min steps = 3 */
+	if ((steps_max > 100) || (steps_max < 0)) {
+		steps_max = 100; /* max steps <= 100 */
+		inc = car_max / steps_max;
+	}
+	*freq_inc = inc;
+	*timeout_sw = timeout;
+	*steps = steps_max;
+
+	return 0;
+}
+
+static int stv090x_chk_signal(struct stv090x_state *state)
+{
+	s32 offst_car, agc2, car_max;
+	int no_signal;
+
+	offst_car  = STV090x_READ_DEMOD(state, CFR2) << 8;
+	offst_car |= STV090x_READ_DEMOD(state, CFR1);
+	offst_car = comp2(offst_car, 16);
+
+	agc2  = STV090x_READ_DEMOD(state, AGC2I1) << 8;
+	agc2 |= STV090x_READ_DEMOD(state, AGC2I0);
+	car_max = state->search_range / 1000;
+
+	car_max += (car_max / 10); /* 10% margin */
+	car_max  = (65536 * car_max / 2);
+	car_max /= state->internal->mclk / 1000;
+
+	if (car_max > 0x4000)
+		car_max = 0x4000;
+
+	if ((agc2 > 0x2000) || (offst_car > 2 * car_max) || (offst_car < -2 * car_max)) {
+		no_signal = 1;
+		dprintk(FE_DEBUG, 1, "No Signal");
+	} else {
+		no_signal = 0;
+		dprintk(FE_DEBUG, 1, "Found Signal");
+	}
+
+	return no_signal;
+}
+
+static int stv090x_search_car_loop(struct stv090x_state *state, s32 inc, s32 timeout, int zigzag, s32 steps_max)
+{
+	int no_signal, lock = 0;
+	s32 cpt_step = 0, offst_freq, car_max;
+	u32 reg;
+
+	car_max  = state->search_range / 1000;
+	car_max += (car_max / 10);
+	car_max  = (65536 * car_max / 2);
+	car_max /= (state->internal->mclk / 1000);
+	if (car_max > 0x4000)
+		car_max = 0x4000;
+
+	if (zigzag)
+		offst_freq = 0;
+	else
+		offst_freq = -car_max + inc;
+
+	do {
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1c) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT1, ((offst_freq / 256) & 0xff)) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT0, offst_freq & 0xff) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
+			goto err;
+
+		reg = STV090x_READ_DEMOD(state, PDELCTRL1);
+		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x1); /* stop DVB-S2 packet delin */
+		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
+			goto err;
+
+		if (zigzag) {
+			if (offst_freq >= 0)
+				offst_freq = -offst_freq - 2 * inc;
+			else
+				offst_freq = -offst_freq;
+		} else {
+			offst_freq += 2 * inc;
+		}
+
+		cpt_step++;
+
+		lock = stv090x_get_dmdlock(state, timeout);
+		no_signal = stv090x_chk_signal(state);
+
+	} while ((!lock) &&
+		 (!no_signal) &&
+		  ((offst_freq - inc) < car_max) &&
+		  ((offst_freq + inc) > -car_max) &&
+		  (cpt_step < steps_max));
+
+	reg = STV090x_READ_DEMOD(state, PDELCTRL1);
+	STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
+			goto err;
+
+	return lock;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_sw_algo(struct stv090x_state *state)
+{
+	int no_signal, zigzag, lock = 0;
+	u32 reg;
+
+	s32 dvbs2_fly_wheel;
+	s32 inc, timeout_step, trials, steps_max;
+
+	/* get params */
+	stv090x_get_loop_params(state, &inc, &timeout_step, &steps_max);
+
+	switch (state->search_mode) {
+	case STV090x_SEARCH_DVBS1:
+	case STV090x_SEARCH_DSS:
+		/* accelerate the frequency detector */
+		if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x3B) < 0)
+				goto err;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x49) < 0)
+			goto err;
+		zigzag = 0;
+		break;
+
+	case STV090x_SEARCH_DVBS2:
+		if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
+				goto err;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x89) < 0)
+			goto err;
+		zigzag = 1;
+		break;
+
+	case STV090x_SEARCH_AUTO:
+	default:
+		/* accelerate the frequency detector */
+		if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x3b) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
+				goto err;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0xc9) < 0)
+			goto err;
+		zigzag = 0;
+		break;
+	}
+
+	trials = 0;
+	do {
+		lock = stv090x_search_car_loop(state, inc, timeout_step, zigzag, steps_max);
+		no_signal = stv090x_chk_signal(state);
+		trials++;
+
+		/*run the SW search 2 times maximum*/
+		if (lock || no_signal || (trials == 2)) {
+			/*Check if the demod is not losing lock in DVBS2*/
+			if (state->internal->dev_ver >= 0x20) {
+				if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x9e) < 0)
+					goto err;
+			}
+
+			reg = STV090x_READ_DEMOD(state, DMDSTATE);
+			if ((lock) && (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == STV090x_DVBS2)) {
+				/*Check if the demod is not losing lock in DVBS2*/
+				msleep(timeout_step);
+				reg = STV090x_READ_DEMOD(state, DMDFLYW);
+				dvbs2_fly_wheel = STV090x_GETFIELD_Px(reg, FLYWHEEL_CPT_FIELD);
+				if (dvbs2_fly_wheel < 0xd) {	 /*if correct frames is decrementing */
+					msleep(timeout_step);
+					reg = STV090x_READ_DEMOD(state, DMDFLYW);
+					dvbs2_fly_wheel = STV090x_GETFIELD_Px(reg, FLYWHEEL_CPT_FIELD);
+				}
+				if (dvbs2_fly_wheel < 0xd) {
+					/*FALSE lock, The demod is losing lock */
+					lock = 0;
+					if (trials < 2) {
+						if (state->internal->dev_ver >= 0x20) {
+							if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x79) < 0)
+								goto err;
+						}
+
+						if (STV090x_WRITE_DEMOD(state, DMDCFGMD, 0x89) < 0)
+							goto err;
+					}
+				}
+			}
+		}
+	} while ((!lock) && (trials < 2) && (!no_signal));
+
+	return lock;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static enum stv090x_delsys stv090x_get_std(struct stv090x_state *state)
+{
+	u32 reg;
+	enum stv090x_delsys delsys;
+
+	reg = STV090x_READ_DEMOD(state, DMDSTATE);
+	if (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == 2)
+		delsys = STV090x_DVBS2;
+	else if (STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD) == 3) {
+		reg = STV090x_READ_DEMOD(state, FECM);
+		if (STV090x_GETFIELD_Px(reg, DSS_DVB_FIELD) == 1)
+			delsys = STV090x_DSS;
+		else
+			delsys = STV090x_DVBS1;
+	} else {
+		delsys = STV090x_ERROR;
+	}
+
+	return delsys;
+}
+
+/* in Hz */
+static s32 stv090x_get_car_freq(struct stv090x_state *state, u32 mclk)
+{
+	s32 derot, int_1, int_2, tmp_1, tmp_2;
+
+	derot  = STV090x_READ_DEMOD(state, CFR2) << 16;
+	derot |= STV090x_READ_DEMOD(state, CFR1) <<  8;
+	derot |= STV090x_READ_DEMOD(state, CFR0);
+
+	derot = comp2(derot, 24);
+	int_1 = mclk >> 12;
+	int_2 = derot >> 12;
+
+	/* carrier_frequency = MasterClock * Reg / 2^24 */
+	tmp_1 = mclk % 0x1000;
+	tmp_2 = derot % 0x1000;
+
+	derot = (int_1 * int_2) +
+		((int_1 * tmp_2) >> 12) +
+		((int_2 * tmp_1) >> 12);
+
+	return derot;
+}
+
+static int stv090x_get_viterbi(struct stv090x_state *state)
+{
+	u32 reg, rate;
+
+	reg = STV090x_READ_DEMOD(state, VITCURPUN);
+	rate = STV090x_GETFIELD_Px(reg, VIT_CURPUN_FIELD);
+
+	switch (rate) {
+	case 13:
+		state->fec = STV090x_PR12;
+		break;
+
+	case 18:
+		state->fec = STV090x_PR23;
+		break;
+
+	case 21:
+		state->fec = STV090x_PR34;
+		break;
+
+	case 24:
+		state->fec = STV090x_PR56;
+		break;
+
+	case 25:
+		state->fec = STV090x_PR67;
+		break;
+
+	case 26:
+		state->fec = STV090x_PR78;
+		break;
+
+	default:
+		state->fec = STV090x_PRERR;
+		break;
+	}
+
+	return 0;
+}
+
+static enum stv090x_signal_state stv090x_get_sig_params(struct stv090x_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+
+	u8 tmg;
+	u32 reg;
+	s32 i = 0, offst_freq;
+
+	msleep(5);
+
+	if (state->algo == STV090x_BLIND_SEARCH) {
+		tmg = STV090x_READ_DEMOD(state, TMGREG2);
+		STV090x_WRITE_DEMOD(state, SFRSTEP, 0x5c);
+		while ((i <= 50) && (tmg != 0) && (tmg != 0xff)) {
+			tmg = STV090x_READ_DEMOD(state, TMGREG2);
+			msleep(5);
+			i += 5;
+		}
+	}
+	state->delsys = stv090x_get_std(state);
+
+	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+		goto err;
+
+	if (state->config->tuner_get_frequency) {
+		if (state->config->tuner_get_frequency(fe, &state->frequency) < 0)
+			goto err_gateoff;
+	}
+
+	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+		goto err;
+
+	offst_freq = stv090x_get_car_freq(state, state->internal->mclk) / 1000;
+	state->frequency += offst_freq;
+
+	if (stv090x_get_viterbi(state) < 0)
+		goto err;
+
+	reg = STV090x_READ_DEMOD(state, DMDMODCOD);
+	state->modcod = STV090x_GETFIELD_Px(reg, DEMOD_MODCOD_FIELD);
+	state->pilots = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) & 0x01;
+	state->frame_len = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) >> 1;
+	reg = STV090x_READ_DEMOD(state, TMGOBS);
+	state->rolloff = STV090x_GETFIELD_Px(reg, ROLLOFF_STATUS_FIELD);
+	reg = STV090x_READ_DEMOD(state, FECM);
+	state->inversion = STV090x_GETFIELD_Px(reg, IQINV_FIELD);
+
+	if ((state->algo == STV090x_BLIND_SEARCH) || (state->srate < 10000000)) {
+
+		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+			goto err;
+
+		if (state->config->tuner_get_frequency) {
+			if (state->config->tuner_get_frequency(fe, &state->frequency) < 0)
+				goto err_gateoff;
+		}
+
+		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+			goto err;
+
+		if (abs(offst_freq) <= ((state->search_range / 2000) + 500))
+			return STV090x_RANGEOK;
+		else if (abs(offst_freq) <= (stv090x_car_width(state->srate, state->rolloff) / 2000))
+			return STV090x_RANGEOK;
+		else
+			return STV090x_OUTOFRANGE; /* Out of Range */
+	} else {
+		if (abs(offst_freq) <= ((state->search_range / 2000) + 500))
+			return STV090x_RANGEOK;
+		else
+			return STV090x_OUTOFRANGE;
+	}
+
+	return STV090x_OUTOFRANGE;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static u32 stv090x_get_tmgoffst(struct stv090x_state *state, u32 srate)
+{
+	s32 offst_tmg;
+
+	offst_tmg  = STV090x_READ_DEMOD(state, TMGREG2) << 16;
+	offst_tmg |= STV090x_READ_DEMOD(state, TMGREG1) <<  8;
+	offst_tmg |= STV090x_READ_DEMOD(state, TMGREG0);
+
+	offst_tmg = comp2(offst_tmg, 24); /* 2's complement */
+	if (!offst_tmg)
+		offst_tmg = 1;
+
+	offst_tmg  = ((s32) srate * 10) / ((s32) 0x1000000 / offst_tmg);
+	offst_tmg /= 320;
+
+	return offst_tmg;
+}
+
+static u8 stv090x_optimize_carloop(struct stv090x_state *state, enum stv090x_modcod modcod, s32 pilots)
+{
+	u8 aclc = 0x29;
+	s32 i;
+	struct stv090x_long_frame_crloop *car_loop, *car_loop_qpsk_low, *car_loop_apsk_low;
+
+	if (state->internal->dev_ver == 0x20) {
+		car_loop		= stv090x_s2_crl_cut20;
+		car_loop_qpsk_low	= stv090x_s2_lowqpsk_crl_cut20;
+		car_loop_apsk_low	= stv090x_s2_apsk_crl_cut20;
+	} else {
+		/* >= Cut 3 */
+		car_loop		= stv090x_s2_crl_cut30;
+		car_loop_qpsk_low	= stv090x_s2_lowqpsk_crl_cut30;
+		car_loop_apsk_low	= stv090x_s2_apsk_crl_cut30;
+	}
+
+	if (modcod < STV090x_QPSK_12) {
+		i = 0;
+		while ((i < 3) && (modcod != car_loop_qpsk_low[i].modcod))
+			i++;
+
+		if (i >= 3)
+			i = 2;
+
+	} else {
+		i = 0;
+		while ((i < 14) && (modcod != car_loop[i].modcod))
+			i++;
+
+		if (i >= 14) {
+			i = 0;
+			while ((i < 11) && (modcod != car_loop_apsk_low[i].modcod))
+				i++;
+
+			if (i >= 11)
+				i = 10;
+		}
+	}
+
+	if (modcod <= STV090x_QPSK_25) {
+		if (pilots) {
+			if (state->srate <= 3000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_on_2;
+			else if (state->srate <= 7000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_on_5;
+			else if (state->srate <= 15000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_on_10;
+			else if (state->srate <= 25000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_on_20;
+			else
+				aclc = car_loop_qpsk_low[i].crl_pilots_on_30;
+		} else {
+			if (state->srate <= 3000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_off_2;
+			else if (state->srate <= 7000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_off_5;
+			else if (state->srate <= 15000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_off_10;
+			else if (state->srate <= 25000000)
+				aclc = car_loop_qpsk_low[i].crl_pilots_off_20;
+			else
+				aclc = car_loop_qpsk_low[i].crl_pilots_off_30;
+		}
+
+	} else if (modcod <= STV090x_8PSK_910) {
+		if (pilots) {
+			if (state->srate <= 3000000)
+				aclc = car_loop[i].crl_pilots_on_2;
+			else if (state->srate <= 7000000)
+				aclc = car_loop[i].crl_pilots_on_5;
+			else if (state->srate <= 15000000)
+				aclc = car_loop[i].crl_pilots_on_10;
+			else if (state->srate <= 25000000)
+				aclc = car_loop[i].crl_pilots_on_20;
+			else
+				aclc = car_loop[i].crl_pilots_on_30;
+		} else {
+			if (state->srate <= 3000000)
+				aclc = car_loop[i].crl_pilots_off_2;
+			else if (state->srate <= 7000000)
+				aclc = car_loop[i].crl_pilots_off_5;
+			else if (state->srate <= 15000000)
+				aclc = car_loop[i].crl_pilots_off_10;
+			else if (state->srate <= 25000000)
+				aclc = car_loop[i].crl_pilots_off_20;
+			else
+				aclc = car_loop[i].crl_pilots_off_30;
+		}
+	} else { /* 16APSK and 32APSK */
+		if (state->srate <= 3000000)
+			aclc = car_loop_apsk_low[i].crl_pilots_on_2;
+		else if (state->srate <= 7000000)
+			aclc = car_loop_apsk_low[i].crl_pilots_on_5;
+		else if (state->srate <= 15000000)
+			aclc = car_loop_apsk_low[i].crl_pilots_on_10;
+		else if (state->srate <= 25000000)
+			aclc = car_loop_apsk_low[i].crl_pilots_on_20;
+		else
+			aclc = car_loop_apsk_low[i].crl_pilots_on_30;
+	}
+
+	return aclc;
+}
+
+static u8 stv090x_optimize_carloop_short(struct stv090x_state *state)
+{
+	struct stv090x_short_frame_crloop *short_crl = NULL;
+	s32 index = 0;
+	u8 aclc = 0x0b;
+
+	switch (state->modulation) {
+	case STV090x_QPSK:
+	default:
+		index = 0;
+		break;
+	case STV090x_8PSK:
+		index = 1;
+		break;
+	case STV090x_16APSK:
+		index = 2;
+		break;
+	case STV090x_32APSK:
+		index = 3;
+		break;
+	}
+
+	if (state->internal->dev_ver >= 0x30) {
+		/* Cut 3.0 and up */
+		short_crl = stv090x_s2_short_crl_cut30;
+	} else {
+		/* Cut 2.0 and up: we don't support cuts older than 2.0 */
+		short_crl = stv090x_s2_short_crl_cut20;
+	}
+
+	if (state->srate <= 3000000)
+		aclc = short_crl[index].crl_2;
+	else if (state->srate <= 7000000)
+		aclc = short_crl[index].crl_5;
+	else if (state->srate <= 15000000)
+		aclc = short_crl[index].crl_10;
+	else if (state->srate <= 25000000)
+		aclc = short_crl[index].crl_20;
+	else
+		aclc = short_crl[index].crl_30;
+
+	return aclc;
+}
+
+static int stv090x_optimize_track(struct stv090x_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+
+	enum stv090x_rolloff rolloff;
+	enum stv090x_modcod modcod;
+
+	s32 srate, pilots, aclc, f_1, f_0, i = 0, blind_tune = 0;
+	u32 reg;
+
+	srate  = stv090x_get_srate(state, state->internal->mclk);
+	srate += stv090x_get_tmgoffst(state, srate);
+
+	switch (state->delsys) {
+	case STV090x_DVBS1:
+	case STV090x_DSS:
+		if (state->search_mode == STV090x_SEARCH_AUTO) {
+			reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+			STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
+			STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 0);
+			if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+				goto err;
+		}
+		reg = STV090x_READ_DEMOD(state, DEMOD);
+		STV090x_SETFIELD_Px(reg, ROLLOFF_CONTROL_FIELD, state->rolloff);
+		STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 0x01);
+		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
+			goto err;
+
+		if (state->internal->dev_ver >= 0x30) {
+			if (stv090x_get_viterbi(state) < 0)
+				goto err;
+
+			if (state->fec == STV090x_PR12) {
+				if (STV090x_WRITE_DEMOD(state, GAUSSR0, 0x98) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, CCIR0, 0x18) < 0)
+					goto err;
+			} else {
+				if (STV090x_WRITE_DEMOD(state, GAUSSR0, 0x18) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, CCIR0, 0x18) < 0)
+					goto err;
+			}
+		}
+
+		if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x75) < 0)
+			goto err;
+		break;
+
+	case STV090x_DVBS2:
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 0);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+		if (state->internal->dev_ver >= 0x30) {
+			if (STV090x_WRITE_DEMOD(state, ACLC, 0) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, BCLC, 0) < 0)
+				goto err;
+		}
+		if (state->frame_len == STV090x_LONG_FRAME) {
+			reg = STV090x_READ_DEMOD(state, DMDMODCOD);
+			modcod = STV090x_GETFIELD_Px(reg, DEMOD_MODCOD_FIELD);
+			pilots = STV090x_GETFIELD_Px(reg, DEMOD_TYPE_FIELD) & 0x01;
+			aclc = stv090x_optimize_carloop(state, modcod, pilots);
+			if (modcod <= STV090x_QPSK_910) {
+				STV090x_WRITE_DEMOD(state, ACLC2S2Q, aclc);
+			} else if (modcod <= STV090x_8PSK_910) {
+				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, ACLC2S28, aclc) < 0)
+					goto err;
+			}
+			if ((state->demod_mode == STV090x_SINGLE) && (modcod > STV090x_8PSK_910)) {
+				if (modcod <= STV090x_16APSK_910) {
+					if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+						goto err;
+					if (STV090x_WRITE_DEMOD(state, ACLC2S216A, aclc) < 0)
+						goto err;
+				} else {
+					if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+						goto err;
+					if (STV090x_WRITE_DEMOD(state, ACLC2S232A, aclc) < 0)
+						goto err;
+				}
+			}
+		} else {
+			/*Carrier loop setting for short frame*/
+			aclc = stv090x_optimize_carloop_short(state);
+			if (state->modulation == STV090x_QPSK) {
+				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, aclc) < 0)
+					goto err;
+			} else if (state->modulation == STV090x_8PSK) {
+				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, ACLC2S28, aclc) < 0)
+					goto err;
+			} else if (state->modulation == STV090x_16APSK) {
+				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, ACLC2S216A, aclc) < 0)
+					goto err;
+			} else if (state->modulation == STV090x_32APSK)  {
+				if (STV090x_WRITE_DEMOD(state, ACLC2S2Q, 0x2a) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, ACLC2S232A, aclc) < 0)
+					goto err;
+			}
+		}
+
+		STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x67); /* PER */
+		break;
+
+	case STV090x_ERROR:
+	default:
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, DVBS1_ENABLE_FIELD, 1);
+		STV090x_SETFIELD_Px(reg, DVBS2_ENABLE_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+		break;
+	}
+
+	f_1 = STV090x_READ_DEMOD(state, CFR2);
+	f_0 = STV090x_READ_DEMOD(state, CFR1);
+	reg = STV090x_READ_DEMOD(state, TMGOBS);
+	rolloff = STV090x_GETFIELD_Px(reg, ROLLOFF_STATUS_FIELD);
+
+	if (state->algo == STV090x_BLIND_SEARCH) {
+		STV090x_WRITE_DEMOD(state, SFRSTEP, 0x00);
+		reg = STV090x_READ_DEMOD(state, DMDCFGMD);
+		STV090x_SETFIELD_Px(reg, SCAN_ENABLE_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, CFR_AUTOSCAN_FIELD, 0x00);
+		if (STV090x_WRITE_DEMOD(state, DMDCFGMD, reg) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0)
+			goto err;
+
+		if (stv090x_set_srate(state, srate) < 0)
+			goto err;
+		blind_tune = 1;
+
+		if (stv090x_dvbs_track_crl(state) < 0)
+			goto err;
+	}
+
+	if (state->internal->dev_ver >= 0x20) {
+		if ((state->search_mode == STV090x_SEARCH_DVBS1)	||
+		    (state->search_mode == STV090x_SEARCH_DSS)		||
+		    (state->search_mode == STV090x_SEARCH_AUTO)) {
+
+			if (STV090x_WRITE_DEMOD(state, VAVSRVIT, 0x0a) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, VITSCALE, 0x00) < 0)
+				goto err;
+		}
+	}
+
+	if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
+		goto err;
+
+	/* AUTO tracking MODE */
+	if (STV090x_WRITE_DEMOD(state, SFRUP1, 0x80) < 0)
+		goto err;
+	/* AUTO tracking MODE */
+	if (STV090x_WRITE_DEMOD(state, SFRLOW1, 0x80) < 0)
+		goto err;
+
+	if ((state->internal->dev_ver >= 0x20) || (blind_tune == 1) ||
+	    (state->srate < 10000000)) {
+		/* update initial carrier freq with the found freq offset */
+		if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
+			goto err;
+		state->tuner_bw = stv090x_car_width(srate, state->rolloff) + 10000000;
+
+		if ((state->internal->dev_ver >= 0x20) || (blind_tune == 1)) {
+
+			if (state->algo != STV090x_WARM_SEARCH) {
+
+				if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+					goto err;
+
+				if (state->config->tuner_set_bandwidth) {
+					if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
+						goto err_gateoff;
+				}
+
+				if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+					goto err;
+
+			}
+		}
+		if ((state->algo == STV090x_BLIND_SEARCH) || (state->srate < 10000000))
+			msleep(50); /* blind search: wait 50ms for SR stabilization */
+		else
+			msleep(5);
+
+		stv090x_get_lock_tmg(state);
+
+		if (!(stv090x_get_dmdlock(state, (state->DemodTimeout / 2)))) {
+			if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
+				goto err;
+
+			i = 0;
+
+			while ((!(stv090x_get_dmdlock(state, (state->DemodTimeout / 2)))) && (i <= 2)) {
+
+				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x1f) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, CFRINIT1, f_1) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, CFRINIT0, f_0) < 0)
+					goto err;
+				if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x18) < 0)
+					goto err;
+				i++;
+			}
+		}
+
+	}
+
+	if (state->internal->dev_ver >= 0x20) {
+		if (STV090x_WRITE_DEMOD(state, CARFREQ, 0x49) < 0)
+			goto err;
+	}
+
+	if ((state->delsys == STV090x_DVBS1) || (state->delsys == STV090x_DSS))
+		stv090x_set_vit_thtracq(state);
+
+	return 0;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_get_feclock(struct stv090x_state *state, s32 timeout)
+{
+	s32 timer = 0, lock = 0, stat;
+	u32 reg;
+
+	while ((timer < timeout) && (!lock)) {
+		reg = STV090x_READ_DEMOD(state, DMDSTATE);
+		stat = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
+
+		switch (stat) {
+		case 0: /* searching */
+		case 1: /* first PLH detected */
+		default:
+			lock = 0;
+			break;
+
+		case 2: /* DVB-S2 mode */
+			reg = STV090x_READ_DEMOD(state, PDELSTATUS1);
+			lock = STV090x_GETFIELD_Px(reg, PKTDELIN_LOCK_FIELD);
+			break;
+
+		case 3: /* DVB-S1/legacy mode */
+			reg = STV090x_READ_DEMOD(state, VSTATUSVIT);
+			lock = STV090x_GETFIELD_Px(reg, LOCKEDVIT_FIELD);
+			break;
+		}
+		if (!lock) {
+			msleep(10);
+			timer += 10;
+		}
+	}
+	return lock;
+}
+
+static int stv090x_get_lock(struct stv090x_state *state, s32 timeout_dmd, s32 timeout_fec)
+{
+	u32 reg;
+	s32 timer = 0;
+	int lock;
+
+	lock = stv090x_get_dmdlock(state, timeout_dmd);
+	if (lock)
+		lock = stv090x_get_feclock(state, timeout_fec);
+
+	if (lock) {
+		lock = 0;
+
+		while ((timer < timeout_fec) && (!lock)) {
+			reg = STV090x_READ_DEMOD(state, TSSTATUS);
+			lock = STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD);
+			msleep(1);
+			timer++;
+		}
+	}
+
+	return lock;
+}
+
+static int stv090x_set_s2rolloff(struct stv090x_state *state)
+{
+	u32 reg;
+
+	if (state->internal->dev_ver <= 0x20) {
+		/* rolloff to auto mode if DVBS2 */
+		reg = STV090x_READ_DEMOD(state, DEMOD);
+		STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 0x00);
+		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
+			goto err;
+	} else {
+		/* DVB-S2 rolloff to auto mode if DVBS2 */
+		reg = STV090x_READ_DEMOD(state, DEMOD);
+		STV090x_SETFIELD_Px(reg, MANUAL_S2ROLLOFF_FIELD, 0x00);
+		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
+			goto err;
+	}
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+
+static enum stv090x_signal_state stv090x_algo(struct stv090x_state *state)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	enum stv090x_signal_state signal_state = STV090x_NOCARRIER;
+	u32 reg;
+	s32 agc1_power, power_iq = 0, i;
+	int lock = 0, low_sr = 0, no_signal = 0;
+
+	reg = STV090x_READ_DEMOD(state, TSCFGH);
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 1); /* Stop path 1 stream merger */
+	if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
+		goto err;
+
+	if (STV090x_WRITE_DEMOD(state, DMDISTATE, 0x5c) < 0) /* Demod stop */
+		goto err;
+
+	if (state->internal->dev_ver >= 0x20) {
+		if (state->srate > 5000000) {
+			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x9e) < 0)
+				goto err;
+		} else {
+			if (STV090x_WRITE_DEMOD(state, CORRELABS, 0x82) < 0)
+				goto err;
+		}
+	}
+
+	stv090x_get_lock_tmg(state);
+
+	if (state->algo == STV090x_BLIND_SEARCH) {
+		state->tuner_bw = 2 * 36000000; /* wide bw for unknown srate */
+		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc0) < 0) /* wider srate scan */
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x70) < 0)
+			goto err;
+		if (stv090x_set_srate(state, 1000000) < 0) /* initial srate = 1Msps */
+			goto err;
+	} else {
+		/* known srate */
+		if (STV090x_WRITE_DEMOD(state, DMDTOM, 0x20) < 0)
+			goto err;
+		if (STV090x_WRITE_DEMOD(state, TMGCFG, 0xd2) < 0)
+			goto err;
+
+		if (state->srate < 2000000) {
+			/* SR < 2MSPS */
+			if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x63) < 0)
+				goto err;
+		} else {
+			/* SR >= 2Msps */
+			if (STV090x_WRITE_DEMOD(state, CORRELMANT, 0x70) < 0)
+				goto err;
+		}
+
+		if (STV090x_WRITE_DEMOD(state, AGC2REF, 0x38) < 0)
+			goto err;
+
+		if (state->internal->dev_ver >= 0x20) {
+			if (STV090x_WRITE_DEMOD(state, KREFTMG, 0x5a) < 0)
+				goto err;
+			if (state->algo == STV090x_COLD_SEARCH)
+				state->tuner_bw = (15 * (stv090x_car_width(state->srate, state->rolloff) + 10000000)) / 10;
+			else if (state->algo == STV090x_WARM_SEARCH)
+				state->tuner_bw = stv090x_car_width(state->srate, state->rolloff) + 10000000;
+		}
+
+		/* if cold start or warm  (Symbolrate is known)
+		 * use a Narrow symbol rate scan range
+		 */
+		if (STV090x_WRITE_DEMOD(state, TMGCFG2, 0xc1) < 0) /* narrow srate scan */
+			goto err;
+
+		if (stv090x_set_srate(state, state->srate) < 0)
+			goto err;
+
+		if (stv090x_set_max_srate(state, state->internal->mclk,
+					  state->srate) < 0)
+			goto err;
+		if (stv090x_set_min_srate(state, state->internal->mclk,
+					  state->srate) < 0)
+			goto err;
+
+		if (state->srate >= 10000000)
+			low_sr = 0;
+		else
+			low_sr = 1;
+	}
+
+	/* Setup tuner */
+	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+		goto err;
+
+	if (state->config->tuner_set_bbgain) {
+		reg = state->config->tuner_bbgain;
+		if (reg == 0)
+			reg = 10; /* default: 10dB */
+		if (state->config->tuner_set_bbgain(fe, reg) < 0)
+			goto err_gateoff;
+	}
+
+	if (state->config->tuner_set_frequency) {
+		if (state->config->tuner_set_frequency(fe, state->frequency) < 0)
+			goto err_gateoff;
+	}
+
+	if (state->config->tuner_set_bandwidth) {
+		if (state->config->tuner_set_bandwidth(fe, state->tuner_bw) < 0)
+			goto err_gateoff;
+	}
+
+	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+		goto err;
+
+	msleep(50);
+
+	if (state->config->tuner_get_status) {
+		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+			goto err;
+		if (state->config->tuner_get_status(fe, &reg) < 0)
+			goto err_gateoff;
+		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+			goto err;
+
+		if (reg)
+			dprintk(FE_DEBUG, 1, "Tuner phase locked");
+		else {
+			dprintk(FE_DEBUG, 1, "Tuner unlocked");
+			return STV090x_NOCARRIER;
+		}
+	}
+
+	msleep(10);
+	agc1_power = MAKEWORD16(STV090x_READ_DEMOD(state, AGCIQIN1),
+				STV090x_READ_DEMOD(state, AGCIQIN0));
+
+	if (agc1_power == 0) {
+		/* If AGC1 integrator value is 0
+		 * then read POWERI, POWERQ
+		 */
+		for (i = 0; i < 5; i++) {
+			power_iq += (STV090x_READ_DEMOD(state, POWERI) +
+				     STV090x_READ_DEMOD(state, POWERQ)) >> 1;
+		}
+		power_iq /= 5;
+	}
+
+	if ((agc1_power == 0) && (power_iq < STV090x_IQPOWER_THRESHOLD)) {
+		dprintk(FE_ERROR, 1, "No Signal: POWER_IQ=0x%02x", power_iq);
+		lock = 0;
+		signal_state = STV090x_NOAGC1;
+	} else {
+		reg = STV090x_READ_DEMOD(state, DEMOD);
+		STV090x_SETFIELD_Px(reg, SPECINV_CONTROL_FIELD, state->inversion);
+
+		if (state->internal->dev_ver <= 0x20) {
+			/* rolloff to auto mode if DVBS2 */
+			STV090x_SETFIELD_Px(reg, MANUAL_SXROLLOFF_FIELD, 1);
+		} else {
+			/* DVB-S2 rolloff to auto mode if DVBS2 */
+			STV090x_SETFIELD_Px(reg, MANUAL_S2ROLLOFF_FIELD, 1);
+		}
+		if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
+			goto err;
+
+		if (stv090x_delivery_search(state) < 0)
+			goto err;
+
+		if (state->algo != STV090x_BLIND_SEARCH) {
+			if (stv090x_start_search(state) < 0)
+				goto err;
+		}
+	}
+
+	if (signal_state == STV090x_NOAGC1)
+		return signal_state;
+
+	if (state->algo == STV090x_BLIND_SEARCH)
+		lock = stv090x_blind_search(state);
+
+	else if (state->algo == STV090x_COLD_SEARCH)
+		lock = stv090x_get_coldlock(state, state->DemodTimeout);
+
+	else if (state->algo == STV090x_WARM_SEARCH)
+		lock = stv090x_get_dmdlock(state, state->DemodTimeout);
+
+	if ((!lock) && (state->algo == STV090x_COLD_SEARCH)) {
+		if (!low_sr) {
+			if (stv090x_chk_tmg(state))
+				lock = stv090x_sw_algo(state);
+		}
+	}
+
+	if (lock)
+		signal_state = stv090x_get_sig_params(state);
+
+	if ((lock) && (signal_state == STV090x_RANGEOK)) { /* signal within Range */
+		stv090x_optimize_track(state);
+
+		if (state->internal->dev_ver >= 0x20) {
+			/* >= Cut 2.0 :release TS reset after
+			 * demod lock and optimized Tracking
+			 */
+			reg = STV090x_READ_DEMOD(state, TSCFGH);
+			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0); /* release merger reset */
+			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
+				goto err;
+
+			msleep(3);
+
+			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 1); /* merger reset */
+			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
+				goto err;
+
+			STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0); /* release merger reset */
+			if (STV090x_WRITE_DEMOD(state, TSCFGH, reg) < 0)
+				goto err;
+		}
+
+		lock = stv090x_get_lock(state, state->FecTimeout,
+				state->FecTimeout);
+		if (lock) {
+			if (state->delsys == STV090x_DVBS2) {
+				stv090x_set_s2rolloff(state);
+
+				reg = STV090x_READ_DEMOD(state, PDELCTRL2);
+				STV090x_SETFIELD_Px(reg, RESET_UPKO_COUNT, 1);
+				if (STV090x_WRITE_DEMOD(state, PDELCTRL2, reg) < 0)
+					goto err;
+				/* Reset DVBS2 packet delinator error counter */
+				reg = STV090x_READ_DEMOD(state, PDELCTRL2);
+				STV090x_SETFIELD_Px(reg, RESET_UPKO_COUNT, 0);
+				if (STV090x_WRITE_DEMOD(state, PDELCTRL2, reg) < 0)
+					goto err;
+
+				if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x67) < 0) /* PER */
+					goto err;
+			} else {
+				if (STV090x_WRITE_DEMOD(state, ERRCTRL1, 0x75) < 0)
+					goto err;
+			}
+			/* Reset the Total packet counter */
+			if (STV090x_WRITE_DEMOD(state, FBERCPT4, 0x00) < 0)
+				goto err;
+			/* Reset the packet Error counter2 */
+			if (STV090x_WRITE_DEMOD(state, ERRCTRL2, 0xc1) < 0)
+				goto err;
+		} else {
+			signal_state = STV090x_NODATA;
+			no_signal = stv090x_chk_signal(state);
+		}
+	}
+	return signal_state;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static enum dvbfe_search stv090x_search(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *props = &fe->dtv_property_cache;
+
+	if (props->frequency == 0)
+		return DVBFE_ALGO_SEARCH_INVALID;
+
+	state->delsys = props->delivery_system;
+	state->frequency = props->frequency;
+	state->srate = props->symbol_rate;
+	state->search_mode = STV090x_SEARCH_AUTO;
+	state->algo = STV090x_COLD_SEARCH;
+	state->fec = STV090x_PRERR;
+	if (state->srate > 10000000) {
+		dprintk(FE_DEBUG, 1, "Search range: 10 MHz");
+		state->search_range = 10000000;
+	} else {
+		dprintk(FE_DEBUG, 1, "Search range: 5 MHz");
+		state->search_range = 5000000;
+	}
+
+	if (stv090x_algo(state) == STV090x_RANGEOK) {
+		dprintk(FE_DEBUG, 1, "Search success!");
+		return DVBFE_ALGO_SEARCH_SUCCESS;
+	} else {
+		dprintk(FE_DEBUG, 1, "Search failed!");
+		return DVBFE_ALGO_SEARCH_FAILED;
+	}
+
+	return DVBFE_ALGO_SEARCH_ERROR;
+}
+
+static int stv090x_read_status(struct dvb_frontend *fe, enum fe_status *status)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, dstatus;
+	u8 search_state;
+
+	*status = 0;
+
+	dstatus = STV090x_READ_DEMOD(state, DSTATUS);
+	if (STV090x_GETFIELD_Px(dstatus, CAR_LOCK_FIELD))
+		*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;
+
+	reg = STV090x_READ_DEMOD(state, DMDSTATE);
+	search_state = STV090x_GETFIELD_Px(reg, HEADER_MODE_FIELD);
+
+	switch (search_state) {
+	case 0: /* searching */
+	case 1: /* first PLH detected */
+	default:
+		dprintk(FE_DEBUG, 1, "Status: Unlocked (Searching ..)");
+		break;
+
+	case 2: /* DVB-S2 mode */
+		dprintk(FE_DEBUG, 1, "Delivery system: DVB-S2");
+		if (STV090x_GETFIELD_Px(dstatus, LOCK_DEFINITIF_FIELD)) {
+			reg = STV090x_READ_DEMOD(state, PDELSTATUS1);
+			if (STV090x_GETFIELD_Px(reg, PKTDELIN_LOCK_FIELD)) {
+				*status |= FE_HAS_VITERBI;
+				reg = STV090x_READ_DEMOD(state, TSSTATUS);
+				if (STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD))
+					*status |= FE_HAS_SYNC | FE_HAS_LOCK;
+			}
+		}
+		break;
+
+	case 3: /* DVB-S1/legacy mode */
+		dprintk(FE_DEBUG, 1, "Delivery system: DVB-S");
+		if (STV090x_GETFIELD_Px(dstatus, LOCK_DEFINITIF_FIELD)) {
+			reg = STV090x_READ_DEMOD(state, VSTATUSVIT);
+			if (STV090x_GETFIELD_Px(reg, LOCKEDVIT_FIELD)) {
+				*status |= FE_HAS_VITERBI;
+				reg = STV090x_READ_DEMOD(state, TSSTATUS);
+				if (STV090x_GETFIELD_Px(reg, TSFIFO_LINEOK_FIELD))
+					*status |= FE_HAS_SYNC | FE_HAS_LOCK;
+			}
+		}
+		break;
+	}
+
+	return 0;
+}
+
+#if 0
+static int stv090x_read_per(struct dvb_frontend *fe, u32 *per)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+
+	s32 count_4, count_3, count_2, count_1, count_0, count;
+	u32 reg, h, m, l;
+	enum fe_status status;
+
+	stv090x_read_status(fe, &status);
+	if (!(status & FE_HAS_LOCK)) {
+		*per = 1 << 23; /* Max PER */
+	} else {
+		/* Counter 2 */
+		reg = STV090x_READ_DEMOD(state, ERRCNT22);
+		h = STV090x_GETFIELD_Px(reg, ERR_CNT2_FIELD);
+
+		reg = STV090x_READ_DEMOD(state, ERRCNT21);
+		m = STV090x_GETFIELD_Px(reg, ERR_CNT21_FIELD);
+
+		reg = STV090x_READ_DEMOD(state, ERRCNT20);
+		l = STV090x_GETFIELD_Px(reg, ERR_CNT20_FIELD);
+
+		*per = ((h << 16) | (m << 8) | l);
+
+		count_4 = STV090x_READ_DEMOD(state, FBERCPT4);
+		count_3 = STV090x_READ_DEMOD(state, FBERCPT3);
+		count_2 = STV090x_READ_DEMOD(state, FBERCPT2);
+		count_1 = STV090x_READ_DEMOD(state, FBERCPT1);
+		count_0 = STV090x_READ_DEMOD(state, FBERCPT0);
+
+		if ((!count_4) && (!count_3)) {
+			count  = (count_2 & 0xff) << 16;
+			count |= (count_1 & 0xff) <<  8;
+			count |=  count_0 & 0xff;
+		} else {
+			count = 1 << 24;
+		}
+		if (count == 0)
+			*per = 1;
+	}
+	if (STV090x_WRITE_DEMOD(state, FBERCPT4, 0) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, ERRCTRL2, 0xc1) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+#endif
+
+static int stv090x_read_ber(struct dvb_frontend *fe, u32 *ber)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, h, m, l;
+
+	/* Counter 1: S1: 0x75 BER, S2: 0x67 PER */
+	reg = STV090x_READ_DEMOD(state, ERRCNT12);
+	h = STV090x_GETFIELD_Px(reg, ERR_CNT12_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT11);
+	m = STV090x_GETFIELD_Px(reg, ERR_CNT11_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT10);
+	l = STV090x_GETFIELD_Px(reg, ERR_CNT10_FIELD);
+
+	*ber = ((h << 16) | (m << 8) | l);
+
+	return 0;
+}
+
+static int stv090x_table_lookup(const struct stv090x_tab *tab, int max, int val)
+{
+	int res = 0;
+	int min = 0, med;
+
+	if ((val >= tab[min].read && val < tab[max].read) ||
+	    (val >= tab[max].read && val < tab[min].read)) {
+		while ((max - min) > 1) {
+			med = (max + min) / 2;
+			if ((val >= tab[min].read && val < tab[med].read) ||
+			    (val >= tab[med].read && val < tab[min].read))
+				max = med;
+			else
+				min = med;
+		}
+		res = ((val - tab[min].read) *
+		       (tab[max].real - tab[min].real) /
+		       (tab[max].read - tab[min].read)) +
+			tab[min].real;
+	} else {
+		if (tab[min].read < tab[max].read) {
+			if (val < tab[min].read)
+				res = tab[min].real;
+			else if (val >= tab[max].read)
+				res = tab[max].real;
+		} else {
+			if (val >= tab[min].read)
+				res = tab[min].real;
+			else if (val < tab[max].read)
+				res = tab[max].real;
+		}
+	}
+
+	return res;
+}
+
+static int stv090x_read_signal_strength(struct dvb_frontend *fe, u16 *strength)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg;
+	s32 agc_0, agc_1, agc;
+	s32 str;
+
+	reg = STV090x_READ_DEMOD(state, AGCIQIN1);
+	agc_1 = STV090x_GETFIELD_Px(reg, AGCIQ_VALUE_FIELD);
+	reg = STV090x_READ_DEMOD(state, AGCIQIN0);
+	agc_0 = STV090x_GETFIELD_Px(reg, AGCIQ_VALUE_FIELD);
+	agc = MAKEWORD16(agc_1, agc_0);
+
+	str = stv090x_table_lookup(stv090x_rf_tab,
+		ARRAY_SIZE(stv090x_rf_tab) - 1, agc);
+	if (agc > stv090x_rf_tab[0].read)
+		str = 0;
+	else if (agc < stv090x_rf_tab[ARRAY_SIZE(stv090x_rf_tab) - 1].read)
+		str = -100;
+	*strength = (str + 100) * 0xFFFF / 100;
+
+	return 0;
+}
+
+static int stv090x_read_cnr(struct dvb_frontend *fe, u16 *cnr)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg_0, reg_1, reg, i;
+	s32 val_0, val_1, val = 0;
+	u8 lock_f;
+	s32 div;
+	u32 last;
+
+	switch (state->delsys) {
+	case STV090x_DVBS2:
+		reg = STV090x_READ_DEMOD(state, DSTATUS);
+		lock_f = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
+		if (lock_f) {
+			msleep(5);
+			for (i = 0; i < 16; i++) {
+				reg_1 = STV090x_READ_DEMOD(state, NNOSPLHT1);
+				val_1 = STV090x_GETFIELD_Px(reg_1, NOSPLHT_NORMED_FIELD);
+				reg_0 = STV090x_READ_DEMOD(state, NNOSPLHT0);
+				val_0 = STV090x_GETFIELD_Px(reg_0, NOSPLHT_NORMED_FIELD);
+				val  += MAKEWORD16(val_1, val_0);
+				msleep(1);
+			}
+			val /= 16;
+			last = ARRAY_SIZE(stv090x_s2cn_tab) - 1;
+			div = stv090x_s2cn_tab[0].read -
+			      stv090x_s2cn_tab[last].read;
+			*cnr = 0xFFFF - ((val * 0xFFFF) / div);
+		}
+		break;
+
+	case STV090x_DVBS1:
+	case STV090x_DSS:
+		reg = STV090x_READ_DEMOD(state, DSTATUS);
+		lock_f = STV090x_GETFIELD_Px(reg, LOCK_DEFINITIF_FIELD);
+		if (lock_f) {
+			msleep(5);
+			for (i = 0; i < 16; i++) {
+				reg_1 = STV090x_READ_DEMOD(state, NOSDATAT1);
+				val_1 = STV090x_GETFIELD_Px(reg_1, NOSDATAT_UNNORMED_FIELD);
+				reg_0 = STV090x_READ_DEMOD(state, NOSDATAT0);
+				val_0 = STV090x_GETFIELD_Px(reg_0, NOSDATAT_UNNORMED_FIELD);
+				val  += MAKEWORD16(val_1, val_0);
+				msleep(1);
+			}
+			val /= 16;
+			last = ARRAY_SIZE(stv090x_s1cn_tab) - 1;
+			div = stv090x_s1cn_tab[0].read -
+			      stv090x_s1cn_tab[last].read;
+			*cnr = 0xFFFF - ((val * 0xFFFF) / div);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int stv090x_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, h, m, l;
+
+	/* Counter 2: 0xc1 TS error count */
+	reg = STV090x_READ_DEMOD(state, ERRCNT22);
+	h = STV090x_GETFIELD_Px(reg, ERR_CNT2_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT21);
+	m = STV090x_GETFIELD_Px(reg, ERR_CNT21_FIELD);
+
+	reg = STV090x_READ_DEMOD(state, ERRCNT20);
+	l = STV090x_GETFIELD_Px(reg, ERR_CNT20_FIELD);
+
+	*ucblocks = ((h << 16) | (m << 8) | l);
+
+	return 0;
+}
+
+static int stv090x_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg;
+
+	reg = STV090x_READ_DEMOD(state, DISTXCTL);
+	switch (tone) {
+	case SEC_TONE_ON:
+		STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, 0);
+		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+			goto err;
+		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
+		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+			goto err;
+		break;
+
+	case SEC_TONE_OFF:
+		STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, 0);
+		STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
+		if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+			goto err;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+
+static enum dvbfe_algo stv090x_frontend_algo(struct dvb_frontend *fe)
+{
+	return DVBFE_ALGO_CUSTOM;
+}
+
+static int stv090x_send_diseqc_msg(struct dvb_frontend *fe, struct dvb_diseqc_master_cmd *cmd)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, idle = 0, fifo_full = 1;
+	int i;
+
+	reg = STV090x_READ_DEMOD(state, DISTXCTL);
+
+	STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD,
+		(state->config->diseqc_envelope_mode) ? 4 : 2);
+	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 1);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	for (i = 0; i < cmd->msg_len; i++) {
+
+		while (fifo_full) {
+			reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
+			fifo_full = STV090x_GETFIELD_Px(reg, FIFO_FULL_FIELD);
+		}
+
+		if (STV090x_WRITE_DEMOD(state, DISTXDATA, cmd->msg[i]) < 0)
+			goto err;
+	}
+	reg = STV090x_READ_DEMOD(state, DISTXCTL);
+	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	i = 0;
+
+	while ((!idle) && (i < 10)) {
+		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
+		idle = STV090x_GETFIELD_Px(reg, TX_IDLE_FIELD);
+		msleep(10);
+		i++;
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_send_diseqc_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t burst)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg, idle = 0, fifo_full = 1;
+	u8 mode, value;
+	int i;
+
+	reg = STV090x_READ_DEMOD(state, DISTXCTL);
+
+	if (burst == SEC_MINI_A) {
+		mode = (state->config->diseqc_envelope_mode) ? 5 : 3;
+		value = 0x00;
+	} else {
+		mode = (state->config->diseqc_envelope_mode) ? 4 : 2;
+		value = 0xFF;
+	}
+
+	STV090x_SETFIELD_Px(reg, DISTX_MODE_FIELD, mode);
+	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 1);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+	STV090x_SETFIELD_Px(reg, DISEQC_RESET_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 1);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	while (fifo_full) {
+		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
+		fifo_full = STV090x_GETFIELD_Px(reg, FIFO_FULL_FIELD);
+	}
+
+	if (STV090x_WRITE_DEMOD(state, DISTXDATA, value) < 0)
+		goto err;
+
+	reg = STV090x_READ_DEMOD(state, DISTXCTL);
+	STV090x_SETFIELD_Px(reg, DIS_PRECHARGE_FIELD, 0);
+	if (STV090x_WRITE_DEMOD(state, DISTXCTL, reg) < 0)
+		goto err;
+
+	i = 0;
+
+	while ((!idle) && (i < 10)) {
+		reg = STV090x_READ_DEMOD(state, DISTXSTATUS);
+		idle = STV090x_GETFIELD_Px(reg, TX_IDLE_FIELD);
+		msleep(10);
+		i++;
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_recv_slave_reply(struct dvb_frontend *fe, struct dvb_diseqc_slave_reply *reply)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg = 0, i = 0, rx_end = 0;
+
+	while ((rx_end != 1) && (i < 10)) {
+		msleep(10);
+		i++;
+		reg = STV090x_READ_DEMOD(state, DISRX_ST0);
+		rx_end = STV090x_GETFIELD_Px(reg, RX_END_FIELD);
+	}
+
+	if (rx_end) {
+		reply->msg_len = STV090x_GETFIELD_Px(reg, FIFO_BYTENBR_FIELD);
+		for (i = 0; i < reply->msg_len; i++)
+			reply->msg[i] = STV090x_READ_DEMOD(state, DISRXDATA);
+	}
+
+	return 0;
+}
+
+static int stv090x_sleep(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg;
+	u8 full_standby = 0;
+
+	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+		goto err;
+
+	if (state->config->tuner_sleep) {
+		if (state->config->tuner_sleep(fe) < 0)
+			goto err_gateoff;
+	}
+
+	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+		goto err;
+
+	dprintk(FE_DEBUG, 1, "Set %s(%d) to sleep",
+		state->device == STV0900 ? "STV0900" : "STV0903",
+		state->demod);
+
+	mutex_lock(&state->internal->demod_lock);
+
+	switch (state->demod) {
+	case STV090x_DEMODULATOR_0:
+		/* power off ADC 1 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
+		STV090x_SETFIELD(reg, ADC1_PON_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
+			goto err;
+		/* power off DiSEqC 1 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR2);
+		STV090x_SETFIELD(reg, DISEQC1_PON_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_TSTTNR2, reg) < 0)
+			goto err;
+
+		/* check whether path 2 is already sleeping, that is when
+		   ADC2 is off */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
+		if (STV090x_GETFIELD(reg, ADC2_PON_FIELD) == 0)
+			full_standby = 1;
+
+		/* stop clocks */
+		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
+		/* packet delineator 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKPKDT1_FIELD, 1);
+		/* ADC 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKADCI1_FIELD, 1);
+		/* FEC clock is shared between the two paths, only stop it
+		   when full standby is possible */
+		if (full_standby)
+			STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
+			goto err;
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		/* sampling 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKSAMP1_FIELD, 1);
+		/* viterbi 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, 1);
+		/* TS clock is shared between the two paths, only stop it
+		   when full standby is possible */
+		if (full_standby)
+			STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_DEMODULATOR_1:
+		/* power off ADC 2 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
+		STV090x_SETFIELD(reg, ADC2_PON_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
+			goto err;
+		/* power off DiSEqC 2 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR4);
+		STV090x_SETFIELD(reg, DISEQC2_PON_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_TSTTNR4, reg) < 0)
+			goto err;
+
+		/* check whether path 1 is already sleeping, that is when
+		   ADC1 is off */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
+		if (STV090x_GETFIELD(reg, ADC1_PON_FIELD) == 0)
+			full_standby = 1;
+
+		/* stop clocks */
+		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
+		/* packet delineator 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKPKDT2_FIELD, 1);
+		/* ADC 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKADCI2_FIELD, 1);
+		/* FEC clock is shared between the two paths, only stop it
+		   when full standby is possible */
+		if (full_standby)
+			STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
+			goto err;
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		/* sampling 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKSAMP2_FIELD, 1);
+		/* viterbi 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, 1);
+		/* TS clock is shared between the two paths, only stop it
+		   when full standby is possible */
+		if (full_standby)
+			STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		break;
+
+	default:
+		dprintk(FE_ERROR, 1, "Wrong demodulator!");
+		break;
+	}
+
+	if (full_standby) {
+		/* general power off */
+		reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
+		STV090x_SETFIELD(reg, STANDBY_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_SYNTCTRL, reg) < 0)
+			goto err;
+	}
+
+	mutex_unlock(&state->internal->demod_lock);
+	return 0;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	mutex_unlock(&state->internal->demod_lock);
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_wakeup(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u32 reg;
+
+	dprintk(FE_DEBUG, 1, "Wake %s(%d) from standby",
+		state->device == STV0900 ? "STV0900" : "STV0903",
+		state->demod);
+
+	mutex_lock(&state->internal->demod_lock);
+
+	/* general power on */
+	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
+	STV090x_SETFIELD(reg, STANDBY_FIELD, 0x00);
+	if (stv090x_write_reg(state, STV090x_SYNTCTRL, reg) < 0)
+		goto err;
+
+	switch (state->demod) {
+	case STV090x_DEMODULATOR_0:
+		/* power on ADC 1 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR1);
+		STV090x_SETFIELD(reg, ADC1_PON_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
+			goto err;
+		/* power on DiSEqC 1 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR2);
+		STV090x_SETFIELD(reg, DISEQC1_PON_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_TSTTNR2, reg) < 0)
+			goto err;
+
+		/* activate clocks */
+		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
+		/* packet delineator 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKPKDT1_FIELD, 0);
+		/* ADC 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKADCI1_FIELD, 0);
+		/* FEC clock */
+		STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
+			goto err;
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		/* sampling 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKSAMP1_FIELD, 0);
+		/* viterbi 1 clock */
+		STV090x_SETFIELD(reg, STOP_CLKVIT1_FIELD, 0);
+		/* TS clock */
+		STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_DEMODULATOR_1:
+		/* power on ADC 2 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR3);
+		STV090x_SETFIELD(reg, ADC2_PON_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
+			goto err;
+		/* power on DiSEqC 2 */
+		reg = stv090x_read_reg(state, STV090x_TSTTNR4);
+		STV090x_SETFIELD(reg, DISEQC2_PON_FIELD, 1);
+		if (stv090x_write_reg(state, STV090x_TSTTNR4, reg) < 0)
+			goto err;
+
+		/* activate clocks */
+		reg = stv090x_read_reg(state, STV090x_STOPCLK1);
+		/* packet delineator 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKPKDT2_FIELD, 0);
+		/* ADC 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKADCI2_FIELD, 0);
+		/* FEC clock */
+		STV090x_SETFIELD(reg, STOP_CLKFEC_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_STOPCLK1, reg) < 0)
+			goto err;
+		reg = stv090x_read_reg(state, STV090x_STOPCLK2);
+		/* sampling 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKSAMP2_FIELD, 0);
+		/* viterbi 2 clock */
+		STV090x_SETFIELD(reg, STOP_CLKVIT2_FIELD, 0);
+		/* TS clock */
+		STV090x_SETFIELD(reg, STOP_CLKTS_FIELD, 0);
+		if (stv090x_write_reg(state, STV090x_STOPCLK2, reg) < 0)
+			goto err;
+		break;
+
+	default:
+		dprintk(FE_ERROR, 1, "Wrong demodulator!");
+		break;
+	}
+
+	mutex_unlock(&state->internal->demod_lock);
+	return 0;
+err:
+	mutex_unlock(&state->internal->demod_lock);
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static void stv090x_release(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+
+	state->internal->num_used--;
+	if (state->internal->num_used <= 0) {
+
+		dprintk(FE_ERROR, 1, "Actually removing");
+
+		remove_dev(state->internal);
+		kfree(state->internal);
+	}
+
+	kfree(state);
+}
+
+static int stv090x_ldpc_mode(struct stv090x_state *state, enum stv090x_mode ldpc_mode)
+{
+	u32 reg = 0;
+
+	reg = stv090x_read_reg(state, STV090x_GENCFG);
+
+	switch (ldpc_mode) {
+	case STV090x_DUAL:
+	default:
+		if ((state->demod_mode != STV090x_DUAL) || (STV090x_GETFIELD(reg, DDEMOD_FIELD) != 1)) {
+			/* set LDPC to dual mode */
+			if (stv090x_write_reg(state, STV090x_GENCFG, 0x1d) < 0)
+				goto err;
+
+			state->demod_mode = STV090x_DUAL;
+
+			reg = stv090x_read_reg(state, STV090x_TSTRES0);
+			STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x1);
+			if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
+				goto err;
+			STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x0);
+			if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
+				goto err;
+
+			if (STV090x_WRITE_DEMOD(state, MODCODLST0, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST1, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST2, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST3, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST4, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST5, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST6, 0xff) < 0)
+				goto err;
+
+			if (STV090x_WRITE_DEMOD(state, MODCODLST7, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST8, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLST9, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTA, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTB, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTC, 0xcc) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTD, 0xcc) < 0)
+				goto err;
+
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTE, 0xff) < 0)
+				goto err;
+			if (STV090x_WRITE_DEMOD(state, MODCODLSTF, 0xcf) < 0)
+				goto err;
+		}
+		break;
+
+	case STV090x_SINGLE:
+		if (stv090x_stop_modcod(state) < 0)
+			goto err;
+		if (stv090x_activate_modcod_single(state) < 0)
+			goto err;
+
+		if (state->demod == STV090x_DEMODULATOR_1) {
+			if (stv090x_write_reg(state, STV090x_GENCFG, 0x06) < 0) /* path 2 */
+				goto err;
+		} else {
+			if (stv090x_write_reg(state, STV090x_GENCFG, 0x04) < 0) /* path 1 */
+				goto err;
+		}
+
+		reg = stv090x_read_reg(state, STV090x_TSTRES0);
+		STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x1);
+		if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
+			goto err;
+		STV090x_SETFIELD(reg, FRESFEC_FIELD, 0x0);
+		if (stv090x_write_reg(state, STV090x_TSTRES0, reg) < 0)
+			goto err;
+
+		reg = STV090x_READ_DEMOD(state, PDELCTRL1);
+		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x01);
+		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
+			goto err;
+		STV090x_SETFIELD_Px(reg, ALGOSWRST_FIELD, 0x00);
+		if (STV090x_WRITE_DEMOD(state, PDELCTRL1, reg) < 0)
+			goto err;
+		break;
+	}
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+/* return (Hz), clk in Hz*/
+static u32 stv090x_get_mclk(struct stv090x_state *state)
+{
+	const struct stv090x_config *config = state->config;
+	u32 div, reg;
+	u8 ratio;
+
+	div = stv090x_read_reg(state, STV090x_NCOARSE);
+	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
+	ratio = STV090x_GETFIELD(reg, SELX1RATIO_FIELD) ? 4 : 6;
+
+	return (div + 1) * config->xtal / ratio; /* kHz */
+}
+
+static int stv090x_set_mclk(struct stv090x_state *state, u32 mclk, u32 clk)
+{
+	const struct stv090x_config *config = state->config;
+	u32 reg, div, clk_sel;
+
+	reg = stv090x_read_reg(state, STV090x_SYNTCTRL);
+	clk_sel = ((STV090x_GETFIELD(reg, SELX1RATIO_FIELD) == 1) ? 4 : 6);
+
+	div = ((clk_sel * mclk) / config->xtal) - 1;
+
+	reg = stv090x_read_reg(state, STV090x_NCOARSE);
+	STV090x_SETFIELD(reg, M_DIV_FIELD, div);
+	if (stv090x_write_reg(state, STV090x_NCOARSE, reg) < 0)
+		goto err;
+
+	state->internal->mclk = stv090x_get_mclk(state);
+
+	/*Set the DiseqC frequency to 22KHz */
+	div = state->internal->mclk / 704000;
+	if (STV090x_WRITE_DEMOD(state, F22TX, div) < 0)
+		goto err;
+	if (STV090x_WRITE_DEMOD(state, F22RX, div) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_set_tspath(struct stv090x_state *state)
+{
+	u32 reg;
+
+	if (state->internal->dev_ver >= 0x20) {
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+			switch (state->config->ts2_mode) {
+			case STV090x_TSMODE_SERIAL_PUNCTURED:
+			case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			default:
+				stv090x_write_reg(state, STV090x_TSGENERAL, 0x00);
+				break;
+
+			case STV090x_TSMODE_PARALLEL_PUNCTURED:
+			case STV090x_TSMODE_DVBCI:
+				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x06) < 0) /* Mux'd stream mode */
+					goto err;
+				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
+				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
+					goto err;
+				reg = stv090x_read_reg(state, STV090x_P2_TSCFGM);
+				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+				if (stv090x_write_reg(state, STV090x_P2_TSCFGM, reg) < 0)
+					goto err;
+				if (stv090x_write_reg(state, STV090x_P1_TSSPEED, 0x14) < 0)
+					goto err;
+				if (stv090x_write_reg(state, STV090x_P2_TSSPEED, 0x28) < 0)
+					goto err;
+				break;
+			}
+			break;
+
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		default:
+			switch (state->config->ts2_mode) {
+			case STV090x_TSMODE_SERIAL_PUNCTURED:
+			case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			default:
+				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c) < 0)
+					goto err;
+				break;
+
+			case STV090x_TSMODE_PARALLEL_PUNCTURED:
+			case STV090x_TSMODE_DVBCI:
+				if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0a) < 0)
+					goto err;
+				break;
+			}
+			break;
+		}
+	} else {
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+			switch (state->config->ts2_mode) {
+			case STV090x_TSMODE_SERIAL_PUNCTURED:
+			case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			default:
+				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x10);
+				break;
+
+			case STV090x_TSMODE_PARALLEL_PUNCTURED:
+			case STV090x_TSMODE_DVBCI:
+				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x16);
+				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
+				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
+					goto err;
+				reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
+				STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 0);
+				if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
+					goto err;
+				if (stv090x_write_reg(state, STV090x_P1_TSSPEED, 0x14) < 0)
+					goto err;
+				if (stv090x_write_reg(state, STV090x_P2_TSSPEED, 0x28) < 0)
+					goto err;
+				break;
+			}
+			break;
+
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		default:
+			switch (state->config->ts2_mode) {
+			case STV090x_TSMODE_SERIAL_PUNCTURED:
+			case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			default:
+				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x14);
+				break;
+
+			case STV090x_TSMODE_PARALLEL_PUNCTURED:
+			case STV090x_TSMODE_DVBCI:
+				stv090x_write_reg(state, STV090x_TSGENERAL1X, 0x12);
+				break;
+			}
+			break;
+		}
+	}
+
+	switch (state->config->ts1_mode) {
+	case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_DVBCI:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts1_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	default:
+		break;
+	}
+
+	switch (state->config->ts2_mode) {
+	case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_DVBCI:
+		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x00);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_PUNCTURED:
+		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x00);
+		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	case STV090x_TSMODE_SERIAL_CONTINUOUS:
+		reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
+		STV090x_SETFIELD_Px(reg, TSFIFO_TEIUPDATE_FIELD, state->config->ts2_tei);
+		STV090x_SETFIELD_Px(reg, TSFIFO_SERIAL_FIELD, 0x01);
+		STV090x_SETFIELD_Px(reg, TSFIFO_DVBCI_FIELD, 0x01);
+		if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+			goto err;
+		break;
+
+	default:
+		break;
+	}
+
+	if (state->config->ts1_clk > 0) {
+		u32 speed;
+
+		switch (state->config->ts1_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+		default:
+			speed = state->internal->mclk /
+				(state->config->ts1_clk / 4);
+			if (speed < 0x08)
+				speed = 0x08;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			speed = state->internal->mclk /
+				(state->config->ts1_clk / 32);
+			if (speed < 0x20)
+				speed = 0x20;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		}
+		reg = stv090x_read_reg(state, STV090x_P1_TSCFGM);
+		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+		if (stv090x_write_reg(state, STV090x_P1_TSCFGM, reg) < 0)
+			goto err;
+		if (stv090x_write_reg(state, STV090x_P1_TSSPEED, speed) < 0)
+			goto err;
+	}
+
+	if (state->config->ts2_clk > 0) {
+		u32 speed;
+
+		switch (state->config->ts2_mode) {
+		case STV090x_TSMODE_PARALLEL_PUNCTURED:
+		case STV090x_TSMODE_DVBCI:
+		default:
+			speed = state->internal->mclk /
+				(state->config->ts2_clk / 4);
+			if (speed < 0x08)
+				speed = 0x08;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		case STV090x_TSMODE_SERIAL_PUNCTURED:
+		case STV090x_TSMODE_SERIAL_CONTINUOUS:
+			speed = state->internal->mclk /
+				(state->config->ts2_clk / 32);
+			if (speed < 0x20)
+				speed = 0x20;
+			if (speed > 0xFF)
+				speed = 0xFF;
+			break;
+		}
+		reg = stv090x_read_reg(state, STV090x_P2_TSCFGM);
+		STV090x_SETFIELD_Px(reg, TSFIFO_MANSPEED_FIELD, 3);
+		if (stv090x_write_reg(state, STV090x_P2_TSCFGM, reg) < 0)
+			goto err;
+		if (stv090x_write_reg(state, STV090x_P2_TSSPEED, speed) < 0)
+			goto err;
+	}
+
+	reg = stv090x_read_reg(state, STV090x_P2_TSCFGH);
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
+	if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+		goto err;
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
+	if (stv090x_write_reg(state, STV090x_P2_TSCFGH, reg) < 0)
+		goto err;
+
+	reg = stv090x_read_reg(state, STV090x_P1_TSCFGH);
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x01);
+	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+		goto err;
+	STV090x_SETFIELD_Px(reg, RST_HWARE_FIELD, 0x00);
+	if (stv090x_write_reg(state, STV090x_P1_TSCFGH, reg) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_init(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	const struct stv090x_config *config = state->config;
+	u32 reg;
+
+	if (state->internal->mclk == 0) {
+		/* call tuner init to configure the tuner's clock output
+		   divider directly before setting up the master clock of
+		   the stv090x. */
+		if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+			goto err;
+
+		if (config->tuner_init) {
+			if (config->tuner_init(fe) < 0)
+				goto err_gateoff;
+		}
+
+		if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+			goto err;
+
+		stv090x_set_mclk(state, 135000000, config->xtal); /* 135 Mhz */
+		msleep(5);
+		if (stv090x_write_reg(state, STV090x_SYNTCTRL,
+				      0x20 | config->clk_mode) < 0)
+			goto err;
+		stv090x_get_mclk(state);
+	}
+
+	if (stv090x_wakeup(fe) < 0) {
+		dprintk(FE_ERROR, 1, "Error waking device");
+		goto err;
+	}
+
+	if (stv090x_ldpc_mode(state, state->demod_mode) < 0)
+		goto err;
+
+	reg = STV090x_READ_DEMOD(state, TNRCFG2);
+	STV090x_SETFIELD_Px(reg, TUN_IQSWAP_FIELD, state->inversion);
+	if (STV090x_WRITE_DEMOD(state, TNRCFG2, reg) < 0)
+		goto err;
+	reg = STV090x_READ_DEMOD(state, DEMOD);
+	STV090x_SETFIELD_Px(reg, ROLLOFF_CONTROL_FIELD, state->rolloff);
+	if (STV090x_WRITE_DEMOD(state, DEMOD, reg) < 0)
+		goto err;
+
+	if (stv090x_i2c_gate_ctrl(state, 1) < 0)
+		goto err;
+
+	if (config->tuner_set_mode) {
+		if (config->tuner_set_mode(fe, TUNER_WAKE) < 0)
+			goto err_gateoff;
+	}
+
+	if (config->tuner_init) {
+		if (config->tuner_init(fe) < 0)
+			goto err_gateoff;
+	}
+
+	if (stv090x_i2c_gate_ctrl(state, 0) < 0)
+		goto err;
+
+	if (stv090x_set_tspath(state) < 0)
+		goto err;
+
+	return 0;
+
+err_gateoff:
+	stv090x_i2c_gate_ctrl(state, 0);
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+static int stv090x_setup(struct dvb_frontend *fe)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	const struct stv090x_config *config = state->config;
+	const struct stv090x_reg *stv090x_initval = NULL;
+	const struct stv090x_reg *stv090x_cut20_val = NULL;
+	unsigned long t1_size = 0, t2_size = 0;
+	u32 reg = 0;
+
+	int i;
+
+	if (state->device == STV0900) {
+		dprintk(FE_DEBUG, 1, "Initializing STV0900");
+		stv090x_initval = stv0900_initval;
+		t1_size = ARRAY_SIZE(stv0900_initval);
+		stv090x_cut20_val = stv0900_cut20_val;
+		t2_size = ARRAY_SIZE(stv0900_cut20_val);
+	} else if (state->device == STV0903) {
+		dprintk(FE_DEBUG, 1, "Initializing STV0903");
+		stv090x_initval = stv0903_initval;
+		t1_size = ARRAY_SIZE(stv0903_initval);
+		stv090x_cut20_val = stv0903_cut20_val;
+		t2_size = ARRAY_SIZE(stv0903_cut20_val);
+	}
+
+	/* STV090x init */
+
+	/* Stop Demod */
+	if (stv090x_write_reg(state, STV090x_P1_DMDISTATE, 0x5c) < 0)
+		goto err;
+	if (stv090x_write_reg(state, STV090x_P2_DMDISTATE, 0x5c) < 0)
+		goto err;
+
+	msleep(5);
+
+	/* Set No Tuner Mode */
+	if (stv090x_write_reg(state, STV090x_P1_TNRCFG, 0x6c) < 0)
+		goto err;
+	if (stv090x_write_reg(state, STV090x_P2_TNRCFG, 0x6c) < 0)
+		goto err;
+
+	/* I2C repeater OFF */
+	STV090x_SETFIELD_Px(reg, ENARPT_LEVEL_FIELD, config->repeater_level);
+	if (stv090x_write_reg(state, STV090x_P1_I2CRPT, reg) < 0)
+		goto err;
+	if (stv090x_write_reg(state, STV090x_P2_I2CRPT, reg) < 0)
+		goto err;
+
+	if (stv090x_write_reg(state, STV090x_NCOARSE, 0x13) < 0) /* set PLL divider */
+		goto err;
+	msleep(5);
+	if (stv090x_write_reg(state, STV090x_I2CCFG, 0x08) < 0) /* 1/41 oversampling */
+		goto err;
+	if (stv090x_write_reg(state, STV090x_SYNTCTRL, 0x20 | config->clk_mode) < 0) /* enable PLL */
+		goto err;
+	msleep(5);
+
+	/* write initval */
+	dprintk(FE_DEBUG, 1, "Setting up initial values");
+	for (i = 0; i < t1_size; i++) {
+		if (stv090x_write_reg(state, stv090x_initval[i].addr, stv090x_initval[i].data) < 0)
+			goto err;
+	}
+
+	state->internal->dev_ver = stv090x_read_reg(state, STV090x_MID);
+	if (state->internal->dev_ver >= 0x20) {
+		if (stv090x_write_reg(state, STV090x_TSGENERAL, 0x0c) < 0)
+			goto err;
+
+		/* write cut20_val*/
+		dprintk(FE_DEBUG, 1, "Setting up Cut 2.0 initial values");
+		for (i = 0; i < t2_size; i++) {
+			if (stv090x_write_reg(state, stv090x_cut20_val[i].addr, stv090x_cut20_val[i].data) < 0)
+				goto err;
+		}
+
+	} else if (state->internal->dev_ver < 0x20) {
+		dprintk(FE_ERROR, 1, "ERROR: Unsupported Cut: 0x%02x!",
+			state->internal->dev_ver);
+
+		goto err;
+	} else if (state->internal->dev_ver > 0x30) {
+		/* we shouldn't bail out from here */
+		dprintk(FE_ERROR, 1, "INFO: Cut: 0x%02x probably incomplete support!",
+			state->internal->dev_ver);
+	}
+
+	/* ADC1 range */
+	reg = stv090x_read_reg(state, STV090x_TSTTNR1);
+	STV090x_SETFIELD(reg, ADC1_INMODE_FIELD,
+		(config->adc1_range == STV090x_ADC_1Vpp) ? 0 : 1);
+	if (stv090x_write_reg(state, STV090x_TSTTNR1, reg) < 0)
+		goto err;
+
+	/* ADC2 range */
+	reg = stv090x_read_reg(state, STV090x_TSTTNR3);
+	STV090x_SETFIELD(reg, ADC2_INMODE_FIELD,
+		(config->adc2_range == STV090x_ADC_1Vpp) ? 0 : 1);
+	if (stv090x_write_reg(state, STV090x_TSTTNR3, reg) < 0)
+		goto err;
+
+	if (stv090x_write_reg(state, STV090x_TSTRES0, 0x80) < 0)
+		goto err;
+	if (stv090x_write_reg(state, STV090x_TSTRES0, 0x00) < 0)
+		goto err;
+
+	return 0;
+err:
+	dprintk(FE_ERROR, 1, "I/O error");
+	return -1;
+}
+
+int stv090x_set_gpio(struct dvb_frontend *fe, u8 gpio, u8 dir, u8 value,
+		u8 xor_value)
+{
+	struct stv090x_state *state = fe->demodulator_priv;
+	u8 reg = 0;
+
+	STV090x_SETFIELD(reg, GPIOx_OPD_FIELD, dir);
+	STV090x_SETFIELD(reg, GPIOx_CONFIG_FIELD, value);
+	STV090x_SETFIELD(reg, GPIOx_XOR_FIELD, xor_value);
+
+	return stv090x_write_reg(state, STV090x_GPIOxCFG(gpio), reg);
+}
+EXPORT_SYMBOL(stv090x_set_gpio);
+
+static struct dvb_frontend_ops stv090x_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2, SYS_DSS },
+	.info = {
+		.name			= "STV090x Multistandard",
+		.frequency_min		= 950000,
+		.frequency_max 		= 2150000,
+		.frequency_stepsize	= 0,
+		.frequency_tolerance	= 0,
+		.symbol_rate_min 	= 1000000,
+		.symbol_rate_max 	= 45000000,
+		.caps			= FE_CAN_INVERSION_AUTO |
+					  FE_CAN_FEC_AUTO       |
+					  FE_CAN_QPSK           |
+					  FE_CAN_2G_MODULATION
+	},
+
+	.release			= stv090x_release,
+	.init				= stv090x_init,
+
+	.sleep				= stv090x_sleep,
+	.get_frontend_algo		= stv090x_frontend_algo,
+
+	.diseqc_send_master_cmd		= stv090x_send_diseqc_msg,
+	.diseqc_send_burst		= stv090x_send_diseqc_burst,
+	.diseqc_recv_slave_reply	= stv090x_recv_slave_reply,
+	.set_tone			= stv090x_set_tone,
+
+	.search				= stv090x_search,
+	.read_status			= stv090x_read_status,
+	.read_ber			= stv090x_read_ber,
+	.read_signal_strength		= stv090x_read_signal_strength,
+	.read_snr			= stv090x_read_cnr,
+	.read_ucblocks			= stv090x_read_ucblocks,
+};
+
+
+struct dvb_frontend *stv090x_attach(const struct stv090x_config *config,
+				    struct i2c_adapter *i2c,
+				    enum stv090x_demodulator demod)
+{
+	struct stv090x_state *state = NULL;
+	struct stv090x_dev *temp_int;
+
+	state = kzalloc(sizeof (struct stv090x_state), GFP_KERNEL);
+	if (state == NULL)
+		goto error;
+
+	state->verbose				= &verbose;
+	state->config				= config;
+	state->i2c				= i2c;
+	state->frontend.ops			= stv090x_ops;
+	state->frontend.demodulator_priv	= state;
+	state->demod				= demod;
+	state->demod_mode 			= config->demod_mode; /* Single or Dual mode */
+	state->device				= config->device;
+	state->rolloff				= STV090x_RO_35; /* default */
+
+	temp_int = find_dev(state->i2c,
+				state->config->address);
+
+	if ((temp_int != NULL) && (state->demod_mode == STV090x_DUAL)) {
+		state->internal = temp_int->internal;
+		state->internal->num_used++;
+		dprintk(FE_INFO, 1, "Found Internal Structure!");
+	} else {
+		state->internal = kmalloc(sizeof(struct stv090x_internal),
+					  GFP_KERNEL);
+		if (!state->internal)
+			goto error;
+		temp_int = append_internal(state->internal);
+		if (!temp_int) {
+			kfree(state->internal);
+			goto error;
+		}
+		state->internal->num_used = 1;
+		state->internal->mclk = 0;
+		state->internal->dev_ver = 0;
+		state->internal->i2c_adap = state->i2c;
+		state->internal->i2c_addr = state->config->address;
+		dprintk(FE_INFO, 1, "Create New Internal Structure!");
+
+		mutex_init(&state->internal->demod_lock);
+		mutex_init(&state->internal->tuner_lock);
+
+		if (stv090x_setup(&state->frontend) < 0) {
+			dprintk(FE_ERROR, 1, "Error setting up device");
+			goto err_remove;
+		}
+	}
+
+	/* workaround for stuck DiSEqC output */
+	if (config->diseqc_envelope_mode)
+		stv090x_send_diseqc_burst(&state->frontend, SEC_MINI_A);
+
+	dprintk(FE_ERROR, 1, "Attaching %s demodulator(%d) Cut=0x%02x",
+	       state->device == STV0900 ? "STV0900" : "STV0903",
+	       demod,
+	       state->internal->dev_ver);
+
+	return &state->frontend;
+
+err_remove:
+	remove_dev(state->internal);
+	kfree(state->internal);
+error:
+	kfree(state);
+	return NULL;
+}
+EXPORT_SYMBOL(stv090x_attach);
+MODULE_PARM_DESC(verbose, "Set Verbosity level");
+MODULE_AUTHOR("Manu Abraham");
+MODULE_DESCRIPTION("STV090x Multi-Std Broadcast frontend");
+MODULE_LICENSE("GPL");
diff -urN linux-3.4.3/drivers/media/dvb/frontends/tda18212dd.c linux-3.4.3.dd/drivers/media/dvb/frontends/tda18212dd.c
--- linux-3.4.3/drivers/media/dvb/frontends/tda18212dd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/tda18212dd.c	2012-06-18 23:27:57.314033923 +0200
@@ -0,0 +1,907 @@
+/*
+ * tda18212: Driver for the TDA18212 tuner
+ *
+ * Copyright (C) 2011 Digital Devices GmbH
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/i2c.h>
+#include <linux/version.h>
+#include <asm/div64.h>
+
+#include "linux/compat.h"
+#include "dvb_frontend.h"
+
+#ifndef CHK_ERROR
+    #define CHK_ERROR(s) if ((status = s) < 0) break
+#endif
+
+#define MASTER_PSM_AGC1     0
+#define MASTER_AGC1_6_15dB  1
+
+#define SLAVE_PSM_AGC1      1
+#define SLAVE_AGC1_6_15dB   0
+
+// 0 = 2 Vpp ... 2 = 1 Vpp,   7 = 0.5 Vpp
+#define IF_LEVEL_DVBC    2
+#define IF_LEVEL_DVBT    2
+
+enum {
+	ID_1                = 0x00,
+	ID_2                = 0x01,
+	ID_3                = 0x02,
+	THERMO_1,
+	THERMO_2,
+	POWER_STATE_1,
+	POWER_STATE_2,
+	INPUT_POWER_LEVEL,
+	IRQ_STATUS,
+	IRQ_ENABLE,
+	IRQ_CLEAR,
+	IRQ_SET,
+	AGC1_1,
+	AGC2_1,
+	AGCK_1,
+	RF_AGC_1,
+	IR_MIXER_1          = 0x10,
+	AGC5_1,
+	IF_AGC,
+	IF_1,
+	REFERENCE,
+	IF_FREQUENCY_1,
+	RF_FREQUENCY_1,
+	RF_FREQUENCY_2,
+	RF_FREQUENCY_3,
+	MSM_1,
+	MSM_2,
+	PSM_1,
+	DCC_1,
+	FLO_MAX,
+	IR_CAL_1,
+	IR_CAL_2,
+	IR_CAL_3            = 0x20,
+	IR_CAL_4,
+	VSYNC_MGT,
+	IR_MIXER_2,
+	AGC1_2,
+	AGC5_2,
+	RF_CAL_1,
+	RF_CAL_2,
+	RF_CAL_3,
+	RF_CAL_4,
+	RF_CAL_5,
+	RF_CAL_6,
+	RF_FILTER_1,
+	RF_FILTER_2,
+	RF_FILTER_3,
+	RF_BAND_PASS_FILTER,
+	CP_CURRENT          = 0x30,
+	AGC_DET_OUT         = 0x31,
+	RF_AGC_GAIN_1       = 0x32,
+	RF_AGC_GAIN_2       = 0x33,
+	IF_AGC_GAIN         = 0x34,
+	POWER_1             = 0x35,
+	POWER_2             = 0x36,
+	MISC_1,
+	RFCAL_LOG_1,
+	RFCAL_LOG_2,
+	RFCAL_LOG_3,
+	RFCAL_LOG_4,
+	RFCAL_LOG_5,
+	RFCAL_LOG_6,
+	RFCAL_LOG_7,
+	RFCAL_LOG_8,
+	RFCAL_LOG_9         = 0x40,
+	RFCAL_LOG_10        = 0x41,
+	RFCAL_LOG_11        = 0x42,
+	RFCAL_LOG_12        = 0x43,
+	REG_MAX,
+};
+
+enum HF_Standard {
+	HF_None=0, HF_B, HF_DK, HF_G, HF_I, HF_L, HF_L1, HF_MN, HF_FM_Radio,
+	HF_AnalogMax, HF_DVBT_6MHZ, HF_DVBT_7MHZ, HF_DVBT_8MHZ,
+	HF_DVBT, HF_ATSC,  HF_DVBC_6MHZ,  HF_DVBC_7MHZ,
+	HF_DVBC_8MHZ, HF_DVBC
+};
+
+struct SStandardParams {
+	s32   m_IFFrequency;
+	u32   m_BandWidth;
+	u8    m_IF_1;         // FF IF_HP_fc:2 IF_Notch:1 LP_FC_Offset:2 LP_FC:3
+	u8    m_IR_MIXER_2;   // 03 :6 HI_Pass:1 DC_Notch:1
+	u8    m_AGC1_1;       // 0F :4 AGC1_Top:4
+	u8    m_AGC2_1;       // 0F :4 AGC2_Top:4
+	u8    m_RF_AGC_1_Low; // EF RF_AGC_Adapt:1 RF_AGC_Adapt_Top:2 :1 RF_Atten_3dB:1  RF_AGC_Top:3
+	u8    m_RF_AGC_1_High;// EF RF_AGC_Adapt:1 RF_AGC_Adapt_Top:2 :1 RF_Atten_3dB:1  RF_AGC_Top:3
+	u8    m_IR_MIXER_1;   // 0F :4 IR_mixer_Top:4
+	u8    m_AGC5_1;       // 1F :3 AGC5_Ana AGC5_Top:4
+	u8    m_AGCK_1;       // 0F :4 AGCK_Step:2 AGCK_Mode:2
+	u8    m_PSM_1;        // 20 :2 PSM_StoB:1 :5
+	bool  m_AGC1_Freeze;
+	bool  m_LTO_STO_immune;
+};
+
+struct SStandardParams m_StandardTable[HF_DVBC_8MHZ - HF_DVBT_6MHZ + 1] =
+{
+	{ 3250000, 6000000, 0x20, 0x03, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_6MHZ
+	{ 3500000, 7000000, 0x31, 0x01, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_7MHZ
+	{ 4000000, 8000000, 0x22, 0x01, 0x00, 0x07, 0x2B, 0x2C, 0x0B, 0x0B, 0x02, 0x20, false, false },    // HF_DVBT_8MHZ
+	{       0,       0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, false, false },    // HF_DVBT (Unused)
+	{ 3250000, 6000000, 0x20, 0x03, 0x0A, 0x07, 0x6D, 0x6D, 0x0E, 0x0E, 0x02, 0x20, false, false },    // HF_ATSC
+	{ 3600000, 6000000, 0x10, 0x01, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_6MHZ
+//    { 5000000, 7000000, 0x53, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_7MHZ (not documented by NXP, use same settings as 8 MHZ)
+//    { 5000000, 8000000, 0x53, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_8MHZ
+	{ 5000000, 7000000, 0x93, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_7MHZ (not documented by NXP, use same settings as 8 MHZ)
+	{ 5000000, 8000000, 0x43, 0x03, 0x00, 0x07, 0x83, 0x83, 0x0B, 0x0B, 0x02, 0x00, true , true  },    // HF_DVBC_8MHZ
+};
+
+struct tda_state {
+	struct i2c_adapter *i2c;
+	u8 adr;
+
+	enum HF_Standard m_Standard;
+	u32   m_Frequency;
+	u32   IF;
+
+	bool    m_isMaster;
+	bool    m_bPowerMeasurement;
+	bool    m_bLTEnable;
+	bool    m_bEnableFreeze;
+
+	u16   m_ID;
+
+	s32    m_SettlingTime;
+
+	u8    m_IFLevelDVBC;
+	u8    m_IFLevelDVBT;
+	u8    m_Regs[REG_MAX];
+	u8    m_LastPowerLevel;
+};
+
+static int i2c_readn(struct i2c_adapter *adapter, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msgs[1] = {{.addr = adr,  .flags = I2C_M_RD,
+				   .buf  = data, .len   = len}};
+	return (i2c_transfer(adapter, msgs, 1) == 1) ? 0 : -1;
+}
+
+static int i2c_read(struct i2c_adapter *adap,
+		    u8 adr, u8 *msg, int len, u8 *answ, int alen)
+{
+	struct i2c_msg msgs[2] = { { .addr = adr, .flags = 0,
+				     .buf = msg, .len = len},
+				   { .addr = adr, .flags = I2C_M_RD,
+				     .buf = answ, .len = alen } };
+	if (i2c_transfer(adap, msgs, 2) != 2) {
+		printk("tda18212dd: i2c_read error\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int i2c_write(struct i2c_adapter *adap, u8 adr, u8 *data, int len)
+{
+	struct i2c_msg msg = {.addr = adr, .flags = 0,
+			      .buf = data, .len = len};
+
+	if (i2c_transfer(adap, &msg, 1) != 1) {
+		printk("tda18212: i2c_write error\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int write_regs(struct tda_state *state,
+		      u8 SubAddr, u8 *Regs, u16 nRegs)
+{
+	u8 data[nRegs+1];
+
+	data[0] = SubAddr;
+	memcpy(data + 1, Regs, nRegs);
+	return i2c_write(state->i2c, state->adr, data, nRegs+1);
+}
+
+static int write_reg(struct tda_state *state, u8 SubAddr,u8 Reg)
+{
+	u8 msg[2] = {SubAddr, Reg};
+
+	return i2c_write(state->i2c, state->adr, msg, 2);
+}
+
+static int Read(struct tda_state *state, u8 * Regs)
+{
+	return i2c_readn(state->i2c, state->adr, Regs, REG_MAX);
+}
+
+static int update_regs(struct tda_state *state, u8 RegFrom,u8 RegTo)
+{
+	return write_regs(state, RegFrom,
+			  &state->m_Regs[RegFrom], RegTo-RegFrom+1);
+}
+
+static int update_reg(struct tda_state *state, u8 Reg)
+{
+	return write_reg(state, Reg,state->m_Regs[Reg]);
+}
+
+
+static int read_regs(struct tda_state *state,
+		    u8 SubAddr, u8 *Regs, u16 nRegs)
+{
+	return i2c_read(state->i2c, state->adr,
+			&SubAddr, 1, Regs, nRegs);
+}
+
+static int read_reg(struct tda_state *state,
+		   u8 SubAddr, u8 *Reg)
+{
+	return i2c_read(state->i2c, state->adr,
+			&SubAddr, 1, Reg, 1);
+}
+
+static int read_reg1(struct tda_state *state, u8 Reg)
+{
+	return read_reg(state, Reg, &state->m_Regs[Reg]);
+}
+
+static void init_state(struct tda_state *state)
+{
+    u32   ulIFLevelDVBC = IF_LEVEL_DVBC;
+    u32   ulIFLevelDVBT = IF_LEVEL_DVBT;
+    u32   ulPowerMeasurement = 1;
+    u32   ulLTEnable = 1;
+    u32   ulEnableFreeze = 0;
+
+    state->m_Frequency    = 0;
+    state->m_isMaster = true;
+    state->m_ID = 0;
+    state->m_LastPowerLevel = 0xFF;
+    state->m_IFLevelDVBC = (ulIFLevelDVBC & 0x07);
+    state->m_IFLevelDVBT = (ulIFLevelDVBT & 0x07);
+    state->m_bPowerMeasurement = (ulPowerMeasurement != 0);
+    state->m_bLTEnable = (ulLTEnable != 0);
+    state->m_bEnableFreeze = (ulEnableFreeze != 0);
+}
+
+static int StartCalibration(struct tda_state *state)
+{
+	int  status = 0;
+	do {
+		state->m_Regs[POWER_2] &= ~0x02; // RSSI CK = 31.25 kHz
+		CHK_ERROR(update_reg(state, POWER_2));
+
+		state->m_Regs[AGC1_2] = (state->m_Regs[AGC1_2] & ~0x60) | 0x40;    // AGC1 Do Step = 2
+		CHK_ERROR(update_reg(state, AGC1_2));        // AGC
+
+		state->m_Regs[RF_FILTER_3] = (state->m_Regs[RF_FILTER_3] & ~0xC0) | 0x40;    // AGC2 Do Step = 1
+		CHK_ERROR(update_reg(state, RF_FILTER_3));
+
+		state->m_Regs[AGCK_1] |= 0xC0; // AGCs Assym Up Step = 3      // Datasheet sets all bits to 1!
+		CHK_ERROR(update_reg(state, AGCK_1));
+
+		state->m_Regs[AGC5_1] = (state->m_Regs[AGC5_1] & ~0x60) | 0x40;    // AGCs Assym Do Step = 2
+		CHK_ERROR(update_reg(state, AGC5_1));
+
+		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
+		CHK_ERROR(update_reg(state, IRQ_CLEAR));
+
+		state->m_Regs[MSM_1] = 0x3B; // Set Calibration
+		state->m_Regs[MSM_2] = 0x01; // Start MSM
+		CHK_ERROR(update_regs(state, MSM_1,MSM_2));
+		state->m_Regs[MSM_2] = 0x00;
+
+	} while(0);
+	return status;
+}
+
+static int FinishCalibration(struct tda_state *state)
+{
+	int status = 0;
+	u8 RFCal_Log[12];
+
+	do {
+		u8 IRQ = 0;
+		int Timeout = 150; // 1.5 s
+		while(true) {
+			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
+			if ((IRQ & 0x80) != 0 )
+				break;
+			Timeout -= 1;
+			if (Timeout == 0) {
+				status = -1;
+				break;
+			}
+			msleep(10);
+		}
+		CHK_ERROR(status);
+
+		state->m_Regs[FLO_MAX] = 0x0A;
+		CHK_ERROR(update_reg(state, FLO_MAX));
+
+		state->m_Regs[AGC1_1] &= ~0xC0;
+		if( state->m_bLTEnable ) state->m_Regs[AGC1_1] |= 0x80;    // LTEnable
+
+		state->m_Regs[AGC1_1] |= (state->m_isMaster ? MASTER_AGC1_6_15dB : SLAVE_AGC1_6_15dB ) << 6;
+		CHK_ERROR(update_reg(state, AGC1_1));
+
+		state->m_Regs[PSM_1] &= ~0xC0;
+		state->m_Regs[PSM_1] |= (state->m_isMaster ? MASTER_PSM_AGC1 : SLAVE_PSM_AGC1 ) << 6;
+		CHK_ERROR(update_reg(state, PSM_1));
+
+		state->m_Regs[REFERENCE] |= 0x03; // XTOUT = 3
+		CHK_ERROR(update_reg(state, REFERENCE));
+
+		CHK_ERROR(read_regs(state, RFCAL_LOG_1,RFCal_Log,sizeof(RFCal_Log)));
+	} while(0);
+	return status;
+}
+
+static int PowerOn(struct tda_state *state)
+{
+	state->m_Regs[POWER_STATE_2] &= ~0x0F;
+	update_reg(state, POWER_STATE_2);
+	state->m_Regs[REFERENCE] |= 0x40;  // Digital clock source = Sigma Delta
+	update_reg(state, REFERENCE);
+	return 0;
+}
+
+static int Standby(struct tda_state *state)
+{
+	int status = 0;
+
+	do {
+		state->m_Regs[REFERENCE] &= ~0x40;  // Digital clock source = Quarz
+		CHK_ERROR(update_reg(state, REFERENCE));
+
+		state->m_Regs[POWER_STATE_2] &= ~0x0F;
+		state->m_Regs[POWER_STATE_2] |= state->m_isMaster ? 0x08 : 0x0E;
+		CHK_ERROR(update_reg(state, POWER_STATE_2));
+	} while(0);
+	return status;
+}
+
+static int attach_init(struct tda_state *state)
+{
+	int stat = 0;
+	u8 Id[2];
+	u8 PowerState = 0x00;
+
+	state->m_Standard = HF_None;
+
+	/* first read after cold reset sometimes fails on some cards,
+	   try twice */
+	stat = read_regs(state, ID_1, Id, sizeof(Id));
+	stat = read_regs(state, ID_1, Id, sizeof(Id));
+	if (stat < 0)
+		return -1;
+
+	state->m_ID = ((Id[0] & 0x7F) << 8) | Id[1];
+	state->m_isMaster = ((Id[0] & 0x80) != 0);
+	if( !state->m_isMaster )
+		state->m_bLTEnable = false;
+
+	printk("tda18212dd: ChipID %04x\n", state->m_ID);
+
+	if( state->m_ID != 18212 )
+		return -1;
+
+	stat = read_reg(state, POWER_STATE_1 ,&PowerState);
+	if (stat < 0)
+		return stat;
+
+	printk("tda18212dd: PowerState %02x\n", PowerState);
+
+	if (state->m_isMaster) {
+		if( PowerState & 0x02 ) {
+			// msleep for XTAL Calibration (on a PC this should be long done)
+			u8 IRQStatus = 0;
+			int Timeout = 10;
+
+			while(Timeout > 0) {
+				read_reg(state, IRQ_STATUS, &IRQStatus);
+				if (IRQStatus & 0x20)
+					break;
+				Timeout -= 1;
+				msleep(10);
+			}
+			if( (IRQStatus & 0x20) == 0 ) {
+				stat = -ETIMEDOUT;
+			}
+		}
+	} else {
+		write_reg(state, FLO_MAX, 0x00);
+		write_reg(state, CP_CURRENT,0x68);
+	}
+	Read(state, state->m_Regs);
+
+	PowerOn(state);
+	StartCalibration(state);
+	FinishCalibration(state);
+	Standby(state);
+	return stat;
+}
+
+static int PowerMeasurement(struct tda_state *state, u8 *pPowerLevel)
+{
+	int status = 0;
+
+	do {
+		u8 IRQ = 0;
+		int Timeout = 70; // 700 ms
+
+		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
+		CHK_ERROR(update_reg(state, IRQ_CLEAR));
+
+		state->m_Regs[MSM_1] = 0x80; // power measurement
+		state->m_Regs[MSM_2] = 0x01; // Start MSM
+		CHK_ERROR(update_regs(state, MSM_1,MSM_2));
+		state->m_Regs[MSM_2] = 0x00;
+
+		while(true) {
+			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
+			if( (IRQ & 0x80) != 0 )
+				break;
+			Timeout -= 1;
+			if( Timeout == 0 )
+			{
+				status = -1;
+				break;
+			}
+			msleep(10);
+		}
+		CHK_ERROR(status);
+
+		CHK_ERROR(read_reg1(state, INPUT_POWER_LEVEL));
+		*pPowerLevel = state->m_Regs[INPUT_POWER_LEVEL] & 0x7F;
+
+
+		if( *pPowerLevel > 110 ) *pPowerLevel = 110;
+	} while(0);
+	/* printk("PL %d\n", *pPowerLevel); */
+	return status;
+}
+
+static int SetFrequency(struct tda_state *state, u32 Frequency, enum HF_Standard Standard)
+{
+	int status = 0;
+	struct SStandardParams *StandardParams;
+	u32   f = Frequency / 1000;
+	u8 IRQ = 0;
+	int Timeout = 25; // 250 ms
+	u32 fRatio = Frequency / 16000000;
+	u32 fDelta = Frequency - fRatio * 16000000;
+
+	if( Standard < HF_DVBT_6MHZ || Standard > HF_DVBC_8MHZ )
+		return -EINVAL;
+	StandardParams = &m_StandardTable[Standard - HF_DVBT_6MHZ];
+
+	if( StandardParams->m_IFFrequency == 0 )
+		return -EINVAL;
+	state->m_Standard = HF_None;
+	state->m_Frequency = 0;
+
+	do {
+		// IF Level
+		state->m_Regs[IF_AGC] = (Standard >= HF_DVBC_6MHZ) ? state->m_IFLevelDVBC : state->m_IFLevelDVBT;
+		CHK_ERROR(update_reg(state, IF_AGC));
+
+		// ---------------------------------------------------------------------------------
+		// Standard setup
+
+		state->m_Regs[IF_1] = StandardParams->m_IF_1;
+		CHK_ERROR(update_reg(state, IF_1));
+
+		state->m_Regs[IR_MIXER_2] = (state->m_Regs[IR_MIXER_2] & ~0x03) | StandardParams->m_IR_MIXER_2;
+		CHK_ERROR(update_reg(state, IR_MIXER_2));
+
+		state->m_Regs[AGC1_1] = (state->m_Regs[AGC1_1] & ~0x0F) | StandardParams->m_AGC1_1;
+		CHK_ERROR(update_reg(state, AGC1_1));
+
+		state->m_Regs[AGC2_1] = (state->m_Regs[AGC2_1] & ~0x0F) | StandardParams->m_AGC2_1;
+		CHK_ERROR(update_reg(state, AGC2_1));
+
+		state->m_Regs[RF_AGC_1] &= ~0xEF;
+		if( Frequency < 291000000 )
+			state->m_Regs[RF_AGC_1] |= StandardParams->m_RF_AGC_1_Low;
+		else
+			state->m_Regs[RF_AGC_1] |= StandardParams->m_RF_AGC_1_High;
+		CHK_ERROR(update_reg(state, RF_AGC_1));
+
+		state->m_Regs[IR_MIXER_1] = (state->m_Regs[IR_MIXER_1] & ~0x0F) | StandardParams->m_IR_MIXER_1;
+		CHK_ERROR(update_reg(state, IR_MIXER_1));
+
+		state->m_Regs[AGC5_1] = (state->m_Regs[AGC5_1] & ~0x1F) | StandardParams->m_AGC5_1;
+		CHK_ERROR(update_reg(state, AGC5_1));
+
+		state->m_Regs[AGCK_1] = (state->m_Regs[AGCK_1] & ~0x0F) | StandardParams->m_AGCK_1;
+		CHK_ERROR(update_reg(state, AGCK_1));
+
+		state->m_Regs[PSM_1] = (state->m_Regs[PSM_1] & ~0x20) | StandardParams->m_PSM_1;
+		CHK_ERROR(update_reg(state, PSM_1));
+
+		state->m_Regs[IF_FREQUENCY_1] = ( StandardParams->m_IFFrequency / 50000 );
+		CHK_ERROR(update_reg(state, IF_FREQUENCY_1));
+
+		if( state->m_isMaster && StandardParams->m_LTO_STO_immune )
+		{
+			u8 tmp;
+			u8 RF_Filter_Gain;
+
+			CHK_ERROR(read_reg(state, RF_AGC_GAIN_1,&tmp));
+			RF_Filter_Gain = (tmp & 0x30) >> 4;
+
+			state->m_Regs[RF_FILTER_1] = (state->m_Regs[RF_FILTER_1] & ~0x0C) | (RF_Filter_Gain << 2);
+			CHK_ERROR(update_reg(state, RF_FILTER_1));
+
+			state->m_Regs[RF_FILTER_1] |= 0x10;    // Force
+			CHK_ERROR(update_reg(state, RF_FILTER_1));
+
+			while( RF_Filter_Gain != 0 )
+			{
+				RF_Filter_Gain -= 1;
+				state->m_Regs[RF_FILTER_1] = (state->m_Regs[RF_FILTER_1] & ~0x0C) | (RF_Filter_Gain << 2);
+				CHK_ERROR(update_reg(state, RF_FILTER_1));
+				msleep(10);
+			}
+			CHK_ERROR(status);
+
+			state->m_Regs[RF_AGC_1] |=  0x08;
+			CHK_ERROR(update_reg(state, RF_AGC_1));
+		}
+
+		// ---------------------------------------------------------------------------------
+
+		state->m_Regs[IRQ_CLEAR] |= 0x80; // Reset IRQ
+		CHK_ERROR(update_reg(state, IRQ_CLEAR));
+
+		CHK_ERROR(PowerOn(state));
+
+		state->m_Regs[RF_FREQUENCY_1] = ((f >> 16) & 0xFF);
+		state->m_Regs[RF_FREQUENCY_2] = ((f >>  8) & 0xFF);
+		state->m_Regs[RF_FREQUENCY_3] = ((f      ) & 0xFF);
+		CHK_ERROR(update_regs(state, RF_FREQUENCY_1,RF_FREQUENCY_3));
+
+		state->m_Regs[MSM_1] = 0x41; // Tune
+		state->m_Regs[MSM_2] = 0x01; // Start MSM
+		CHK_ERROR(update_regs(state, MSM_1, MSM_2));
+		state->m_Regs[MSM_2] = 0x00;
+
+		while(true)
+		{
+			CHK_ERROR(read_reg(state, IRQ_STATUS, &IRQ));
+			if( (IRQ & 0x80) != 0 ) break;
+			Timeout -= 1;
+			if (Timeout == 0) {
+				status = -1;
+				break;
+			}
+			msleep(10);
+		}
+		CHK_ERROR(status);
+
+		// ---------------------------------------------------------------------------------
+
+		if( state->m_isMaster && StandardParams->m_LTO_STO_immune )
+		{
+			state->m_Regs[RF_AGC_1] &=  ~0x08;
+			CHK_ERROR(update_reg(state, RF_AGC_1));
+
+			msleep(50);
+
+			state->m_Regs[RF_FILTER_1] &= ~0x10;    // remove force
+			CHK_ERROR(update_reg(state, RF_FILTER_1));
+		}
+
+		// ---------------------------------------------------------------------------------
+		//  Spur reduction
+
+		if( Frequency < 72000000 )
+		{
+			state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
+		}
+		else if( Frequency < 104000000 )
+		{
+			state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
+		}
+		else if( Frequency < 120000000 )
+		{
+			state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
+		}
+		else
+		{
+			if( fDelta <= 8000000 )
+			{
+				if( fRatio & 1 ) state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
+				else             state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
+			}
+			else
+			{
+				if( fRatio & 1 ) state->m_Regs[REFERENCE] |= 0x40;  // Set digital clock
+				else             state->m_Regs[REFERENCE] &= ~0x40;  // Clear digital clock
+			}
+
+		}
+		CHK_ERROR(update_reg(state, REFERENCE));
+
+		if( StandardParams->m_AGC1_Freeze && state->m_bEnableFreeze )
+		{
+			u8 tmp;
+			int AGC1GainMin = 0;
+			int nSteps = 10;
+			int Step  = 0;
+
+			CHK_ERROR(read_reg(state, AGC1_2,&tmp));
+
+			if( (tmp & 0x80) == 0 )
+			{
+				state->m_Regs[AGC1_2] |= 0x80;         // Loop off
+				CHK_ERROR(update_reg(state, AGC1_2));
+				state->m_Regs[AGC1_2] |= 0x10 ;        // Force gain
+				CHK_ERROR(update_reg(state, AGC1_2));
+			}
+			// Adapt
+			if( state->m_Regs[AGC1_1] & 0x40 ) // AGC1_6_15dB set
+			{
+				AGC1GainMin = 6;
+				nSteps = 4;
+			}
+			while( Step < nSteps )
+			{
+				int Down = 0;
+				int Up = 0, i;
+				u8 AGC1_Gain;
+
+				Step = Step + 1;
+
+				for (i = 0; i < 40; i += 1) {
+					CHK_ERROR(read_reg(state, AGC_DET_OUT, &tmp));
+					Up   += (tmp & 0x02) ?  1 : -4;
+					Down += (tmp & 0x01) ? 14 : -1;
+					msleep(1);
+				}
+				CHK_ERROR(status);
+				AGC1_Gain = (state->m_Regs[AGC1_2] & 0x0F);
+				if( Up >= 15 && AGC1_Gain != 9 )
+				{
+					state->m_Regs[AGC1_2] = ( state->m_Regs[AGC1_2] & ~0x0F ) | (AGC1_Gain + 1);
+					CHK_ERROR(update_reg(state, AGC1_2));
+				}
+				else if ( Down >= 10 && AGC1_Gain != AGC1GainMin )
+				{
+					state->m_Regs[AGC1_2] = ( state->m_Regs[AGC1_2] & ~0x0F ) | (AGC1_Gain - 1);
+					CHK_ERROR(update_reg(state, AGC1_2));
+				}
+				else
+				{
+					Step = nSteps;
+				}
+			}
+		}
+		else
+		{
+			state->m_Regs[AGC1_2] &= ~0x10 ;       // unforce gain
+			CHK_ERROR(update_reg(state, AGC1_2));
+			state->m_Regs[AGC1_2] &= ~0x80;         // Loop on
+			CHK_ERROR(update_reg(state, AGC1_2));
+		}
+
+		state->m_Standard = Standard;
+		state->m_Frequency = Frequency;
+
+		if( state->m_bPowerMeasurement )
+			PowerMeasurement(state, &state->m_LastPowerLevel);
+	} while(0);
+
+	return status;
+}
+
+static int sleep(struct dvb_frontend* fe)
+{
+	struct tda_state *state = fe->tuner_priv;
+
+	Standby(state);
+	return 0;
+}
+
+static int init(struct dvb_frontend* fe)
+{
+	//struct tda_state *state = fe->tuner_priv;
+	return 0;
+}
+
+static int release(struct dvb_frontend* fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+#ifdef USE_API3
+static int set_params(struct dvb_frontend *fe,
+		      struct dvb_frontend_parameters *params)
+{
+	struct tda_state *state = fe->tuner_priv;
+	int status = 0;
+	int Standard;
+
+	state->m_Frequency = params->frequency;
+
+	if (fe->ops.info.type == FE_OFDM)
+		switch (params->u.ofdm.bandwidth) {
+		case BANDWIDTH_6_MHZ:
+			Standard = HF_DVBT_6MHZ;
+			break;
+		case BANDWIDTH_7_MHZ:
+			Standard = HF_DVBT_7MHZ;
+			break;
+		default:
+		case BANDWIDTH_8_MHZ:
+			Standard = HF_DVBT_8MHZ;
+			break;
+		}
+	else if (fe->ops.info.type == FE_QAM) {
+		Standard = HF_DVBC_8MHZ;
+	} else
+		return -EINVAL;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	SetFrequency(state, state->m_Frequency, Standard);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return status;
+}
+#else
+static int set_params(struct dvb_frontend *fe)
+{
+	struct tda_state *state = fe->tuner_priv;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	int status = 0;
+	int Standard;
+
+	state->m_Frequency = p->frequency;
+
+	if (p->delivery_system == SYS_DVBT)
+		switch (p->bandwidth_hz) {
+		case 6000000:
+			Standard = HF_DVBT_6MHZ;
+			break;
+		case 7000000:
+			Standard = HF_DVBT_7MHZ;
+			break;
+		default:
+		case 8000000:
+			Standard = HF_DVBT_8MHZ;
+			break;
+		}
+	else if (p->delivery_system == SYS_DVBC_ANNEX_A) {
+		Standard = HF_DVBC_8MHZ;
+	} else
+		return -EINVAL;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	SetFrequency(state, state->m_Frequency, Standard);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return status;
+}
+#endif
+
+static int get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tda_state *state = fe->tuner_priv;
+
+	*frequency = state->IF;
+	return 0;
+}
+
+static int get_rf_strength(struct dvb_frontend *fe, u16 *st)
+{
+	struct tda_state *state = fe->tuner_priv;
+
+	*st = state->m_LastPowerLevel;
+	return 0;
+}
+
+static int get_if(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct tda_state *state = fe->tuner_priv;
+
+	state->IF = 0;
+	if (state->m_Standard < HF_DVBT_6MHZ ||
+	    state->m_Standard > HF_DVBC_8MHZ)
+		return 0;
+	state->IF = m_StandardTable[state->m_Standard - HF_DVBT_6MHZ].m_IFFrequency;
+	*frequency = state->IF;
+	return 0;
+}
+
+static int get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)
+{
+	//struct tda_state *state = fe->tuner_priv;
+	//*bandwidth = priv->bandwidth;
+	return 0;
+}
+
+
+static struct dvb_tuner_ops tuner_ops = {
+	.info = {
+		.name = "NXP TDA18212",
+		.frequency_min  =  47125000,
+		.frequency_max  = 865000000,
+		.frequency_step =     62500
+	},
+	.init              = init,
+	.sleep             = sleep,
+	.set_params        = set_params,
+	.release           = release,
+	.get_frequency     = get_frequency,
+	.get_if_frequency  = get_if,
+	.get_bandwidth     = get_bandwidth,
+	.get_rf_strength   = get_rf_strength,
+};
+
+struct dvb_frontend *tda18212dd_attach(struct dvb_frontend *fe,
+				       struct i2c_adapter *i2c, u8 adr)
+{
+	struct tda_state *state;
+	int stat;
+
+	state = kzalloc(sizeof(struct tda_state), GFP_KERNEL);
+	if (!state)
+		return NULL;
+	state->adr = adr;
+	state->i2c = i2c;
+	memcpy(&fe->ops.tuner_ops, &tuner_ops, sizeof(struct dvb_tuner_ops));
+	init_state(state);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+	stat = attach_init(state);
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+	if (stat < 0) {
+		kfree(state);
+		return 0;
+	}
+	fe->tuner_priv = state;
+	return fe;
+}
+
+EXPORT_SYMBOL_GPL(tda18212dd_attach);
+MODULE_DESCRIPTION("TDA18212 driver");
+MODULE_AUTHOR("DD");
+MODULE_LICENSE("GPL");
+
+/*
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
diff -urN linux-3.4.3/drivers/media/dvb/frontends/tda18212dd.h linux-3.4.3.dd/drivers/media/dvb/frontends/tda18212dd.h
--- linux-3.4.3/drivers/media/dvb/frontends/tda18212dd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/frontends/tda18212dd.h	2012-06-18 22:32:12.574032210 +0200
@@ -0,0 +1,5 @@
+#ifndef _TDA18212DD_H_
+#define _TDA18212DD_H_
+struct dvb_frontend *tda18212dd_attach(struct dvb_frontend *fe,
+				       struct i2c_adapter *i2c, u8 adr);
+#endif
diff -urN linux-3.4.3/drivers/media/dvb/ngene/Kconfig linux-3.4.3.dd/drivers/media/dvb/ngene/Kconfig
--- linux-3.4.3/drivers/media/dvb/ngene/Kconfig	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/Kconfig	2012-06-18 22:31:48.134032196 +0200
@@ -7,6 +7,8 @@
 	select DVB_LGDT330X if !DVB_FE_CUSTOMISE
 	select DVB_DRXK if !DVB_FE_CUSTOMISE
 	select DVB_TDA18271C2DD if !DVB_FE_CUSTOMISE
+	select DVB_STV0367DD if !DVB_FE_CUSTOMISE
+	select DVB_TDA18212DD if !DVB_FE_CUSTOMISE
 	select MEDIA_TUNER_MT2131 if !MEDIA_TUNER_CUSTOMISE
 	---help---
 	  Support for Micronas PCI express cards with nGene bridge.
diff -urN linux-3.4.3/drivers/media/dvb/ngene/Makefile linux-3.4.3.dd/drivers/media/dvb/ngene/Makefile
--- linux-3.4.3/drivers/media/dvb/ngene/Makefile	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/Makefile	2012-06-18 22:31:48.134032196 +0200
@@ -2,7 +2,8 @@
 # Makefile for the nGene device driver
 #
 
-ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-dvb.o
+ngene-objs := ngene-core.o ngene-i2c.o ngene-cards.o ngene-av.o \
+	ngene-eeprom.o ngene-dvb.o
 
 obj-$(CONFIG_DVB_NGENE) += ngene.o
 
@@ -11,4 +12,4 @@
 ccflags-y += -Idrivers/media/common/tuners/
 
 # For the staging CI driver cxd2099
-ccflags-y += -Idrivers/staging/media/cxd2099/
+ccflags-y += -Idrivers/staging/cxd2099/
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-av.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-av.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-av.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-av.c	2012-06-18 23:36:32.184034187 +0200
@@ -0,0 +1,349 @@
+/*
+ * ngene-av.c: nGene PCIe bridge driver - DVB video/audio support
+ *
+ * Copyright (C) 2005-2007 Micronas
+ *
+ * Copyright (C) 2008-2009 Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Modifications for new nGene firmware,
+ *                         support for EEPROM-copying,
+ *                         support for new dual DVB-S2 card prototype
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* This file provides the support functions for DVB audio/video devices
+   (/dev/dvb/adapter0/[video|audio]), not to be confused with V4L2 support */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/io.h>
+#include <asm/div64.h>
+#include <linux/pci.h>
+#include <linux/timer.h>
+#include <linux/version.h>
+#include <linux/byteorder/generic.h>
+#include <linux/firmware.h>
+#include <linux/vmalloc.h>
+#include "linux/compat.h"
+
+#include "ngene.h"
+
+#if 0
+
+static void *ain_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
+{
+	struct ngene_channel *chan = priv;
+	struct ngene *dev = chan->dev;
+
+	if (dvb_ringbuffer_free(&dev->ain_rbuf) >= len) {
+		dvb_ringbuffer_write(&dev->ain_rbuf, buf, len);
+		wake_up_interruptible(&dev->ain_rbuf.queue);
+	} else
+		printk(KERN_INFO DEVICE_NAME ": Dropped ain packet.\n");
+
+	return 0;
+}
+
+static void *vcap_exchange(void *priv, void *buf, u32 len, u32 clock, u32 flags)
+{
+
+	struct ngene_channel *chan = priv;
+	struct ngene *dev = chan->dev;
+
+	if (len >= 1920 * 1080)
+		len = 1920 * 1080;
+	if (dvb_ringbuffer_free(&dev->vin_rbuf) >= len) {
+		dvb_ringbuffer_write(&dev->vin_rbuf, buf, len);
+		wake_up_interruptible(&dev->vin_rbuf.queue);
+	} else {
+		;/*printk(KERN_INFO DEVICE_NAME ": Dropped vcap packet.\n"); */
+	}
+	return 0;
+}
+
+static ssize_t audio_write(struct file *file,
+			   const char *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+ssize_t audio_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int left;
+	int avail;
+
+	left = count;
+	while (left) {
+		if (wait_event_interruptible(
+				dev->ain_rbuf.queue,
+				dvb_ringbuffer_avail(&dev->ain_rbuf) > 0) < 0)
+			return -EAGAIN;
+		avail = dvb_ringbuffer_avail(&dev->ain_rbuf);
+		if (avail > left)
+			avail = left;
+		dvb_ringbuffer_read_user(&dev->ain_rbuf, buf, avail);
+		left -= avail;
+		buf += avail;
+	}
+	return count;
+}
+
+static int audio_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	struct ngene_channel *chan2 = &chan->dev->channel[2];
+	int ret;
+
+	ret = dvb_generic_open(inode, file);
+	if (ret < 0)
+		return ret;
+	dvb_ringbuffer_flush(&dev->ain_rbuf);
+
+	chan2->Capture1Length = MAX_AUDIO_BUFFER_SIZE;
+	chan2->pBufferExchange = ain_exchange;
+	ngene_command_stream_control(chan2->dev, chan2->number, 0x80,
+				     SMODE_AUDIO_CAPTURE, 0);
+	return ret;
+}
+
+static int audio_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	struct ngene_channel *chan2 = &chan->dev->channel[2];
+
+	ngene_command_stream_control(dev, 2, 0, 0, 0);
+	chan2->pBufferExchange = 0;
+
+	return dvb_generic_release(inode, file);
+}
+
+static const struct file_operations audio_fops = {
+	.owner   = THIS_MODULE,
+	.read    = audio_read,
+	.write   = audio_write,
+	.open    = audio_open,
+	.release = audio_release,
+};
+
+static struct dvb_device dvbdev_audio = {
+	.priv    = 0,
+	.readers = -1,
+	.writers = 1,
+	.users   = 1,
+	.fops    = &audio_fops,
+};
+
+static int video_open(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	struct ngene_channel *chan0 = &chan->dev->channel[0];
+	int ret;
+
+	ret = dvb_generic_open(inode, file);
+	if (ret < 0)
+		return ret;
+	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
+		return ret;
+	dvb_ringbuffer_flush(&dev->vin_rbuf);
+
+	chan0->nBytesPerLine = 1920 * 2;
+	chan0->nLines = 540;
+	chan0->Capture1Length = 1920 * 2 * 540;
+	chan0->pBufferExchange = vcap_exchange;
+	chan0->itumode = 2;
+	ngene_command_stream_control(chan0->dev, chan0->number,
+				     0x80, SMODE_VIDEO_CAPTURE, 0);
+	return ret;
+}
+
+static int video_release(struct inode *inode, struct file *file)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	struct ngene_channel *chan0 = &chan->dev->channel[0];
+
+	ngene_command_stream_control(dev, 0, 0, 0, 0);
+	chan0->pBufferExchange = 0;
+
+	return dvb_generic_release(inode, file);
+}
+
+static ssize_t video_write(struct file *file,
+			   const char *buf, size_t count, loff_t *ppos)
+{
+	return -EINVAL;
+}
+
+ssize_t video_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int left, avail;
+
+	left = count;
+	while (left) {
+		if (wait_event_interruptible(
+				dev->vin_rbuf.queue,
+				dvb_ringbuffer_avail(&dev->vin_rbuf) > 0) < 0)
+			return -EAGAIN;
+		avail = dvb_ringbuffer_avail(&dev->vin_rbuf);
+		if (avail > left)
+			avail = left;
+		dvb_ringbuffer_read_user(&dev->vin_rbuf, buf, avail);
+		left -= avail;
+		buf += avail;
+	}
+	return count;
+}
+
+/* Why is this not exported from dvb_core ?!?! */
+
+static int dvb_usercopy2(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg,
+			 int (*func)(struct inode *inode, struct file *file,
+				     unsigned int cmd, void *arg))
+{
+	char sbuf[128];
+	void *mbuf = NULL;
+	void *parg = NULL;
+	int  err   = -EINVAL;
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		/*
+		 * For this command, the pointer is actually an integer
+		 * argument.
+		 */
+		parg = (void *)arg;
+		break;
+	case _IOC_READ: /* some v4l ioctls are marked wrong ... */
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		err = -EFAULT;
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto out;
+		break;
+	}
+
+	/* call driver */
+	err = func(inode, file, cmd, parg);
+	if (err == -ENOIOCTLCMD)
+		err = -EINVAL;
+
+	if (err < 0)
+		goto out;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			err = -EFAULT;
+		break;
+	}
+
+out:
+	kfree(mbuf);
+	return err;
+}
+
+static int video_do_ioctl(struct inode *inode, struct file *file,
+			  unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int ret = 0;
+	unsigned long arg = (unsigned long)parg;
+
+	switch (cmd) {
+	case VIDEO_SET_STREAMTYPE:
+		switch (arg) {
+		case VIDEO_CAP_MPEG2:
+			/* printk(KERN_INFO DEVICE_NAME ": setting MPEG2\n"); */
+			send_cli(dev, "vdec mpeg2\n");
+			break;
+		case VIDEO_CAP_AVC:
+			/* printk(KERN_INFO DEVICE_NAME ": setting H264\n"); */
+			send_cli(dev, "vdec h264\n");
+			break;
+		case VIDEO_CAP_VC1:
+			/* printk(KERN_INFO DEVICE_NAME ": setting VC1\n"); */
+			send_cli(dev, "vdec vc1\n");
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		break;
+	default:
+		ret = -ENOIOCTLCMD;
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int video_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	return dvb_usercopy2(inode, file, cmd, arg, video_do_ioctl);
+}
+
+static const struct file_operations video_fops = {
+	.owner   = THIS_MODULE,
+	.read    = video_read,
+	.write   = video_write,
+	.open    = video_open,
+	.release = video_release,
+	.ioctl   = video_ioctl,
+};
+
+static struct dvb_device dvbdev_video = {
+	.priv    = 0,
+	.readers = -1,
+	.writers = 1,
+	.users   = -1,
+	.fops    = &video_fops,
+};
+#endif
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-cards.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-cards.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-cards.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-cards.c	2012-06-18 23:34:56.714034137 +0200
@@ -31,6 +31,7 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/pci_ids.h>
+#include "linux/compat.h"
 
 #include "ngene.h"
 
@@ -42,6 +43,8 @@
 #include "mt2131.h"
 #include "tda18271c2dd.h"
 #include "drxk.h"
+#include "tda18212dd.h"
+#include "stv0367dd.h"
 
 
 /****************************************************************************/
@@ -84,8 +87,98 @@
 	return 0;
 }
 
+#if 0
+static int tuner_attach_mt2060(struct ngene_channel *chan)
+{
+	struct ngene *dev = chan->dev;
+	void *tconf = dev->card_info->tuner_config[chan->number];
+	u8 drxa = dev->card_info->demoda[chan->number];
+	struct dvb_frontend *fe = chan->fe, *fe2;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	fe->misc_priv = chan;
+#else
+	fe->sec_priv = chan;
+#endif
+	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
+
+	dev->card_info->gate_ctrl(fe, 1);
+	fe2 = mt2060_attach(fe, &chan->i2c_adapter, tconf, 1220);
+	dev->card_info->gate_ctrl(fe, 0);
+
+	i2c_write_register(&chan->i2c_adapter, drxa, 3, 4);
+	write_demod(&chan->i2c_adapter, drxa, 0x1012, 15);
+	write_demod(&chan->i2c_adapter, drxa, 0x1007, 0xc27);
+	write_demod(&chan->i2c_adapter, drxa, 0x0020, 0x003);
+
+	return fe2 ? 0 : -ENODEV;
+}
+
+static int tuner_attach_xc3028(struct ngene_channel *chan)
+{
+	struct ngene *dev = chan->dev;
+	void *tconf = dev->card_info->tuner_config[chan->number];
+	struct dvb_frontend *fe = chan->fe, *fe2;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	fe->misc_priv = chan;
+#else
+	fe->sec_priv = chan;
+#endif
+	fe->ops.i2c_gate_ctrl = dev->card_info->gate_ctrl;
+
+	dev->card_info->gate_ctrl(fe, 1);
+	fe2 = xc3028_attach(fe, &chan->i2c_adapter, tconf);
+	dev->card_info->gate_ctrl(fe, 0);
+
+	/*chan->fe->ops.tuner_ops.set_frequency(chan->fe,231250000);*/
+
+	return fe2 ? 0 : -ENODEV;
+}
+
+static int demod_attach_drxd(struct ngene_channel *chan)
+{
+	void *feconf = chan->dev->card_info->fe_config[chan->number];
+
+	chan->fe = drxd_attach(feconf,
+			       chan, &chan->i2c_adapter,
+			       &chan->dev->pci_dev->dev);
+	return (chan->fe) ? 0 : -ENODEV;
+}
+
+static int demod_attach_drxh(struct ngene_channel *chan)
+{
+	void *feconf = chan->dev->card_info->fe_config[chan->number];
+
+	chan->fe = drxh_attach(feconf, chan,
+			       &chan->i2c_adapter, &chan->dev->pci_dev->dev);
+	return (chan->fe) ? 0 : -ENODEV;
+}
+
+static int demod_attach_stb0899(struct ngene_channel *chan)
+{
+	void *feconf = chan->dev->card_info->fe_config[chan->number];
+
+	chan->fe = stb0899_attach(feconf,
+				  chan, &chan->i2c_adapter,
+				  &chan->dev->pci_dev->dev);
+	if (chan->fe) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+		chan->set_tone = chan->fe->ops->set_tone;
+		chan->fe->ops->set_tone = lnbh21_set_tone;
+		chan->fe->ops->set_voltage = lnbh21_set_voltage;
+#else
+		chan->set_tone = chan->fe->ops.set_tone;
+		chan->fe->ops.set_tone = lnbh21_set_tone;
+		chan->fe->ops.set_voltage = lnbh21_set_voltage;
+#endif
+	}
+
+	return (chan->fe) ? 0 : -ENODEV;
+}
+#endif
 
-static int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)
+static int locked_gate_ctrl(struct dvb_frontend *fe, int enable)
 {
 	struct ngene_channel *chan = fe->sec_priv;
 	int status;
@@ -119,12 +212,29 @@
 	return 0;
 }
 
+static int tuner_attach_tda18212dd(struct ngene_channel *chan)
+{
+	struct i2c_adapter *i2c;
+	struct dvb_frontend *fe;
+
+	i2c = &chan->dev->channel[0].i2c_adapter;
+	fe = dvb_attach(tda18212dd_attach, chan->fe, i2c,
+			(chan->number & 1) ? 0x63 : 0x60);
+	if (!fe) {
+		printk(KERN_ERR "No TDA18212 found!\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
 static int tuner_attach_probe(struct ngene_channel *chan)
 {
 	if (chan->demod_type == 0)
 		return tuner_attach_stv6110(chan);
 	if (chan->demod_type == 1)
 		return tuner_attach_tda18271(chan);
+	if (chan->demod_type == 2)
+		return tuner_attach_tda18212dd(chan);
 	return -EINVAL;
 }
 
@@ -216,17 +326,51 @@
 	struct drxk_config config;
 
 	memset(&config, 0, sizeof(config));
-	config.microcode_name = "drxk_a3.mc";
 	config.adr = 0x29 + (chan->number ^ 2);
+	config.microcode_name = "drxk_a3.mc";
 
+#ifdef USE_API3
+	chan->fe = dvb_attach(drxk_attach, &config, i2c, &chan->fe2);
+#else
 	chan->fe = dvb_attach(drxk_attach, &config, i2c);
+#endif
 	if (!chan->fe) {
 		printk(KERN_ERR "No DRXK found!\n");
 		return -ENODEV;
 	}
 	chan->fe->sec_priv = chan;
 	chan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;
-	chan->fe->ops.i2c_gate_ctrl = drxk_gate_ctrl;
+	chan->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
+	return 0;
+}
+
+static int port_has_stv0367(struct i2c_adapter *i2c, int port)
+{
+	u8 val;
+
+	if (i2c_read_reg16(i2c, 0x1c + (port ^ 1), 0xf000, &val) < 0)
+		return 0;
+	if (val != 0x60)
+		return 0;
+	return 1;
+}
+
+static int demod_attach_stv0367dd(struct ngene_channel *chan,
+				  struct i2c_adapter *i2c)
+{
+	struct stv0367_cfg cfg;
+
+	memset(&cfg, 0, sizeof cfg);
+	cfg.adr = 0x1c + (chan->number ^ 1);
+
+	chan->fe = dvb_attach(stv0367_attach, i2c, &cfg, &chan->fe2);
+	if (!chan->fe) {
+		printk(KERN_ERR "No stv0367 found!\n");
+		return -ENODEV;
+	}
+	chan->fe->sec_priv = chan;
+	chan->gate_ctrl = chan->fe->ops.i2c_gate_ctrl;
+	chan->fe->ops.i2c_gate_ctrl = locked_gate_ctrl;
 	return 0;
 }
 
@@ -276,6 +420,9 @@
 	} else if (port_has_drxk(i2c, chan->number^2)) {
 		chan->demod_type = 1;
 		demod_attach_drxk(chan, i2c);
+	} else if (port_has_stv0367(i2c, chan->number)) {
+		chan->demod_type = 2;
+		demod_attach_stv0367dd(chan, i2c);
 	} else {
 		printk(KERN_ERR "No demod found on chan %d\n", chan->number);
 		return -ENODEV;
@@ -316,6 +463,136 @@
 /* Switch control (I2C gates, etc.) *****************************************/
 /****************************************************************************/
 
+#if 0
+static int avf_output(struct ngene_channel *chan, int state)
+{
+	if (chan->dev->card_info->avf[chan->number])
+		i2c_write_register(&chan->i2c_adapter,
+				   chan->dev->card_info->avf[chan->number],
+				   0xf2, state ? 0x89 : 0x80);
+	return 0;
+}
+
+/* Viper expander: sw11,sw12,sw21,sw22,i2csw1,i2csw2,tsen1,tsen2 */
+
+static int exp_set(struct ngene *dev)
+{
+	return i2c_write(&dev->channel[0].i2c_adapter,
+			 dev->card_info->exp, dev->exp_val);
+}
+
+static int exp_init(struct ngene *dev)
+{
+	if (!dev->card_info->exp)
+		return 0;
+	dev->exp_val = dev->card_info->exp_init;
+	return exp_set(dev);
+}
+
+static int exp_set_bit(struct ngene *dev, int bit, int val)
+{
+	if (val)
+		set_bit(bit, &dev->exp_val);
+	else
+		clear_bit(bit, &dev->exp_val);
+	return exp_set(dev);
+}
+
+static int viper_switch_ctrl(struct ngene_channel *chan, int type, int val)
+{
+	switch (type) {
+	case 0: /* I2C tuner gate on/off */
+		return exp_set_bit(chan->dev, 4 + chan->number, val);
+	case 1: /* Stream: 0=TS 1=ITU */
+		avf_output(chan, val);
+		return exp_set_bit(chan->dev, 6 + chan->number, val);
+	case 2: /* Input: 0=digital 1=analog antenna input */
+		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
+		exp_set_bit(chan->dev, 1 + chan->number * 2, val ? 1 : 0);
+		break;
+	}
+	return 0;
+}
+
+static int viper_switch_ctrl2(struct ngene_channel *chan, int type, int val)
+{
+	switch (type) {
+	case 0: /* I2C tuner gate on/off */
+		return exp_set_bit(chan->dev, 4 + chan->number, val);
+	case 1: /* Stream: 0=TS 1=ITU */
+		avf_output(chan, val);
+		return exp_set_bit(chan->dev, 6 + chan->number, val);
+	case 2: /* Input: 0=digital 1=analog antenna input */
+		exp_set_bit(chan->dev, 0 + chan->number * 2, val ? 0 : 1);
+		exp_set_bit(chan->dev, 1 + chan->number * 2, 0);
+		break;
+	}
+	return 0;
+}
+
+static int viper_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	struct ngene_channel *chan = fe->misc_priv;
+#else /* Why is there no misc_priv available anymore !?!?! */
+	/* Well, just abuse sec :-) */
+	struct ngene_channel *chan = fe->sec_priv;
+#endif
+	struct ngene *dev = chan->dev;
+
+	return dev->card_info->switch_ctrl(chan, 0, enable);
+}
+
+static int python_switch_ctrl(struct ngene_channel *chan, int type, int val)
+{
+	switch (type) {
+	case 0: /* I2C tuner gate on/off */
+		if (chan->number > 1)
+			return -EINVAL;
+		return ngene_command_gpio_set(chan->dev, 3 + chan->number, val);
+	case 1: /* Stream: 0=TS 1=ITU */
+		avf_output(chan, val);
+		return 0;
+	}
+	return 0;
+}
+
+static int viper_reset_xc(struct dvb_frontend *fe)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	struct ngene_channel *chan = fe->misc_priv;
+#else
+	struct ngene_channel *chan = fe->sec_priv;
+#endif
+	struct ngene *dev = chan->dev;
+
+	printk(KERN_INFO DEVICE_NAME ": Reset XC3028\n");
+
+	if (chan->number > 1)
+		return -EINVAL;
+
+	ngene_command_gpio_set(dev, 3 + chan->number, 0);
+	msleep(150);
+	ngene_command_gpio_set(dev, 3 + chan->number, 1);
+	return 0;
+}
+
+static int python_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	struct ngene_channel *chan = fe->misc_priv;
+#else /* Why is there no misc_priv available anymore !?!?! */
+	struct ngene_channel *chan = fe->sec_priv;
+#endif
+	struct ngene *dev = chan->dev;
+
+	if (chan->number == 0)
+		return ngene_command_gpio_set(dev, 3, enable);
+	if (chan->number == 1)
+		return ngene_command_gpio_set(dev, 4, enable);
+	return -EINVAL;
+}
+#endif
 
 static struct stv090x_config fe_cineS2 = {
 	.device         = STV0900,
@@ -465,6 +742,323 @@
 
 /****************************************************************************/
 
+#if 0
+static struct drxd_config fe_terratec_dvbt_0 = {
+	.index          = 0,
+	.demod_address  = 0x70,
+	.demod_revision = 0xa2,
+	.demoda_address = 0x00,
+	.pll_address    = 0x60,
+	.pll_type       = DRXD_PLL_DTT7520X,
+	.clock          = 20000,
+	.pll_set        = ngene_pll_set_th_dtt7520x,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct drxd_config fe_terratec_dvbt_1 = {
+	.index          = 1,
+	.demod_address  = 0x71,
+	.demod_revision = 0xa2,
+	.demoda_address = 0x00,
+	.pll_address    = 0x60,
+	.pll_type       = DRXD_PLL_DTT7520X,
+	.clock          = 20000,
+	.pll_set        = ngene_pll_set_th_dtt7520x,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct ngene_info ngene_info_terratec = {
+	.type           = NGENE_TERRATEC,
+	.name           = "Terratec Integra/Cinergy2400i Dual DVB-T",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
+	.fe_config      = {&fe_terratec_dvbt_0, &fe_terratec_dvbt_1},
+	.i2c_access     = 1,
+};
+
+/****************************************************************************/
+
+static struct mt2060_config tuner_python_0 = {
+	.i2c_address    = 0x60,
+	.clock_out      = 3,
+	.input          = 0
+};
+
+static struct mt2060_config tuner_python_1 = {
+	.i2c_address    = 0x61,
+	.clock_out      = 3,
+	.input          = 1
+};
+
+static struct drxd_config fe_python_0 = {
+	.index          = 0,
+	.demod_address  = 0x71,
+	.demod_revision = 0xb1,
+	.demoda_address = 0x41,
+	.clock          = 16000,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct drxd_config fe_python_1 = {
+	.index          = 1,
+	.demod_address  = 0x70,
+	.demod_revision = 0xb1,
+	.demoda_address = 0x45,
+	.clock          = 16000,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct ngene_info ngene_info_python = {
+	.type           = NGENE_PYTHON,
+	.name           = "Micronas MicPython/Hedgehog Dual DVB-T",
+	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_AIN, NGENE_IO_AIN},
+	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
+	.tuner_attach   = {tuner_attach_mt2060, tuner_attach_mt2060},
+	.fe_config      = {&fe_python_0, &fe_python_1},
+	.tuner_config   = {&tuner_python_0, &tuner_python_1},
+	.avf            = {0x43, 0x47},
+	.msp            = {0x40, 0x42},
+	.demoda         = {0x41, 0x45},
+	.gate_ctrl      = python_gate_ctrl,
+	.switch_ctrl    = python_switch_ctrl,
+};
+
+/****************************************************************************/
+
+static struct drxd_config fe_appb_dvbt_0 = {
+	.index          = 0,
+	.demod_address  = 0x71,
+	.demod_revision = 0xa2,
+	.demoda_address = 0x41,
+	.pll_address    = 0x63,
+	.pll_type       = DRXD_PLL_MT3X0823,
+	.clock          = 20000,
+	.pll_set        = ngene_pll_set_mt_3x0823,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct drxd_config fe_appb_dvbt_1 = {
+	.index          = 1,
+	.demod_address  = 0x70,
+	.demod_revision = 0xa2,
+	.demoda_address = 0x45,
+	.pll_address    = 0x60,
+	.pll_type       = DRXD_PLL_MT3X0823,
+	.clock          = 20000,
+	.pll_set        = ngene_pll_set_mt_3x0823,
+	.osc_deviation  = osc_deviation,
+};
+
+static struct ngene_info ngene_info_appboard = {
+	.type           = NGENE_APP,
+	.name           = "Micronas Application Board Dual DVB-T",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
+	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
+	.avf            = {0x43, 0x47},
+};
+
+static struct ngene_info ngene_info_appboard_ntsc = {
+	.type           = NGENE_APP,
+	.name           = "Micronas Application Board Dual DVB-T",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_drxd, demod_attach_drxd},
+	.fe_config      = {&fe_appb_dvbt_0, &fe_appb_dvbt_1},
+	.avf            = {0x43, 0x47},
+	.ntsc           = 1,
+};
+
+/****************************************************************************/
+
+static struct stb0899_config fe_sidewinder_0 = {
+	.demod_address  = 0x68,
+	.pll_address    = 0x63,
+};
+
+static struct stb0899_config fe_sidewinder_1 = {
+	.demod_address  = 0x6b,
+	.pll_address    = 0x60,
+};
+
+static struct ngene_info ngene_info_sidewinder = {
+	.type           = NGENE_SIDEWINDER,
+	.name           = "Micronas MicSquirrel/Sidewinder Dual DVB-S2",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_stb0899, demod_attach_stb0899},
+	.fe_config      = {&fe_sidewinder_0, &fe_sidewinder_1},
+	.lnb            = {0x0b, 0x08},
+};
+
+/****************************************************************************/
+/* Yet unnamed S2 card with dual DVB-S2 demod                               */
+/****************************************************************************/
+
+static struct stv0900_config fe_s2_0 = {
+	.addr           = 0x68,
+	.pll            = 0x63,
+	.pll_type       = 0,
+	.nr             = 0,
+};
+
+static struct stv0900_config fe_s2_1 = {
+	.addr           = 0x68,
+	.pll            = 0x60,
+	.pll_type       = 0,
+	.nr             = 1,
+};
+
+static struct ngene_info ngene_info_s2 = {
+	.type           = NGENE_SIDEWINDER,
+	.name           = "S2",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
+			   NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
+	.fe_config      = {&fe_s2_0, &fe_s2_1},
+	.lnb            = {0x0b, 0x08},
+	.tsf            = {3, 3},
+	.fw_version     = 15,
+};
+
+static struct stv0900_config fe_s2b_0 = {
+	.addr           = 0x68,
+	.pll            = 0x60,
+	.pll_type       = 0x10,
+	.nr             = 0,
+};
+
+static struct stv0900_config fe_s2b_1 = {
+	.addr           = 0x68,
+	.pll            = 0x63,
+	.pll_type       = 0x10,
+	.nr             = 1,
+};
+
+static struct ngene_info ngene_info_s2_b = {
+	.type           = NGENE_SIDEWINDER,
+	.name           = "S2 V2",
+	.io_type        = {NGENE_IO_TSIN, NGENE_IO_TSIN,
+			   NGENE_IO_TSIN, NGENE_IO_TSIN},
+	.demod_attach   = {demod_attach_stv0900, demod_attach_stv0900},
+	.fe_config      = {&fe_s2b_0, &fe_s2b_1},
+	.lnb            = {0x0b, 0x08},
+	.tsf            = {3, 3},
+	.fw_version     = 17,
+};
+
+/****************************************************************************/
+
+static struct xc3028_config tuner_viper_0 = {
+	.adr            = 0x61,
+	.reset          = viper_reset_xc
+};
+
+static struct xc3028_config tuner_viper_1 = {
+	.adr            = 0x64,
+	.reset          = viper_reset_xc
+};
+
+static struct drxh_config fe_viper_h_0 = {.adr = 0x2b};
+
+static struct drxh_config fe_viper_h_1 = {.adr = 0x29};
+
+static struct drxh_config fe_viper_l_0 = {.adr = 0x2b, .type = 3931};
+
+static struct drxh_config fe_viper_l_1 = {.adr = 0x29, .type = 3931};
+
+static struct ngene_info ngene_info_viper_v1 = {
+	.type           = NGENE_VIPER,
+	.name           = "Micronas MicViper Dual ATSC DRXH",
+	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_AIN, NGENE_IO_AIN},
+	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
+	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
+	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
+	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
+	.avf            = {0x43, 0x47},
+	.msp            = {0x40, 0x42},
+	.exp            = 0x20,
+	.exp_init       = 0xf5,
+	.gate_ctrl      = viper_gate_ctrl,
+	.switch_ctrl    = viper_switch_ctrl,
+	.tsf            = {2, 2},
+};
+
+static struct ngene_info ngene_info_viper_v2 = {
+	.type           = NGENE_VIPER,
+	.name           = "Micronas MicViper Dual ATSC DRXL",
+	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_AIN, NGENE_IO_AIN},
+	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
+	.fe_config      = {&fe_viper_l_0, &fe_viper_l_1},
+	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
+	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
+	.avf            = {0x43, 0x47},
+	.msp            = {0x40, 0x42},
+	.exp            = 0x38,
+	.exp_init       = 0xf5,
+	.gate_ctrl      = viper_gate_ctrl,
+	.switch_ctrl    = viper_switch_ctrl,
+	.tsf            = {2, 2},
+};
+
+/****************************************************************************/
+
+static struct ngene_info ngene_info_vbox_v1 = {
+	.type           = NGENE_VBOX_V1,
+	.name           = "VBox Cat's Eye 164E",
+	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_AIN, NGENE_IO_AIN},
+	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
+	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
+	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
+	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
+	.avf            = {0x43, 0x47},
+	.msp            = {0x40, 0x42},
+	.exp            = 0x20,
+	.exp_init       = 0xf5,
+	.gate_ctrl      = viper_gate_ctrl,
+	.switch_ctrl    = viper_switch_ctrl,
+	.tsf            = {2, 2},
+};
+
+/****************************************************************************/
+
+static struct ngene_info ngene_info_vbox_v2 = {
+	.type           = NGENE_VBOX_V2,
+	.name           = "VBox Cat's Eye 164E",
+	.io_type        = {NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_TSIN | NGENE_IO_TV,
+			   NGENE_IO_AIN, NGENE_IO_AIN},
+	.demod_attach   = {demod_attach_drxh, demod_attach_drxh},
+	.fe_config      = {&fe_viper_h_0, &fe_viper_h_1},
+	.tuner_config   = {&tuner_viper_0, &tuner_viper_1},
+	.tuner_attach   = {tuner_attach_xc3028, tuner_attach_xc3028},
+	.avf            = {0x43, 0x47},
+	.msp            = {0x40, 0x42},
+	.exp            = 0x20,
+	.exp_init       = 0xf5,
+	.gate_ctrl      = viper_gate_ctrl,
+	.switch_ctrl    = viper_switch_ctrl2,
+	.tsf            = {2, 2},
+};
+
+/****************************************************************************/
+
+static struct ngene_info ngene_info_racer = {
+	.type           = NGENE_RACER,
+	.name           = "Micronas MicRacer HDTV Decoder Card",
+	.io_type        = {NGENE_IO_HDTV, NGENE_IO_NONE,
+			   NGENE_IO_AIN, NGENE_IO_NONE,
+			   NGENE_IO_TSOUT},
+	.i2s            = {0, 0, 1, 0},
+	.fw_version     = 17,
+};
+#endif
 
 
 /****************************************************************************/
@@ -479,6 +1073,8 @@
 /****************************************************************************/
 
 static const struct pci_device_id ngene_id_tbl[] __devinitdata = {
+	NGENE_ID(0x18c3, 0xab04, ngene_info_cineS2),
+	NGENE_ID(0x18c3, 0xab05, ngene_info_cineS2v5),
 	NGENE_ID(0x18c3, 0xabc3, ngene_info_cineS2),
 	NGENE_ID(0x18c3, 0xabc4, ngene_info_cineS2),
 	NGENE_ID(0x18c3, 0xdb01, ngene_info_satixS2),
@@ -487,6 +1083,32 @@
 	NGENE_ID(0x18c3, 0xdd10, ngene_info_duoFlex),
 	NGENE_ID(0x18c3, 0xdd20, ngene_info_duoFlex),
 	NGENE_ID(0x1461, 0x062e, ngene_info_m780),
+#if 0 /* not (yet?) supported */
+	NGENE_ID(0x18c3, 0x0000, ngene_info_appboard),
+	NGENE_ID(0x18c3, 0x0004, ngene_info_appboard),
+	NGENE_ID(0x18c3, 0x8011, ngene_info_appboard),
+	NGENE_ID(0x18c3, 0x8015, ngene_info_appboard_ntsc),
+	NGENE_ID(0x153b, 0x1167, ngene_info_terratec),
+	NGENE_ID(0x18c3, 0x0030, ngene_info_python),
+	NGENE_ID(0x18c3, 0x0052, ngene_info_sidewinder),
+	NGENE_ID(0x18c3, 0x8f00, ngene_info_racer),
+	NGENE_ID(0x18c3, 0x0041, ngene_info_viper_v1),
+	NGENE_ID(0x18c3, 0x0042, ngene_info_viper_v2),
+	NGENE_ID(0x14f3, 0x0041, ngene_info_vbox_v1),
+	NGENE_ID(0x14f3, 0x0043, ngene_info_vbox_v2),
+	NGENE_ID(0x18c3, 0xabcd, ngene_info_s2),
+	NGENE_ID(0x18c3, 0xabc2, ngene_info_s2_b),
+	NGENE_ID(0x18c3, 0xabc3, ngene_info_s2_b),
+	NGENE_ID(0x18c3, 0x0001, ngene_info_appboard),
+	NGENE_ID(0x18c3, 0x0005, ngene_info_appboard),
+	NGENE_ID(0x18c3, 0x0009, ngene_info_appboard_atsc),
+	NGENE_ID(0x18c3, 0x000b, ngene_info_appboard_atsc),
+	NGENE_ID(0x18c3, 0x0010, ngene_info_shrek_50_fp),
+	NGENE_ID(0x18c3, 0x0011, ngene_info_shrek_60_fp),
+	NGENE_ID(0x18c3, 0x0012, ngene_info_shrek_50),
+	NGENE_ID(0x18c3, 0x0013, ngene_info_shrek_60),
+	NGENE_ID(0x18c3, 0x0000, ngene_info_hognose),
+#endif
 	{0}
 };
 MODULE_DEVICE_TABLE(pci, ngene_id_tbl);
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-core.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-core.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-core.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-core.c	2012-06-18 23:29:28.584033969 +0200
@@ -38,6 +38,7 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
+#include "linux/compat.h"
 
 #include "ngene.h"
 
@@ -86,6 +87,14 @@
 		if ((Event.UARTStatus & 0x02) && (dev->RxEventNotify))
 			dev->RxEventNotify(dev, Event.TimeStamp,
 					   Event.RXCharacter);
+#if 0
+		if ((Event.GPIOStatus & 0x80) && (dev->Gpio2EventNotify))
+			dev->Gpio2EventNotify(dev, Event.TimeStamp,
+					      Event.GPIOStatus & 0x1f);
+		if ((Event.GPIOStatus & 0x40) && (dev->Gpio3EventNotify))
+			dev->Gpio3EventNotify(dev, Event.TimeStamp,
+					      Event.GPIOStatus & 0x1f);
+#endif
 	}
 }
 
@@ -214,6 +223,13 @@
 		u8 nextWriteIndex =
 			(dev->EventQueueWriteIndex + 1) &
 			(EVENT_QUEUE_SIZE - 1);
+#if 0
+		printk(KERN_ERR DEVICE_NAME
+		       ": Event interrupt %02x Uart = %02x Gpio = %02x\n",
+		       dev->EventBuffer->EventStatus,
+		       dev->EventBuffer->UARTStatus,
+		       dev->EventBuffer->GPIOStatus);
+#endif
 		if (nextWriteIndex != dev->EventQueueReadIndex) {
 			dev->EventQueue[dev->EventQueueWriteIndex] =
 				*(dev->EventBuffer);
@@ -322,12 +338,24 @@
 	ngwritel(1, FORCE_INT);
 
 	ret = wait_event_timeout(dev->cmd_wq, dev->cmd_done == 1, 2 * HZ);
+#if 0
+	if (ret < 0)
+		return ret;
+	if (!dev->cmd_done)
+		;
+#endif
 	if (!ret) {
 		/*ngwritel(0, FORCE_NMI);*/
 
 		printk(KERN_ERR DEVICE_NAME
 		       ": Command timeout cmd=%02x prev=%02x\n",
 		       com->cmd.hdr.Opcode, dev->prev_cmd);
+#if 0
+		printk(KERN_ERR DEVICE_NAME ": Icounts=%08x\n",
+		       ngreadl(NGENE_INT_COUNTS));
+		if (ngreadl(NGENE_INT_COUNTS) == 0xffffffff)
+			ngwritel(0, NGENE_INT_ENABLE);
+#endif
 		dump_command_io(dev);
 		return -1;
 	}
@@ -354,6 +382,19 @@
 	return result;
 }
 
+#if 0
+int ngene_command_nop(struct ngene *dev)
+{
+	struct ngene_command com;
+
+	com.cmd.hdr.Opcode = CMD_NOP;
+	com.cmd.hdr.Length = 0;
+	com.in_len = 0;
+	com.out_len = 0;
+
+	return ngene_command(dev, &com);
+}
+#endif
 
 static int ngene_command_load_firmware(struct ngene *dev,
 				       u8 *ngene_fw, u32 size)
@@ -388,6 +429,83 @@
 	return ngene_command(dev, &com);
 }
 
+#if 0
+int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type)
+{
+	struct ngene_command com;
+
+	com.cmd.hdr.Opcode = type ? CMD_SFR_READ : CMD_IRAM_READ;
+	com.cmd.hdr.Length = 1;
+	com.cmd.SfrIramRead.address = adr;
+	com.in_len = 1;
+	com.out_len = 2;
+
+	if (ngene_command(dev, &com) < 0)
+		return -EIO;
+
+	*data = com.cmd.raw8[1];
+	return 0;
+}
+
+int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type)
+{
+	struct ngene_command com;
+
+	com.cmd.hdr.Opcode = type ? CMD_SFR_WRITE : CMD_IRAM_WRITE;
+	com.cmd.hdr.Length = 2;
+	com.cmd.SfrIramWrite.address = adr;
+	com.cmd.SfrIramWrite.data = data;
+	com.in_len = 2;
+	com.out_len = 1;
+
+	if (ngene_command(dev, &com) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int ngene_command_config_uart(struct ngene *dev, u8 config,
+				     tx_cb_t *tx_cb, rx_cb_t *rx_cb)
+{
+	struct ngene_command com;
+
+	com.cmd.hdr.Opcode = CMD_CONFIGURE_UART;
+	com.cmd.hdr.Length = sizeof(struct FW_CONFIGURE_UART) - 2;
+	com.cmd.ConfigureUart.UartControl = config;
+	com.in_len = sizeof(struct FW_CONFIGURE_UART);
+	com.out_len = 0;
+
+	if (ngene_command(dev, &com) < 0)
+		return -EIO;
+
+	dev->TxEventNotify = tx_cb;
+	dev->RxEventNotify = rx_cb;
+
+	dprintk(KERN_DEBUG DEVICE_NAME ": Set UART config %02x.\n", config);
+
+	return 0;
+}
+
+static void tx_cb(struct ngene *dev, u32 ts)
+{
+	dev->tx_busy = 0;
+	wake_up_interruptible(&dev->tx_wq);
+}
+
+static void rx_cb(struct ngene *dev, u32 ts, u8 c)
+{
+	int rp = dev->uart_rp;
+	int nwp, wp = dev->uart_wp;
+
+	/* dprintk(KERN_DEBUG DEVICE_NAME ": %c\n", c); */
+	nwp = (wp + 1) % (UART_RBUF_LEN);
+	if (nwp == rp)
+		return;
+	dev->uart_rbuf[wp] = c;
+	dev->uart_wp = nwp;
+	wake_up_interruptible(&dev->rx_wq);
+}
+#endif
 
 static int ngene_command_config_buf(struct ngene *dev, u8 config)
 {
@@ -433,6 +551,18 @@
 	return ngene_command(dev, &com);
 }
 
+#if 0
+/* The reset is only wired to GPIO4 on MicRacer Revision 1.10 !
+   Also better set bootdelay to 1 in nvram or less. */
+static void ngene_reset_decypher(struct ngene *dev)
+{
+	printk(KERN_INFO DEVICE_NAME ": Resetting Decypher.\n");
+	ngene_command_gpio_set(dev, 4, 0);
+	msleep(1);
+	ngene_command_gpio_set(dev, 4, 1);
+	msleep(2000);
+}
+#endif
 
 /*
  02000640 is sample on rising edge.
@@ -518,6 +648,17 @@
 	}
 }
 
+#if 0
+static void clear_tsin(struct ngene_channel *chan)
+{
+	struct SBufferHeader *Cur = chan->nextBuffer;
+
+	do {
+		memset(&Cur->ngeneBuffer.SR, 0, sizeof(Cur->ngeneBuffer.SR));
+		Cur = Cur->Next;
+	} while (Cur != chan->nextBuffer);
+}
+#endif
 
 static void flush_buffers(struct ngene_channel *chan)
 {
@@ -738,6 +879,14 @@
 	if (dev->card_info->switch_ctrl)
 		dev->card_info->switch_ctrl(chan, 1, state ^ 1);
 
+#if 0
+	/* Disable AVF output if present. */
+	if (dev->card_info->avf[chan->number])
+		i2c_write_register(&chan->i2c_adapter,
+				   chan->dev->card_info->avf[chan->number],
+				   0xf2, state ? 0x80 : 0x89);
+
+#endif
 	if (state) {
 		spin_lock_irq(&chan->state_lock);
 
@@ -777,6 +926,89 @@
 	}
 }
 
+#if 0
+/****************************************************************************/
+/* Decypher firmware loading ************************************************/
+/****************************************************************************/
+
+#define DECYPHER_FW "decypher.fw"
+
+static int dec_ts_send(struct ngene *dev, u8 *buf, u32 len)
+{
+#if 0
+	if (wait_event_interruptible(dev->tsout_rbuf.queue,
+				     dvb_ringbuffer_free
+				     (&dev->tsout_rbuf) >= len) < 0)
+		return 0;
+#else
+	while (dvb_ringbuffer_free(&dev->tsout_rbuf) < len)
+		msleep(1);
+
+#endif
+
+	dvb_ringbuffer_write(&dev->tsout_rbuf, buf, len);
+
+	return len;
+}
+
+u8 dec_fw_fill_ts[188] = { 0x47, 0x09, 0x0e, 0x10, 0xff, 0xff, 0x00, 0x00 };
+
+int dec_fw_send(struct ngene *dev, u8 *fw, u32 size)
+{
+	struct ngene_channel *chan = &dev->channel[4];
+	u32 len = 180, cc = 0;
+	u8 buf[8] = { 0x47, 0x09, 0x0e, 0x10, 0x00, 0x00, 0x00, 0x00 };
+
+	set_transfer(chan, 1);
+	msleep(100);
+	while (size) {
+		len = 180;
+		if (len > size)
+			len = size;
+		buf[3] = 0x10 | (cc & 0x0f);
+		buf[4] = (cc >> 8);
+		buf[5] = cc & 0xff;
+		buf[6] = len;
+
+		dec_ts_send(dev, buf, 8);
+		dec_ts_send(dev, fw, len);
+		if (len < 180)
+			dec_ts_send(dev, dec_fw_fill_ts + len + 8, 180 - len);
+		cc++;
+		size -= len;
+		fw += len;
+	}
+	for (len = 0; len < 512; len++)
+		dec_ts_send(dev, dec_fw_fill_ts, 188);
+	while (dvb_ringbuffer_avail(&dev->tsout_rbuf))
+		msleep(10);
+	msleep(100);
+	set_transfer(chan, 0);
+	return 0;
+}
+
+int dec_fw_boot(struct ngene *dev)
+{
+	u32 size;
+	const struct firmware *fw = NULL;
+	u8 *dec_fw;
+
+	if (request_firmware(&fw, DECYPHER_FW, &dev->pci_dev->dev) < 0) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": %s not found. Check hotplug directory.\n",
+		       DECYPHER_FW);
+		return -1;
+	}
+	printk(KERN_INFO DEVICE_NAME ": Booting decypher firmware file %s\n",
+	       DECYPHER_FW);
+
+	size = fw->size;
+	dec_fw = (u8 *)fw->data;
+	dec_fw_send(dev, dec_fw, size);
+	release_firmware(fw);
+	return 0;
+}
+#endif
 
 /****************************************************************************/
 /* nGene hardware init and release functions ********************************/
@@ -1071,6 +1303,85 @@
 	0
 };
 
+#if 0
+static int allocate_buffer(struct pci_dev *pci_dev, dma_addr_t of,
+			   struct SRingBufferDescriptor *rbuf,
+			   u32 entries, u32 size1, u32 size2)
+{
+	if (create_ring_buffer(pci_dev, rbuf, entries) < 0)
+		return -ENOMEM;
+
+	if (AllocateRingBuffers(pci_dev, of, rbuf, size1, size2) < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int channel_allocate_buffers(struct ngene_channel *chan)
+{
+	struct ngene *dev = chan->dev;
+	int type = dev->card_info->io_type[chan->number];
+	int status;
+
+	chan->State = KSSTATE_STOP;
+
+	if (type & (NGENE_IO_TV | NGENE_IO_HDTV | NGENE_IO_AIN)) {
+		status = create_ring_buffer(dev->pci_dev,
+					    &chan->RingBuffer,
+					    RingBufferSizes[chan->number]);
+		if (status < 0)
+			return -ENOMEM;
+
+		if (type & (NGENE_IO_TV | NGENE_IO_AIN)) {
+			status = AllocateRingBuffers(dev->pci_dev,
+						     dev->PAOverflowBuffer,
+						     &chan->RingBuffer,
+						     Buffer1Sizes[chan->number],
+						     Buffer2Sizes[chan->
+								  number]);
+			if (status < 0)
+				return -ENOMEM;
+		} else if (type & NGENE_IO_HDTV) {
+			status = AllocateRingBuffers(dev->pci_dev,
+						     dev->PAOverflowBuffer,
+						     &chan->RingBuffer,
+						     MAX_HDTV_BUFFER_SIZE, 0);
+			if (status < 0)
+				return -ENOMEM;
+		}
+	}
+
+	if (type & (NGENE_IO_TSIN | NGENE_IO_TSOUT)) {
+
+		status = create_ring_buffer(dev->pci_dev,
+					    &chan->TSRingBuffer, RING_SIZE_TS);
+		if (status < 0)
+			return -ENOMEM;
+
+		status = AllocateRingBuffers(dev->pci_dev,
+					     dev->PAOverflowBuffer,
+					     &chan->TSRingBuffer,
+					     MAX_TS_BUFFER_SIZE, 0);
+		if (status)
+			return -ENOMEM;
+	}
+
+	if (type & NGENE_IO_TSOUT) {
+		status = create_ring_buffer(dev->pci_dev,
+					    &chan->TSIdleBuffer, 1);
+		if (status < 0)
+			return -ENOMEM;
+		status = AllocateRingBuffers(dev->pci_dev,
+					     dev->PAOverflowBuffer,
+					     &chan->TSIdleBuffer,
+					     MAX_TS_BUFFER_SIZE, 0);
+		if (status)
+			return -ENOMEM;
+		FillTSIdleBuffer(&chan->TSIdleBuffer, &chan->TSRingBuffer);
+	}
+	return 0;
+}
+#endif
 
 static int AllocCommonBuffers(struct ngene *dev)
 {
@@ -1324,6 +1635,10 @@
 		u8 tsin12_config[6]   = { 0x60, 0x60, 0x00, 0x00, 0x00, 0x00 };
 		u8 tsin1234_config[6] = { 0x30, 0x30, 0x00, 0x30, 0x30, 0x00 };
 		u8 tsio1235_config[6] = { 0x30, 0x30, 0x00, 0x28, 0x00, 0x38 };
+#if 0
+		u8 tsin34_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x60, 0x00 };
+		u8 tsio35_config[6]   = { 0x00, 0x00, 0x00, 0x60, 0x00, 0x60 };
+#endif
 		u8 *bconf = tsin12_config;
 
 		if (dev->card_info->io_type[2]&NGENE_IO_TSIN &&
@@ -1333,10 +1648,22 @@
 			    dev->ci.en)
 				bconf = tsio1235_config;
 		}
+#if 0
+		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
+			bconf = hdtv_config;
+			ngene_reset_decypher(dev);
+		}
+#endif
 		stat = ngene_command_config_free_buf(dev, bconf);
 	} else {
 		int bconf = BUFFER_CONFIG_4422;
 
+#if 0
+		if (dev->card_info->io_type[0] == NGENE_IO_HDTV) {
+			bconf = BUFFER_CONFIG_8022;
+			ngene_reset_decypher(dev);
+		}
+#endif
 		if (dev->card_info->io_type[3] == NGENE_IO_TSIN)
 			bconf = BUFFER_CONFIG_3333;
 		stat = ngene_command_config_buf(dev, bconf);
@@ -1697,6 +2024,33 @@
 
 
 	dev->i2c_current_bus = -1;
+#if 0
+	exp_init(dev);
+
+	/* Disable analog TV decoder chips if present */
+	if (dev->card_info->msp[0])
+		i2c_write_msp_register(&dev->channel[0].i2c_adapter,
+				       dev->card_info->msp[0], 0x00, 0x0000);
+	if (dev->card_info->msp[1])
+		i2c_write_msp_register(&dev->channel[1].i2c_adapter,
+				       dev->card_info->msp[1], 0x00, 0x0000);
+	{
+		u16 data;
+		read_msp(&dev->channel[0].i2c_adapter,
+			 dev->card_info->msp[0], 0x00, &data);
+	}
+	if (dev->card_info->avf[0])
+		i2c_write_register(&dev->channel[0].i2c_adapter,
+				   dev->card_info->avf[0], 0xf2, 0x80);
+	if (dev->card_info->avf[1])
+		i2c_write_register(&dev->channel[1].i2c_adapter,
+				   dev->card_info->avf[1], 0xf2, 0x80);
+	if (copy_eeprom) {
+		i2c_copy_eeprom(&dev->channel[0].i2c_adapter, 0x50, 0x52);
+		i2c_dump_eeprom(&dev->channel[0].i2c_adapter, 0x52);
+	}
+	/*i2c_check_eeprom(&dev->i2c_adapter);*/
+#endif
 
 	/* Register DVB adapters and devices for both channels */
 	if (init_channels(dev) < 0)
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-dvb.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-dvb.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-dvb.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-dvb.c	2012-06-18 23:37:09.114034205 +0200
@@ -39,13 +39,323 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
+#include "linux/compat.h"
 
 #include "ngene.h"
 
+#if 0
+int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
+			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl)
+{
+	if (!(mode & SMODE_TRANSPORT_STREAM))
+		return -EINVAL;
+
+	if (lines * bpl > MAX_VIDEO_BUFFER_SIZE)
+		return -EINVAL;
+
+	if ((mode & SMODE_TRANSPORT_STREAM) && (((bpl * lines) & 0xff) != 0))
+		return -EINVAL;
+
+	if ((mode & SMODE_VIDEO_CAPTURE) && (bpl & 7) != 0)
+		return -EINVAL;
+
+	return ngene_command_stream_control(dev, stream, control, mode, 0);
+}
+#endif
 
 /****************************************************************************/
 /* COMMAND API interface ****************************************************/
 /****************************************************************************/
+#if 0
+
+static int command_do_ioctl(struct inode *inode, struct file *file,
+			    unsigned int cmd, void *parg)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int err = 0;
+
+	switch (cmd) {
+	case IOCTL_MIC_NO_OP:
+		err = ngene_command_nop(dev);
+		break;
+
+	case IOCTL_MIC_DOWNLOAD_FIRMWARE:
+		break;
+
+	case IOCTL_MIC_I2C_READ:
+	{
+		MIC_I2C_READ *msg = parg;
+
+		err = ngene_command_i2c_read(dev, msg->I2CAddress >> 1,
+					     msg->OutData, msg->OutLength,
+					     msg->OutData, msg->InLength, 1);
+		break;
+	}
+
+	case IOCTL_MIC_I2C_WRITE:
+	{
+		MIC_I2C_WRITE *msg = parg;
+
+		err = ngene_command_i2c_write(dev, msg->I2CAddress >> 1,
+					      msg->Data, msg->Length);
+		break;
+	}
+
+	case IOCTL_MIC_TEST_GETMEM:
+	{
+		MIC_MEM *m = parg;
+
+		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
+			return -EINVAL;
+
+		/* WARNING, only use this on x86,
+		   other archs may not swallow this  */
+		err = copy_to_user(m->Data, dev->iomem + m->Start, m->Length);
+		break;
+	}
+
+	case IOCTL_MIC_TEST_SETMEM:
+	{
+		MIC_MEM *m = parg;
+
+		if (m->Length > 64 * 1024 || m->Start + m->Length > 64 * 1024)
+			return -EINVAL;
+
+		err = copy_from_user(dev->iomem + m->Start, m->Data, m->Length);
+		break;
+	}
+
+	case IOCTL_MIC_SFR_READ:
+	{
+		MIC_IMEM *m = parg;
+
+		err = ngene_command_imem_read(dev, m->Address, &m->Data, 1);
+		break;
+	}
+
+	case IOCTL_MIC_SFR_WRITE:
+	{
+		MIC_IMEM *m = parg;
+
+		err = ngene_command_imem_write(dev, m->Address, m->Data, 1);
+		break;
+	}
+
+	case IOCTL_MIC_IRAM_READ:
+	{
+		MIC_IMEM *m = parg;
+
+		err = ngene_command_imem_read(dev, m->Address, &m->Data, 0);
+		break;
+	}
+
+	case IOCTL_MIC_IRAM_WRITE:
+	{
+		MIC_IMEM *m = parg;
+
+		err = ngene_command_imem_write(dev, m->Address, m->Data, 0);
+		break;
+	}
+
+	case IOCTL_MIC_STREAM_CONTROL:
+	{
+		MIC_STREAM_CONTROL *m = parg;
+
+		err = ngene_stream_control(dev, m->Stream, m->Control, m->Mode,
+					   m->nLines, m->nBytesPerLine,
+					   m->nVBILines, m->nBytesPerVBILine);
+		break;
+	}
+
+	default:
+		err = -EINVAL;
+		break;
+	}
+	return err;
+}
+
+static int command_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	void *parg = (void *)arg, *pbuf = NULL;
+	char  buf[64];
+	int   res = -EFAULT;
+
+	if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		parg = buf;
+		if (_IOC_SIZE(cmd) > sizeof(buf)) {
+			pbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (!pbuf)
+				return -ENOMEM;
+			parg = pbuf;
+		}
+		if (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))
+			goto error;
+	}
+	res = command_do_ioctl(inode, file, cmd, parg);
+	if (res < 0)
+		goto error;
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			res = -EFAULT;
+error:
+	kfree(pbuf);
+	return res;
+}
+
+struct page *ngene_nopage(struct vm_area_struct *vma,
+			  unsigned long address, int *type)
+{
+	return 0;
+}
+
+static int ngene_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long padr = pci_resource_start(dev->pci_dev, 0) + off;
+	unsigned long psize = pci_resource_len(dev->pci_dev, 0) - off;
+
+	if (size > psize)
+		return -EINVAL;
+
+	if (io_remap_pfn_range(vma, vma->vm_start, padr >> PAGE_SHIFT, size,
+			       vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+
+static int write_uart(struct ngene *dev, u8 *data, int len)
+{
+	struct ngene_command com;
+
+	com.cmd.hdr.Opcode = CMD_WRITE_UART;
+	com.cmd.hdr.Length = len;
+	memcpy(com.cmd.WriteUart.Data, data, len);
+	com.cmd.WriteUart.Data[len] = 0;
+	com.cmd.WriteUart.Data[len + 1] = 0;
+	com.in_len = len;
+	com.out_len = 0;
+
+	if (ngene_command(dev, &com) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int send_cli(struct ngene *dev, char *cmd)
+{
+	/* printk(KERN_INFO DEVICE_NAME ": %s", cmd); */
+	return write_uart(dev, cmd, strlen(cmd));
+}
+
+static int send_cli_val(struct ngene *dev, char *cmd, u32 val)
+{
+	char s[32];
+
+	snprintf(s, 32, "%s %d\n", cmd, val);
+	/* printk(KERN_INFO DEVICE_NAME ": %s", s); */
+	return write_uart(dev, s, strlen(s));
+}
+
+static int ngene_command_write_uart_user(struct ngene *dev,
+					 const u8 *data, int len)
+{
+	struct ngene_command com;
+
+	dev->tx_busy = 1;
+	com.cmd.hdr.Opcode = CMD_WRITE_UART;
+	com.cmd.hdr.Length = len;
+
+	if (copy_from_user(com.cmd.WriteUart.Data, data, len))
+		return -EFAULT;
+	com.in_len = len;
+	com.out_len = 0;
+
+	if (ngene_command(dev, &com) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static ssize_t uart_write(struct file *file, const char *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int len, ret = 0;
+	size_t left = count;
+
+	while (left) {
+		len = left;
+		if (len > 250)
+			len = 250;
+		ret = wait_event_interruptible(dev->tx_wq, dev->tx_busy == 0);
+		if (ret < 0)
+			return ret;
+		ngene_command_write_uart_user(dev, buf, len);
+		left -= len;
+		buf += len;
+	}
+	return count;
+}
+
+static ssize_t uart_read(struct file *file, char *buf,
+			 size_t count, loff_t *ppos)
+{
+	struct dvb_device *dvbdev = file->private_data;
+	struct ngene_channel *chan = dvbdev->priv;
+	struct ngene *dev = chan->dev;
+	int left;
+	int wp, rp, avail, len;
+
+	if (!dev->uart_rbuf)
+		return -EINVAL;
+	if (count > 128)
+		count = 128;
+	left = count;
+	while (left) {
+		if (wait_event_interruptible(dev->rx_wq,
+					     dev->uart_wp != dev->uart_rp) < 0)
+			return -EAGAIN;
+		wp = dev->uart_wp;
+		rp = dev->uart_rp;
+		avail = (wp - rp);
+
+		if (avail < 0)
+			avail += UART_RBUF_LEN;
+		if (avail > left)
+			avail = left;
+		if (wp < rp) {
+			len = UART_RBUF_LEN - rp;
+			if (len > avail)
+				len = avail;
+			if (copy_to_user(buf, dev->uart_rbuf + rp, len))
+				return -EFAULT;
+			if (len < avail)
+				if (copy_to_user(buf + len, dev->uart_rbuf,
+						 avail - len))
+					return -EFAULT;
+		} else {
+			if (copy_to_user(buf, dev->uart_rbuf + rp, avail))
+				return -EFAULT;
+		}
+		dev->uart_rp = (rp + avail) % UART_RBUF_LEN;
+		left -= avail;
+		buf += avail;
+	}
+	return count;
+}
+
+#endif
 
 static ssize_t ts_write(struct file *file, const char *buf,
 			size_t count, loff_t *ppos)
@@ -133,6 +443,11 @@
 	struct ngene_channel *chan = priv;
 	struct ngene *dev = chan->dev;
 
+#if 0
+	printk(KERN_INFO DEVICE_NAME ": tsin %08x %02x %02x %02x %02x\n",
+	       len, ((u8 *) buf)[512 * 188], ((u8 *) buf)[0],
+	       ((u8 *) buf)[1], ((u8 *) buf)[2]);
+#endif
 
 	if (flags & DF_SWAP32)
 		swap_buffer(buf, len);
@@ -191,12 +506,49 @@
 	return buf;
 }
 
+#if 0
+static void set_dto(struct ngene_channel *chan, u32 rate)
+{
+	u64 val = rate * 0x89705f41ULL; /* times val for 2^26 Hz */
+
+	val = ((val >> 25) + 1) >> 1;
+	chan->AudioDTOValue = (u32) val;
+	/* chan->AudioDTOUpdated=1; */
+	/* printk(KERN_INFO DEVICE_NAME ": Setting DTO to %08x\n", val); */
+}
+#endif
 
 
 int ngene_start_feed(struct dvb_demux_feed *dvbdmxfeed)
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ngene_channel *chan = dvbdmx->priv;
+#if 0
+	struct ngene *dev = chan->dev;
+
+	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
+		switch (dvbdmxfeed->pes_type) {
+		case DMX_TS_PES_VIDEO:
+			send_cli_val(dev, "vpid", dvbdmxfeed->pid);
+			send_cli(dev, "res 1080i50\n");
+			/* send_cli(dev, "vdec mpeg2\n"); */
+			break;
+
+		case DMX_TS_PES_AUDIO:
+			send_cli_val(dev, "apid", dvbdmxfeed->pid);
+			send_cli(dev, "start\n");
+			break;
+
+		case DMX_TS_PES_PCR:
+			send_cli_val(dev, "pcrpid", dvbdmxfeed->pid);
+			break;
+
+		default:
+			break;
+		}
+
+	}
+#endif
 
 	if (chan->users == 0) {
 		if (!chan->dev->cmd_timeout_workaround || !chan->running)
@@ -210,6 +562,27 @@
 {
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	struct ngene_channel *chan = dvbdmx->priv;
+#if 0
+	struct ngene *dev = chan->dev;
+
+	if (dev->card_info->io_type[chan->number] & NGENE_IO_TSOUT) {
+		switch (dvbdmxfeed->pes_type) {
+		case DMX_TS_PES_VIDEO:
+			send_cli(dev, "stop\n");
+			break;
+
+		case DMX_TS_PES_AUDIO:
+			break;
+
+		case DMX_TS_PES_PCR:
+			break;
+
+		default:
+			break;
+		}
+
+	}
+#endif
 
 	if (--chan->users)
 		return chan->users;
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-eeprom.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-eeprom.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-eeprom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-eeprom.c	2012-06-18 22:31:48.134032196 +0200
@@ -0,0 +1,284 @@
+/*
+ * ngene-eeprom.c: nGene PCIe bridge driver - eeprom support
+ *
+ * Copyright (C) 2005-2007 Micronas
+ *
+ * Copyright (C) 2008-2009 Ralph Metzler <rjkm@metzlerbros.de>
+ *                         Modifications for new nGene firmware,
+ *                         support for EEPROM-copying,
+ *                         support for new dual DVB-S2 card prototype
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 only, as published by the Free Software Foundation.
+ *
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
+ */
+
+#if 0
+static int copy_eeprom;
+module_param(copy_eeprom, int, 0444);
+MODULE_PARM_DESC(copy_eeprom, "Copy eeprom.");
+
+#define MICNG_EE_START      0x0100
+#define MICNG_EE_END        0x0FF0
+
+#define MICNG_EETAG_END0    0x0000
+#define MICNG_EETAG_END1    0xFFFF
+
+/* 0x0001 - 0x000F reserved for housekeeping */
+/* 0xFFFF - 0xFFFE reserved for housekeeping */
+
+/* Micronas assigned tags
+   EEProm tags for hardware support */
+
+#define MICNG_EETAG_DRXD1_OSCDEVIATION  0x1000  /* 2 Bytes data */
+#define MICNG_EETAG_DRXD2_OSCDEVIATION  0x1001  /* 2 Bytes data */
+
+#define MICNG_EETAG_MT2060_1_1STIF      0x1100  /* 2 Bytes data */
+#define MICNG_EETAG_MT2060_2_1STIF      0x1101  /* 2 Bytes data */
+
+/* Tag range for OEMs */
+
+#define MICNG_EETAG_OEM_FIRST  0xC000
+#define MICNG_EETAG_OEM_LAST   0xFFEF
+
+static int i2c_write_eeprom(struct i2c_adapter *adapter,
+			    u8 adr, u16 reg, u8 data)
+{
+	u8 m[3] = {(reg >> 8), (reg & 0xff), data};
+	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m,
+			      .len = sizeof(m)};
+
+	if (i2c_transfer(adapter, &msg, 1) != 1) {
+		dprintk(KERN_ERR DEVICE_NAME ": Error writing EEPROM!\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int i2c_read_eeprom(struct i2c_adapter *adapter,
+			   u8 adr, u16 reg, u8 *data, int len)
+{
+	u8 msg[2] = {(reg >> 8), (reg & 0xff)};
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf = msg, .len = 2 },
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf = data, .len = len} };
+
+	if (i2c_transfer(adapter, msgs, 2) != 2) {
+		dprintk(KERN_ERR DEVICE_NAME ": Error reading EEPROM\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int ReadEEProm(struct i2c_adapter *adapter,
+		      u16 Tag, u32 MaxLen, u8 *data, u32 *pLength)
+{
+	int status = 0;
+	u16 Addr = MICNG_EE_START, Length, tag = 0;
+	u8  EETag[3];
+
+	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
+		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
+			return -1;
+		tag = (EETag[0] << 8) | EETag[1];
+		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
+			return -1;
+		if (tag == Tag)
+			break;
+		Addr += sizeof(u16) + 1 + EETag[2];
+	}
+	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
+		       tag, EETag[2]);
+		return -1;
+	}
+	Length = EETag[2];
+	if (Length > MaxLen)
+		Length = (u16) MaxLen;
+	if (Length > 0) {
+		Addr += sizeof(u16) + 1;
+		status = i2c_read_eeprom(adapter, 0x50, Addr, data, Length);
+		if (!status) {
+			*pLength = EETag[2];
+			if (Length < EETag[2])
+				; /*status=STATUS_BUFFER_OVERFLOW; */
+		}
+	}
+	return status;
+}
+
+static int WriteEEProm(struct i2c_adapter *adapter,
+		       u16 Tag, u32 Length, u8 *data)
+{
+	int status = 0;
+	u16 Addr = MICNG_EE_START;
+	u8 EETag[3];
+	u16 tag = 0;
+	int retry, i;
+
+	while (Addr + sizeof(u16) + 1 < MICNG_EE_END) {
+		if (i2c_read_eeprom(adapter, 0x50, Addr, EETag, sizeof(EETag)))
+			return -1;
+		tag = (EETag[0] << 8) | EETag[1];
+		if (tag == MICNG_EETAG_END0 || tag == MICNG_EETAG_END1)
+			return -1;
+		if (tag == Tag)
+			break;
+		Addr += sizeof(u16) + 1 + EETag[2];
+	}
+	if (Addr + sizeof(u16) + 1 + EETag[2] > MICNG_EE_END) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": Reached EOEE @ Tag = %04x Length = %3d\n",
+		       tag, EETag[2]);
+		return -1;
+	}
+
+	if (Length > EETag[2])
+		return -EINVAL;
+	/* Note: We write the data one byte at a time to avoid
+	   issues with page sizes. (which are different for
+	   each manufacture and eeprom size)
+	 */
+	Addr += sizeof(u16) + 1;
+	for (i = 0; i < Length; i++, Addr++) {
+		status = i2c_write_eeprom(adapter, 0x50, Addr, data[i]);
+
+		if (status)
+			break;
+
+		/* Poll for finishing write cycle */
+		retry = 10;
+		while (retry) {
+			u8 Tmp;
+
+			msleep(50);
+			status = i2c_read_eeprom(adapter, 0x50, Addr, &Tmp, 1);
+			if (status)
+				break;
+			if (Tmp != data[i])
+				printk(KERN_ERR DEVICE_NAME
+				       "eeprom write error\n");
+			retry -= 1;
+		}
+		if (status) {
+			printk(KERN_ERR DEVICE_NAME
+			       ": Timeout polling eeprom\n");
+			break;
+		}
+	}
+	return status;
+}
+
+static void i2c_init_eeprom(struct i2c_adapter *adapter)
+{
+	u8 tags[] = {0x10, 0x00, 0x02, 0x00, 0x00,
+		     0x10, 0x01, 0x02, 0x00, 0x00,
+		     0x00, 0x00, 0x00};
+
+	int i;
+
+	for (i = 0; i < sizeof(tags); i++)
+		i2c_write_eeprom(adapter, 0x50, 0x0100 + i, tags[i]);
+}
+
+int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data)
+{
+	int stat;
+	u8 buf[2];
+	u32 len = 0;
+
+	stat = ReadEEProm(adapter, tag, 2, buf, &len);
+	if (stat)
+		return stat;
+	if (len != 2)
+		return -EINVAL;
+
+	*data = (buf[0] << 8) | buf[1];
+	return 0;
+}
+
+static int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data)
+{
+	int stat;
+	u8 buf[2];
+
+	buf[0] = data >> 8;
+	buf[1] = data & 0xff;
+	stat = WriteEEProm(adapter, tag, 2, buf);
+	if (stat)
+		return stat;
+	return 0;
+}
+
+int i2c_dump_eeprom(struct i2c_adapter *adapter, u8 adr)
+{
+	u8 buf[64];
+	int i;
+
+	if (i2c_read_eeprom(adapter, adr, 0x0000, buf, sizeof(buf))) {
+		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
+		return -1;
+	}
+	for (i = 0; i < sizeof(buf); i++) {
+		if (!(i & 15))
+			printk(KERN_DEBUG "\n");
+		printk(KERN_DEBUG "%02x ", buf[i]);
+	}
+	printk("\n");
+
+	return 0;
+}
+
+int i2c_copy_eeprom(struct i2c_adapter *adapter, u8 adr, u8 adr2)
+{
+	u8 buf[64];
+	int i;
+
+	if (i2c_read_eeprom(adapter, adr, 0x0000, buf, sizeof(buf))) {
+		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
+		return -1;
+	}
+	buf[36] = 0xc3;
+	buf[39] = 0xab;
+	for (i = 0; i < sizeof(buf); i++) {
+		i2c_write_eeprom(adapter, adr2, i, buf[i]);
+		msleep(10);
+	}
+	return 0;
+}
+
+int i2c_check_eeprom(struct i2c_adapter *adapter)
+{
+	u8 buf[13];
+
+	i2c_dump_eeprom(adapter);
+
+	if (i2c_read_eeprom(adapter, 0x50, 0x0100, buf, sizeof(buf))) {
+		printk(KERN_ERR DEVICE_NAME ": No EEPROM?\n");
+		return -1;
+	}
+	if (buf[0] != 0x10 || buf[1] != 0x00) {
+		printk(KERN_INFO DEVICE_NAME
+		       ": Initializing EEPROM TAG area\n");
+		i2c_init_eeprom(adapter);
+	}
+	return 0;
+}
+
+#endif
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene.h linux-3.4.3.dd/drivers/media/dvb/ngene/ngene.h
--- linux-3.4.3/drivers/media/dvb/ngene/ngene.h	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene.h	2012-06-18 23:31:41.234034037 +0200
@@ -40,7 +40,7 @@
 #include "dvb_frontend.h"
 #include "dvb_ringbuffer.h"
 #include "dvb_net.h"
-#include "cxd2099.h"
+#include "../drivers/staging/media/cxd2099/cxd2099.h"
 
 #define DEVICE_NAME "ngene"
 
@@ -653,6 +653,11 @@
 	struct dmx_frontend   mem_frontend;
 	int                   users;
 	struct video_device  *v4l_dev;
+#if 0
+	struct dvb_device    *command_dev;
+	struct dvb_device    *audio_dev;
+	struct dvb_device    *video_dev;
+#endif
 	struct dvb_device    *ci_dev;
 	struct tasklet_struct demux_tasklet;
 
@@ -691,6 +696,9 @@
 	struct mychip        *mychip;
 	struct snd_card      *soundcard;
 	u8                   *evenbuffer;
+#if 0
+	u8                   *soundbuffer;
+#endif
 	u8                    dma_on;
 	int                   soundstreamon;
 	int                   audiomute;
@@ -849,6 +857,10 @@
 	u8    lnb[4];
 	int   i2c_access;
 	u8    ntsc;
+#if 0
+	u8    exp;
+	u8    exp_init;
+#endif
 	u8    tsf[4];
 	u8    i2s[4];
 
@@ -885,6 +897,25 @@
 };
 #endif
 
+#if 0
+int ngene_command_stream_control(struct ngene *dev,
+				 u8 stream, u8 control, u8 mode, u8 flags);
+int ngene_command_nop(struct ngene *dev);
+int ngene_command_i2c_read(struct ngene *dev, u8 adr,
+			   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag);
+int ngene_command_i2c_write(struct ngene *dev, u8 adr, u8 *out, u8 outlen);
+int ngene_command_imem_read(struct ngene *dev, u8 adr, u8 *data, int type);
+int ngene_command_imem_write(struct ngene *dev, u8 adr, u8 data, int type);
+int ngene_stream_control(struct ngene *dev, u8 stream, u8 control, u8 mode,
+			 u16 lines, u16 bpl, u16 vblines, u16 vbibpl);
+
+int ngene_v4l2_init(struct ngene_channel *chan);
+void ngene_v4l2_remove(struct ngene_channel *chan);
+int ngene_snd_exit(struct ngene_channel *chan);
+int ngene_snd_init(struct ngene_channel *chan);
+
+struct i2c_client *avf4910a_attach(struct i2c_adapter *adap, int addr);
+#endif
 
 /* Provided by ngene-core.c */
 int __devinit ngene_probe(struct pci_dev *pci_dev,
@@ -915,6 +946,15 @@
 			       struct dmx_frontend *mem_frontend,
 			       struct dvb_adapter *dvb_adapter);
 
+/* Provided by ngene-eeprom.c */
+#if 0
+int i2c_copy_eeprom(struct i2c_adapter *adapter, u8 adr, u8 adr2);
+int i2c_dump_eeprom(struct i2c_adapter *adapter, u8 adr);
+int i2c_check_eeprom(struct i2c_adapter *adapter);
+int eeprom_write_ushort(struct i2c_adapter *adapter, u16 tag, u16 data);
+int eeprom_read_ushort(struct i2c_adapter *adapter, u16 tag, u16 *data);
+#endif
+
 #endif
 
 /*  LocalWords:  Endif
diff -urN linux-3.4.3/drivers/media/dvb/ngene/ngene-i2c.c linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-i2c.c
--- linux-3.4.3/drivers/media/dvb/ngene/ngene-i2c.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/dvb/ngene/ngene-i2c.c	2012-06-18 23:32:27.604034061 +0200
@@ -41,6 +41,7 @@
 #include <linux/byteorder/generic.h>
 #include <linux/firmware.h>
 #include <linux/vmalloc.h>
+#include "linux/compat.h"
 
 #include "ngene.h"
 
@@ -77,6 +78,11 @@
 {
 	struct ngene_command com;
 
+#if 0
+	/* Probing by writing 0 bytes does not work */
+	if (!outlen)
+		outlen++;
+#endif
 
 	com.cmd.hdr.Opcode = CMD_I2C_WRITE;
 	com.cmd.hdr.Length = outlen + 1;
@@ -148,6 +154,39 @@
 	return num;
 }
 
+#if 0
+static int ngene_i2c_algo_control(struct i2c_adapter *adap,
+				  unsigned int cmd, unsigned long arg)
+{
+	struct ngene_channel *chan =
+		(struct ngene_channel *)i2c_get_adapdata(adap);
+
+	switch (cmd) {
+	case IOCTL_MIC_TUN_RDY:
+		chan->tun_rdy = 1;
+		if (chan->dec_rdy == 1)
+			chan->tun_dec_rdy = 1;
+		break;
+
+	case IOCTL_MIC_DEC_RDY:
+		chan->dec_rdy = 1;
+		if (chan->tun_rdy == 1)
+			chan->tun_dec_rdy = 1;
+		break;
+
+	case IOCTL_MIC_TUN_DETECT:
+		{
+			int *palorbtsc = (int *)arg;
+			*palorbtsc = chan->dev->card_info->ntsc;
+			break;
+		}
+
+	default:
+		break;
+	}
+	return 0;
+}
+#endif
 
 static u32 ngene_i2c_functionality(struct i2c_adapter *adap)
 {
@@ -174,3 +213,78 @@
 	return i2c_add_adapter(adap);
 }
 
+#if 0
+int i2c_write(struct i2c_adapter *adapter, u8 adr, u8 data)
+{
+	u8 m[1] = {data};
+	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 1};
+
+	if (i2c_transfer(adapter, &msg, 1) != 1) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": Failed to write to I2C adr %02x!\n", adr);
+		return -1;
+	}
+	return 0;
+}
+
+static int i2c_write_register(struct i2c_adapter *adapter,
+			      u8 adr, u8 reg, u8 data)
+{
+	u8 m[2] = {reg, data};
+	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 2};
+
+	if (i2c_transfer(adapter, &msg, 1) != 1) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": Failed to write to I2C register %02x@%02x!\n",
+		       reg, adr);
+		return -1;
+	}
+	return 0;
+}
+
+static int i2c_write_read(struct i2c_adapter *adapter,
+			  u8 adr, u8 *w, u8 wlen, u8 *r, u8 rlen)
+{
+	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
+				   .buf = w, .len = wlen},
+				  {.addr = adr, .flags = I2C_M_RD,
+				   .buf = r, .len = rlen} };
+
+	if (i2c_transfer(adapter, msgs, 2) != 2) {
+		printk(KERN_ERR DEVICE_NAME ": error in i2c_write_read\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int test_dec_i2c(struct i2c_adapter *adapter, int reg)
+{
+	u8 data[256] = { reg, 0x00, 0x93, 0x78, 0x43, 0x45 };
+	u8 data2[256];
+	int i;
+
+	memset(data2, 0, 256);
+	i2c_write_read(adapter, 0x66, data, 2, data2, 4);
+	for (i = 0; i < 4; i++)
+		printk(KERN_DEBUG "%02x ", data2[i]);
+	printk(KERN_DEBUG "\n");
+
+	return 0;
+}
+
+static int i2c_write_msp_register(struct i2c_adapter *adapter,
+				  u8 adr, u8 reg, u16 data)
+{
+	u8 m[3] = {reg, (data >> 8) & 0xff, data & 0xff};
+	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 3 };
+
+	if (i2c_transfer(adapter, &msg, 1) != 1) {
+		printk(KERN_ERR DEVICE_NAME
+		       ": Failed to write to I2C register %02x@%02x!\n",
+		       reg, adr);
+		return -1;
+	}
+	return 0;
+}
+
+#endif
diff -urN linux-3.4.3/drivers/media/Kconfig linux-3.4.3.dd/drivers/media/Kconfig
--- linux-3.4.3/drivers/media/Kconfig	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/media/Kconfig	2012-06-18 22:34:28.944032278 +0200
@@ -126,4 +126,6 @@
 
 source "drivers/media/dvb/Kconfig"
 
+source "drivers/media/common/saa716x/Kconfig"
+
 endif # MEDIA_SUPPORT
diff -urN linux-3.4.3/drivers/media/Kconfig.orig linux-3.4.3.dd/drivers/media/Kconfig.orig
--- linux-3.4.3/drivers/media/Kconfig.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.4.3.dd/drivers/media/Kconfig.orig	2012-06-17 20:21:44.000000000 +0200
@@ -0,0 +1,129 @@
+#
+# Multimedia device configuration
+#
+
+menuconfig MEDIA_SUPPORT
+	tristate "Multimedia support"
+	depends on HAS_IOMEM
+	help
+	  If you want to use Video for Linux, DVB for Linux, or DAB adapters,
+	  enable this option and other options below.
+
+if MEDIA_SUPPORT
+
+comment "Multimedia core support"
+
+#
+# Media controller
+#
+
+config MEDIA_CONTROLLER
+	bool "Media Controller API (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	---help---
+	  Enable the media controller API used to query media devices internal
+	  topology and configure it dynamically.
+
+	  This API is mostly used by camera interfaces in embedded platforms.
+
+#
+# V4L core and enabled API's
+#
+
+config VIDEO_DEV
+	tristate "Video For Linux"
+	---help---
+	  V4L core support for video capture and overlay devices, webcams and
+	  AM/FM radio cards.
+
+	  This kernel includes support for the new Video for Linux Two API,
+	  (V4L2).
+
+	  Additional info and docs are available on the web at
+	  <http://linuxtv.org>
+
+	  Documentation for V4L2 is also available on the web at
+	  <http://bytesex.org/v4l/>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called videodev.
+
+config VIDEO_V4L2_COMMON
+	tristate
+	depends on (I2C || I2C=n) && VIDEO_DEV
+	default (I2C || I2C=n) && VIDEO_DEV
+
+config VIDEO_V4L2_SUBDEV_API
+	bool "V4L2 sub-device userspace API (EXPERIMENTAL)"
+	depends on VIDEO_DEV && MEDIA_CONTROLLER && EXPERIMENTAL
+	---help---
+	  Enables the V4L2 sub-device pad-level userspace API used to configure
+	  video format, size and frame rate between hardware blocks.
+
+	  This API is mostly used by camera interfaces in embedded platforms.
+
+#
+# DVB Core
+#
+
+config DVB_CORE
+	tristate "DVB for Linux"
+	select CRC32
+	help
+	  DVB core utility functions for device handling, software fallbacks etc.
+
+	  Enable this if you own a DVB/ATSC adapter and want to use it or if
+	  you compile Linux for a digital SetTopBox.
+
+	  Say Y when you have a DVB or an ATSC card and want to use it.
+
+	  API specs and user tools are available from <http://www.linuxtv.org/>.
+
+	  Please report problems regarding this support to the LinuxDVB
+	  mailing list.
+
+	  If unsure say N.
+
+config DVB_NET
+	bool "DVB Network Support"
+	default (NET && INET)
+	depends on NET && INET && DVB_CORE
+	help
+	  This option enables DVB Network Support which is a part of the DVB
+	  standard. It is used, for example, by automatic firmware updates used
+	  on Set-Top-Boxes. It can also be used to access the Internet via the
+	  DVB card, if the network provider supports it.
+
+	  You may want to disable the network support on embedded devices. If
+	  unsure say Y.
+
+config VIDEO_MEDIA
+	tristate
+	default (DVB_CORE && (VIDEO_DEV = n)) || (VIDEO_DEV && (DVB_CORE = n)) || (DVB_CORE && VIDEO_DEV)
+
+comment "Multimedia drivers"
+
+source "drivers/media/common/Kconfig"
+source "drivers/media/rc/Kconfig"
+
+#
+# Tuner drivers for DVB and V4L
+#
+
+source "drivers/media/common/tuners/Kconfig"
+
+#
+# Video/Radio/Hybrid adapters
+#
+
+source "drivers/media/video/Kconfig"
+
+source "drivers/media/radio/Kconfig"
+
+#
+# DVB adapters
+#
+
+source "drivers/media/dvb/Kconfig"
+
+endif # MEDIA_SUPPORT
diff -urN linux-3.4.3/drivers/staging/media/cxd2099/cxd2099.c linux-3.4.3.dd/drivers/staging/media/cxd2099/cxd2099.c
--- linux-3.4.3/drivers/staging/media/cxd2099/cxd2099.c	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/staging/media/cxd2099/cxd2099.c	2012-06-18 22:32:00.134032202 +0200
@@ -117,9 +117,10 @@
 
 static int read_block(struct cxd *ci, u8 adr, u8 *data, u8 n)
 {
-	int status;
+	int status = 0;
 
-	status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
+	if (ci->lastaddress != adr)
+		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
 	if (!status) {
 		ci->lastaddress = adr;
 		status = i2c_read(ci->i2c, ci->cfg.adr, 1, data, n);
diff -urN linux-3.4.3/drivers/staging/media/cxd2099/Makefile linux-3.4.3.dd/drivers/staging/media/cxd2099/Makefile
--- linux-3.4.3/drivers/staging/media/cxd2099/Makefile	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/drivers/staging/media/cxd2099/Makefile	2012-06-18 22:32:00.134032202 +0200
@@ -1,5 +1,5 @@
 obj-$(CONFIG_DVB_CXD2099) += cxd2099.o
 
-ccflags-y += -Idrivers/media/dvb/dvb-core/
-ccflags-y += -Idrivers/media/dvb/frontends/
-ccflags-y += -Idrivers/media/common/tuners/
+EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core/
+EXTRA_CFLAGS += -Idrivers/media/dvb/frontends/
+EXTRA_CFLAGS += -Idrivers/media/common/tuners/
diff -urN linux-3.4.3/include/linux/dvb/osd.h linux-3.4.3.dd/include/linux/dvb/osd.h
--- linux-3.4.3/include/linux/dvb/osd.h	2012-06-17 20:21:44.000000000 +0200
+++ linux-3.4.3.dd/include/linux/dvb/osd.h	2012-06-18 22:34:49.394032290 +0200
@@ -141,4 +141,20 @@
 #define OSD_SEND_CMD            _IOW('o', 160, osd_cmd_t)
 #define OSD_GET_CAPABILITY      _IOR('o', 161, osd_cap_t)
 
+typedef struct osd_raw_cmd_s {
+	const void __user *cmd_data;
+	int cmd_len;
+	void __user *result_data;
+	int result_len;
+} osd_raw_cmd_t;
+
+typedef struct osd_raw_data_s {
+	const void __user *data_buffer;
+	int data_length;
+	int data_handle;
+} osd_raw_data_t;
+
+#define OSD_RAW_CMD            _IOWR('o', 162, osd_raw_cmd_t)
+#define OSD_RAW_DATA           _IOWR('o', 163, osd_raw_data_t)
+
 #endif
